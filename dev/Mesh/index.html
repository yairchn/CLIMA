<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mesh · CLIMA</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="CLIMA logo"/></a><h1>CLIMA</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Utilites</span><ul><li><a class="toctext" href="../Utilities/RootSolvers/">RootSolvers</a></li><li><a class="toctext" href="../Utilities/MoistThermodynamics/">MoistThermodynamics</a></li></ul></li><li><span class="toctext">Atmos</span><ul><li><a class="toctext" href="../Atmos/SurfaceFluxes/"><code>SurfaceFluxes</code></a></li></ul></li><li><a class="toctext" href="../ODESolvers/">ODESolvers</a></li><li class="current"><a class="toctext" href>Mesh</a><ul class="internal"><li><a class="toctext" href="#Topologies-1"><code>Topologies</code></a></li><li><a class="toctext" href="#Grids-1"><code>Grids</code></a></li></ul></li><li><a class="toctext" href="../AtmosDycore/">AtmosDycore</a></li><li><a class="toctext" href="../TurbulenceConvection/">TurbulenceConvection</a></li><li><span class="toctext">Developer docs</span><ul><li><a class="toctext" href="../CodingConventions/">Coding Conventions</a></li><li><a class="toctext" href="../AcceptableUnicode/">Acceptable Unicode characters:</a></li><li><a class="toctext" href="../VariableList/">CliMA Variable List:</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Mesh</a></li></ul><a class="edit-page" href="https://github.com/climate-machine/CLIMA/blob/master/docs/src/Mesh.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Mesh</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Meshing-Stuff-1" href="#Meshing-Stuff-1">Meshing Stuff</a></h1><h2><a class="nav-anchor" id="Topologies-1" href="#Topologies-1"><code>Topologies</code></a></h2><p>Topologies encode the connectivity of the elements, spatial domain interval and MPI communication.</p><h3><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.Topologies.AbstractTopology" href="#CLIMA.Topologies.AbstractTopology"><code>CLIMA.Topologies.AbstractTopology</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractTopology{dim}</code></pre><p>Represents the connectivity of individual elements, with local dimension <code>dim</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/5221f1742da7220b1d797a032a8cabbf9fe84889/src/Mesh/Topologies.jl#L7-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.Topologies.BoxElementTopology" href="#CLIMA.Topologies.BoxElementTopology"><code>CLIMA.Topologies.BoxElementTopology</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BoxElementTopology{dim, T} &lt;: AbstractTopology{dim}</code></pre><p>The local topology of a larger MPI-distributed topology, represented by <code>dim</code>-dimensional box elements.</p><p>This contains the necessary information for the connectivity elements of the elements on the local process, along with &quot;ghost&quot; elements from neighbouring processes.</p><p><strong>Fields</strong></p><ul><li><p><code>mpicomm</code></p><p>MPI communicator for communicating with neighbouring processes.</p></li></ul><ul><li><p><code>elems</code></p><p>Range of element indices</p></li></ul><ul><li><p><code>realelems</code></p><p>Range of real (aka nonghost) element indices</p></li></ul><ul><li><p><code>ghostelems</code></p><p>Range of ghost element indices</p></li></ul><ul><li><p><code>sendelems</code></p><p>Array of send element indices sorted so that</p></li></ul><ul><li><p><code>elemtocoord</code></p><p>Element to vertex coordinates; <code>elemtocoord[d,i,e]</code> is the <code>d</code>th coordinate of corner <code>i</code> of element <code>e</code></p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>currently coordinates always are of size 3 for <code>(x, y, z)</code></p></div></div></li></ul><ul><li><p><code>elemtoelem</code></p><p>Element to neighboring element; <code>elemtoelem[f,e]</code> is the number of the element neighboring element <code>e</code> across face <code>f</code>.  If there is no neighboring element then <code>elemtoelem[f,e] == e</code>.</p></li></ul><ul><li><p><code>elemtoface</code></p><p>Element to neighboring element face; <code>elemtoface[f,e]</code> is the face number of the element neighboring element <code>e</code> across face <code>f</code>.  If there is no neighboring element then <code>elemtoface[f,e] == f</code>.&quot;</p></li></ul><ul><li><p><code>elemtoordr</code></p><p>element to neighboring element order; <code>elemtoordr[f,e]</code> is the ordering number of the element neighboring element <code>e</code> across face <code>f</code>.  If there is no neighboring element then <code>elemtoordr[f,e] == 1</code>.</p></li></ul><ul><li><p><code>elemtobndy</code></p><p>Element to bounday number; <code>elemtobndy[f,e]</code> is the boundary number of face <code>f</code> of element <code>e</code>.  If there is a neighboring element then <code>elemtobndy[f,e] == 0</code>.</p></li></ul><ul><li><p><code>nabrtorank</code></p><p>List of the MPI ranks for the neighboring processes</p></li></ul><ul><li><p><code>nabrtorecv</code></p><p>Range in ghost elements to receive for each neighbor</p></li></ul><ul><li><p><code>nabrtosend</code></p><p>Range in <code>sendelems</code> to send for each neighbor</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/5221f1742da7220b1d797a032a8cabbf9fe84889/src/Mesh/Topologies.jl#L17-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.Topologies.BrickTopology" href="#CLIMA.Topologies.BrickTopology"><code>CLIMA.Topologies.BrickTopology</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BrickTopology{dim, T} &lt;: AbstractTopology{dim}</code></pre><p>A simple grid-based topolgy. This is a convenience wrapper around <a href="#CLIMA.Topologies.BoxElementTopology"><code>BoxElementTopology</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/5221f1742da7220b1d797a032a8cabbf9fe84889/src/Mesh/Topologies.jl#L110-L114">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.Topologies.StackedBrickTopology" href="#CLIMA.Topologies.StackedBrickTopology"><code>CLIMA.Topologies.StackedBrickTopology</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">StackedBrickTopology{dim, T} &lt;: AbstractTopology{dim}</code></pre><p>A simple grid-based topolgy, where all elements on the trailing dimension are stacked to be contiguous. This is a convenience wrapper around <a href="#CLIMA.Topologies.BoxElementTopology"><code>BoxElementTopology</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/5221f1742da7220b1d797a032a8cabbf9fe84889/src/Mesh/Topologies.jl#L131-L135">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.Topologies.CubedShellTopology" href="#CLIMA.Topologies.CubedShellTopology"><code>CLIMA.Topologies.CubedShellTopology</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">CubedShellTopology{T} &lt;: AbstractTopology{2}</code></pre><p>A cube-shell topolgy. This is a convenience wrapper around <a href="#CLIMA.Topologies.BoxElementTopology"><code>BoxElementTopology</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/5221f1742da7220b1d797a032a8cabbf9fe84889/src/Mesh/Topologies.jl#L120-L124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.Topologies.StackedCubedSphereTopology" href="#CLIMA.Topologies.StackedCubedSphereTopology"><code>CLIMA.Topologies.StackedCubedSphereTopology</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">StackedCubedSphereTopology{3, T} &lt;: AbstractTopology{3}</code></pre><p>A cube-sphere topology. All elements on the same &quot;vertical&quot; dimension are stacked to be contiguous. This is a convenience wrapper around <a href="#CLIMA.Topologies.BoxElementTopology"><code>BoxElementTopology</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/5221f1742da7220b1d797a032a8cabbf9fe84889/src/Mesh/Topologies.jl#L144-L148">source</a></section><h3><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.Topologies.cubedshellmesh" href="#CLIMA.Topologies.cubedshellmesh"><code>CLIMA.Topologies.cubedshellmesh</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">cubedshellmesh(T, Ne; part=1, numparts=1)</code></pre><p>Generate a cubed mesh with each of the &quot;cubes&quot; has an <code>Ne X Ne</code> grid of elements.</p><p>The mesh can optionally be partitioned into <code>numparts</code> and this returns partition <code>part</code>.  This is a simple Cartesian partition and further partitioning (e.g, based on a space-filling curve) should be done before the mesh is used for computation.</p><p>This mesh returns the cubed spehere in a flatten fashion for the vertex values, and a remapping is needed to embed the mesh in a 3-D space.</p><p>The mesh structures for the cubes is as follows:</p><pre><code class="language-none">x_2
   ^
   |
4Ne-           +-------+
   |           |       |
   |           |   6   |
   |           |       |
3Ne-           +-------+
   |           |       |
   |           |   5   |
   |           |       |
2Ne-           +-------+
   |           |       |
   |           |   4   |
   |           |       |
 Ne-   +-------+-------+-------+
   |   |       |       |       |
   |   |   1   |   2   |   3   |
   |   |       |       |       |
  0-   +-------+-------+-------+
   |
   +---|-------|-------|------|-&gt; x_1
       0      Ne      2Ne    3Ne</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/5221f1742da7220b1d797a032a8cabbf9fe84889/src/Mesh/Topologies.jl#L599-L640">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.Topologies.cubedshellwarp" href="#CLIMA.Topologies.cubedshellwarp"><code>CLIMA.Topologies.cubedshellwarp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">cubedshellwarp(a, b, c, R = max(abs(a), abs(b), abs(c)))</code></pre><p>Given points <code>(a, b, c)</code> on the surface of a cube, warp the points out to a spherical shell of radius <code>R</code> based on the equiangular gnomonic grid proposed by Ronchi, Iacono, Paolucci (1996) <a href="https://dx.doi.org/10.1006/jcph.1996.0047">https://dx.doi.org/10.1006/jcph.1996.0047</a></p><pre><code class="language-none">@article{RonchiIaconoPaolucci1996,
  title={The ``cubed sphere&#39;&#39;: a new method for the solution of partial
         differential equations in spherical geometry},
  author={Ronchi, C. and Iacono, R. and Paolucci, P. S.},
  journal={Journal of Computational Physics},
  volume={124},
  number={1},
  pages={93--114},
  year={1996},
  doi={10.1006/jcph.1996.0047}
}</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/5221f1742da7220b1d797a032a8cabbf9fe84889/src/Mesh/Topologies.jl#L700-L721">source</a></section><h2><a class="nav-anchor" id="Grids-1" href="#Grids-1"><code>Grids</code></a></h2><p>Grids specify the approximation within each element, and any necessary warping.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.Grids.DiscontinuousSpectralElementGrid" href="#CLIMA.Grids.DiscontinuousSpectralElementGrid"><code>CLIMA.Grids.DiscontinuousSpectralElementGrid</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DiscontinuousSpectralElementGrid(topology; FloatType, DeviceArray,
                                 polynomialorder,
                                 meshwarp = (x...)-&gt;identity(x))</code></pre><p>Generate a discontinuous spectral element (tensor product, Legendre-Gauss-Lobatto) grid/mesh from a <code>topology</code>, where the order of the elements is given by <code>polynomialorder</code>. <code>DeviceArray</code> gives the array type used to store the data (<code>CuArray</code> or <code>Array</code>), and the coordinate points will be of <code>FloatType</code>.</p><p>The optional <code>meshwarp</code> function allows the coordinate points to be warped after the mesh is created; the mesh degrees of freedom are orginally assigned using a trilinear blend of the element corner locations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/5221f1742da7220b1d797a032a8cabbf9fe84889/src/Mesh/Grids.jl#L26-L40">source</a></section><footer><hr/><a class="previous" href="../ODESolvers/"><span class="direction">Previous</span><span class="title">ODESolvers</span></a><a class="next" href="../AtmosDycore/"><span class="direction">Next</span><span class="title">AtmosDycore</span></a></footer></article></body></html>
