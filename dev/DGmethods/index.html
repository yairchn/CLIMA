<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DGmethods · CLIMA</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="CLIMA logo"/></a><h1>CLIMA</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Utilites</span><ul><li><a class="toctext" href="../Utilities/RootSolvers/">RootSolvers</a></li><li><a class="toctext" href="../Utilities/MoistThermodynamics/">MoistThermodynamics</a></li></ul></li><li><span class="toctext">Atmos</span><ul><li><a class="toctext" href="../Atmos/SurfaceFluxes/"><code>SurfaceFluxes</code></a></li><li><a class="toctext" href="../Atmos/TurbulenceConvection/"><code>TurbulenceConvection</code></a></li><li><a class="toctext" href="../Atmos/EDMFEquations/">Eddy-Diffusivity Mass-Flux (EDMF) equations</a></li></ul></li><li><a class="toctext" href="../ODESolvers/">ODESolvers</a></li><li><a class="toctext" href="../Mesh/">Mesh</a></li><li><a class="toctext" href="../AtmosDycore/">AtmosDycore</a></li><li><a class="toctext" href="../Arrays/">Arrays</a></li><li class="current"><a class="toctext" href>DGmethods</a><ul class="internal"><li><a class="toctext" href="#SpaceMethods-1"><code>SpaceMethods</code></a></li><li><a class="toctext" href="#DGBalanceLawDiscretizations-1"><code>DGBalanceLawDiscretizations</code></a></li><li><a class="toctext" href="#DGBalanceLawDiscretizations.NumericalFluxes-1"><code>DGBalanceLawDiscretizations.NumericalFluxes</code></a></li></ul></li><li><span class="toctext">Developer docs</span><ul><li><a class="toctext" href="../CodingConventions/">Coding Conventions</a></li><li><a class="toctext" href="../AcceptableUnicode/">Acceptable Unicode characters</a></li><li><a class="toctext" href="../VariableList/">CliMA Variable List</a></li></ul></li><li><span class="toctext">Balance Law Examples</span><ul><li><a class="toctext" href="../BalanceLawOverview/">DG Balance Law Method</a></li><li><a class="toctext" href="../examples/DGmethods/generated/ex_001_periodic_advection/">Example 001: Periodic Advection</a></li><li><a class="toctext" href="../examples/DGmethods/generated/ex_002_solid_body_rotation/">Example 002: Solid Body Rotation</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>DGmethods</a></li></ul><a class="edit-page" href="https://github.com/climate-machine/CLIMA/blob/master/docs/src/DGmethods.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>DGmethods</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="ODESolvers-1" href="#ODESolvers-1">ODESolvers</a></h1><h2><a class="nav-anchor" id="SpaceMethods-1" href="#SpaceMethods-1"><code>SpaceMethods</code></a></h2><p>Set of abstract types for spatial discretizations</p><h3><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.SpaceMethods.AbstractSpaceMethod" href="#CLIMA.SpaceMethods.AbstractSpaceMethod"><code>CLIMA.SpaceMethods.AbstractSpaceMethod</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractSpaceMethod</code></pre><p>Supertype for spatial discretizations</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/af4371e9a6658c1c9b529fbd73e4765271322ed3/src/DGmethods/SpaceMethods.jl#L5-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.SpaceMethods.AbstractDGMethod" href="#CLIMA.SpaceMethods.AbstractDGMethod"><code>CLIMA.SpaceMethods.AbstractDGMethod</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractDGMethod &lt;: AbstractSpaceMethod</code></pre><p>Supertype for discontinuous Galerkin spatial discretizations</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/af4371e9a6658c1c9b529fbd73e4765271322ed3/src/DGmethods/SpaceMethods.jl#L12-L16">source</a></section><h3><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.SpaceMethods.odefun!" href="#CLIMA.SpaceMethods.odefun!"><code>CLIMA.SpaceMethods.odefun!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">odefun!(disc::DGBalanceLaw, dQ::MPIStateArray, Q::MPIStateArray, t)</code></pre><p>Evaluates the right-hand side of the discontinuous Galerkin semi-discretization defined by <code>disc</code> at time <code>t</code> with state <code>Q</code>. The result is added into <code>dQ</code>. Namely, the semi-discretization is of the form</p><div>\[Q̇ = F(Q, t)\]</div><p>and after the call <code>dQ += F(Q, t)</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/af4371e9a6658c1c9b529fbd73e4765271322ed3/src/DGmethods/DGBalanceLawDiscretizations.jl#L577-L587">source</a><div><div><pre><code class="language-julia">odefun!(disc::AbstractSpaceMethod, dQ, Q, t)</code></pre><p>Evaluates the right-hand side of the spatial discretization defined by <code>disc</code> at time <code>t</code> with state <code>Q</code>. The result is added into <code>dQ</code>. Namely, the semi-discretization is of the form <span>$Q̇ = F(Q, t)$</span> and after the call <code>dQ += F(Q, t)</code></p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>There is no generic implementation of this function. This must be implemented for each subtype of <code>AbstractSpaceMethod</code></p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/af4371e9a6658c1c9b529fbd73e4765271322ed3/src/DGmethods/SpaceMethods.jl#L19-L34">source</a></section><h2><a class="nav-anchor" id="DGBalanceLawDiscretizations-1" href="#DGBalanceLawDiscretizations-1"><code>DGBalanceLawDiscretizations</code></a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations" href="#CLIMA.DGBalanceLawDiscretizations"><code>CLIMA.DGBalanceLawDiscretizations</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>DG Balance Law Discretizations module. Attempts to provide a reasonable implementation of a discontinuous Galerkin method (in weak form) on tensor product quadrilateral (2D) and hexahedral (3D) elements for balance laws of the form</p><div>\[q_{,t} + Σ_{i=1,...d} F_{i,i} = s\]</div><p>where <span>$q$</span> is the state vector, <span>$F$</span> is the flux function, and <span>$s$</span> is the source function. <span>$F$</span> includes both the &quot;inviscid&quot; and &quot;viscous&quot; fluxes. Note that this is a space only discretization, time must be advanced using some ordinary differential equations methods; see <a href="@ref"><code>ODESolvers</code></a>.</p><p>The flux function <code>F_{i}</code> is taken to be of the form:</p><div>\[F_{i} := F_{i}(q, σ; a)
σ = H(q, ∇G(q; a); a)\]</div><p>where <span>$a$</span> is a set of parameters and viscous terms enter through <span>$σ$</span></p><p>The source term is of the form:</p><div>\[s := s(q; a)\]</div><p>In the code and docs the following terminology is used:</p><ul><li><span>$q$</span> is referred to as the state</li><li><span>$σ$</span> is the viscous state</li><li><span>$a$</span> is the auxiliary state</li><li><span>$F$</span> is the physical flux</li><li><span>$H$</span> is the viscous transform</li><li><span>$G$</span> is the gradient transform</li></ul><p>Much of the notation used in this module follows Hesthaven and Warburton (2008).</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Currently all the functions take the same parameters and the gradient transform can take a user-specified subset of the state vector.</p></div></div><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>We plan to switch to a skew-symmetric formulation (at which time this note will be removed)</p></div></div><div class="admonition references"><div class="admonition-title">References</div><div class="admonition-text"><pre><code class="language-none">@BOOK{HesthavenWarburton2008,
  title = {Nodal Discontinuous {G}alerkin Methods: {A}lgorithms, Analysis,
           and Applications},
  publisher = {Springer-Verlag New York},
  year = {2008},
  author = {Hesthaven, Jan S. and Warburton, Tim},
  volume = {54},
  series = {Texts in Applied Mathematics},
  doi = {10.1007/978-0-387-72067-8}
}</code></pre></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/af4371e9a6658c1c9b529fbd73e4765271322ed3/src/DGmethods/DGBalanceLawDiscretizations.jl#L1-L62">source</a></section><h3><a class="nav-anchor" id="Types-2" href="#Types-2">Types</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw" href="#CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw"><code>CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DGBalanceLaw &lt;: AbstractDGMethod</code></pre><p>This contains the necessary information for a discontinuous Galerkin method for balance laws.</p><p>See also: Outer constructor <a href="#CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw"><code>DGBalanceLaw</code></a></p><p><strong>Fields</strong></p><ul><li><p><code>grid</code></p><p>computational grid / mesh</p></li><li><p><code>nstate</code></p><p>number of state</p></li><li><p><code>flux!</code></p><p>physical flux function</p></li><li><p><code>numerical_flux!</code></p><p>numerical flux function</p></li><li><p><code>numerical_boundary_flux!</code></p><p>numerical boundary flux function</p></li><li><p><code>Qvisc</code></p><p>storage for the viscous state</p></li><li><p><code>number_gradient_states</code></p><p>number of out states for gradient_transform!</p></li><li><p><code>number_viscous_states</code></p><p>number of out states for the viscous_transform!</p></li><li><p><code>states_for_gradient_transform</code></p><p>tuple of states going into gradient_transform!</p></li><li><p><code>gradient_transform!</code></p><p>transform from state to variables to take gradient of</p></li><li><p><code>viscous_transform!</code></p><p>transform from Q and gradient state to viscous states</p></li><li><p><code>viscous_penalty!</code></p><p>penalty for the viscous state computation</p></li><li><p><code>viscous_boundary_penalty!</code></p><p>boundary penalty for the viscous state computation (e.g., Dirichlet)</p></li><li><p><code>auxstate</code></p><p>auxiliary state array</p></li><li><p><code>source!</code></p><p>source function</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/af4371e9a6658c1c9b529fbd73e4765271322ed3/src/DGmethods/DGBalanceLawDiscretizations.jl#L88-L100">source</a></section><h3><a class="nav-anchor" id="Constructor-1" href="#Constructor-1">Constructor</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw-Tuple{}" href="#CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw-Tuple{}"><code>CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">DGBalanceLaw(;grid::DiscontinuousSpectralElementGrid,
             length_state_vector,
             flux!,
             numerical_flux!,
             numerical_boundary_flux! = nothing,
             states_for_gradient_transform = (),
             number_gradient_states = 0,
             number_viscous_states = 0,
             gradient_transform! = nothing,
             viscous_transform! = nothing,
             viscous_penalty! = nothing,
             viscous_boundary_penalty! = nothing,
             auxiliary_state_length = 0,
             auxiliary_state_initialization! = nothing,
             source! = nothing)</code></pre><p>Constructs a <code>DGBalanceLaw</code> spatial discretization type for the physics defined by <code>flux!</code> and <code>source!</code>. The computational domain is defined by <code>grid</code>. The number of state variables is defined by <code>length_state_vector</code>. The user may also specify an auxiliary state which will be unpacked by the compute kernel passed on to the user-defined flux and numerical flux functions. The source function <code>source!</code> is optional.</p><p>The flux function is called with data from a degree of freedom (DOF) as</p><pre><code class="language-none">flux!(F, Q, V, aux, t)</code></pre><p>where</p><ul><li><code>F</code> is an <code>MArray</code> of size <code>(dim, length_state_vector)</code> to be filled (note that this is uninitialized so the user must set to zero if is this desired)</li><li><code>Q</code> is the state to evaluate (<code>MArray</code>)</li><li><code>V</code> is the viscous state to evaluate (<code>MArray</code>)</li><li><code>aux</code> is the user-defined auxiliary state (<code>MArray</code>)</li><li><code>t</code> is the current simulation time</li></ul><p>Warning: Modifications to <code>Q</code> or <code>aux</code> may cause side effects and should be avoided.</p><p>The numerical flux function is called with data from two DOFs as</p><pre><code class="language-none">numerical_flux!(F, nM, QM, VM, auxM, QP, VP, auxP, t)</code></pre><p>where</p><ul><li><code>F</code> is an <code>MVector</code> of length <code>length_state_vector</code> to be filled with the numerical flux across the face (note that this is uninitialized so user must set to zero if is this desired)</li><li><code>nM</code> is the unit outward normal to the face with respect to the minus side (<code>MVector</code> of length <code>3</code>)</li><li><code>QM</code> and <code>QP</code> are the minus and plus side states (<code>MArray</code>)</li><li><code>VM</code> and <code>VP</code> are the minus and plus viscous side states (<code>MArray</code>)</li><li><code>auxM</code> and <code>auxP</code> are the auxiliary states (<code>MArray</code>)</li><li><code>t</code> is the current simulation time</li></ul><p>Warning: Modifications to <code>nM</code>, <code>QM</code>, <code>auxM</code>, <code>QP</code>, or <code>auxP</code> may cause side effects and should be avoided.</p><p>If <code>grid.topology</code> has a boundary then the function <code>numerical_boundary_flux!</code> must be specified. This function is called with the data from the neighbouring DOF as</p><pre><code class="language-none">numerical_boundary_flux!(F, nM, QM, VM, auxM, QP, VP, auxP, bctype, t)</code></pre><p>where</p><ul><li><code>F</code> is an <code>MArray</code> of size <code>(dim, length_state_vector)</code> to be filled with the numerical flux across the face (note that this is uninitialized so user must set to zero is this desired)</li><li><code>nM</code> is the unit outward normal to the face with respect to the minus side (<code>MVector</code> of length <code>3</code>)</li><li><code>QM</code> and <code>QP</code> are the minus and plus side states (<code>MArray</code>)</li><li><code>VM</code> and <code>VP</code> are the minus and plus viscous side states (<code>MArray</code>)</li><li><code>auxM</code> and <code>auxP</code> are the auxiliary states (<code>MArray</code>)</li><li><code>bctype</code> is the boundary condition flag for the connected face and element of  <code>grid.elemtobndy</code></li><li><code>t</code> is the current simulation time</li></ul><p>Note: <code>QP</code> and <code>auxP</code> are filled with values based on degrees of freedom referenced in <code>grid.vmapP</code>; <code>QP</code> and <code>auxP</code> may be modified by the calling function.</p><p>Warning: Modifications to <code>nM</code>, <code>QM</code>, or <code>auxM</code> may cause side effects and should be avoided.</p><p>If present the source function is called with data from a DOF as</p><pre><code class="language-none">source!(S, Q, aux, t)</code></pre><p>where <code>S</code> is an <code>MVector</code> of length <code>length_state_vector</code> to be filled; other arguments are the same as <code>flux!</code> and the same warning concerning <code>Q</code> and <code>aux</code> applies.</p><p>When <code>auxiliary_state_initialization! !== nothing</code> then this is called on the auxiliary state (assuming <code>auxiliary_state_length &gt; 0</code>) as</p><pre><code class="language-none">auxiliary_state_initialization!(aux, x, y, z)</code></pre><p>where <code>aux</code> is an <code>MArray</code> to fill with the auxiliary state for a DOF located at Cartesian coordinate locations <code>(x, y, z)</code>; see also <a href="#CLIMA.DGBalanceLawDiscretizations.grad_auxiliary_state!"><code>grad_auxiliary_state!</code></a> allows the user to take the gradient of a field stored in the auxiliary state.</p><p>When viscous terms are needed, the user must specify values for the following keyword arguments:</p><ul><li><code>states_for_gradient_transform</code> (<code>Tuple</code>)</li><li><code>number_gradient_states</code> (<code>Int</code>)</li><li><code>number_viscous_states</code> (<code>Int</code>)</li><li><code>gradient_transform!</code> (<code>Function</code>)</li><li><code>viscous_transform!</code> (<code>Function</code>)</li><li><code>viscous_penalty!</code> (<code>Function</code>)</li><li><code>viscous_boundary_penalty!</code> (<code>Function</code>); only required if the topology has a boundary</li></ul><p>The function <code>gradient_transform!</code> is the implementation of the function <code>G</code> in the module docs; see <a href="#CLIMA.DGBalanceLawDiscretizations"><code>DGBalanceLawDiscretizations</code></a>. It transforms the elements of the components of state vector specified by <code>states_for_gradient_transform</code> into the values that should have their gradient taken. It is called on each DOF as:</p><pre><code class="language-none">gradient_transform!(G, Q, aux, t)</code></pre><p>where <code>G</code> is an <code>MVector</code> of length <code>number_gradient_states</code> to be filled, <code>Q</code> is an <code>MVector</code> containing only the states specified by <code>states_for_gradient_transform</code>, <code>aux</code> is the full auxiliary state at the DOF, and <code>t</code> is the simulation time.Q</p><p>The function <code>viscous_transform!</code> is the implementation of the function <code>H</code> in the module docs; see <a href="#CLIMA.DGBalanceLawDiscretizations"><code>DGBalanceLawDiscretizations</code></a>. It transforms the gradient <span>$∇G$</span> and <span>$q$</span> into the viscous state <span>$σ$</span>. It is called on each DOF as:</p><pre><code class="language-none">viscous_transform!(V, gradG, Q, aux, t)</code></pre><p>where <code>V</code> is an <code>MVector</code> of length <code>number_viscous_states</code> to be filled, <code>gradG</code> is an <code>MMatrix</code> containing the DG-gradient of <span>$G$</span>, <code>Q</code> is an <code>MVector</code> containing only the states specified by <code>states_for_gradient_transform</code>, <code>aux</code> is the full auxiliary state at the DOF, and <code>t</code> is the simulation time. Note that <code>V</code> is a vector not a matrix so that minimal storage can be used if symmetry can be exploited.</p><p>The function <code>viscous_penalty!</code> is the penalty terms to be used for the DG-gradient calculation. It is called with data from two neighbouring degrees of freedom as</p><pre><code class="language-none">viscous_penalty!(V, nM, HM, QM, auxM, HP, QP, auxP, t)</code></pre><p>where:</p><ul><li><code>V</code> is an <code>MVector</code> of length <code>number_viscous_states</code> to be filled with the numerical penalty across the face; see below.</li><li><code>nM</code> is the unit outward normal to the face with respect to the minus side (<code>MVector</code> of length <code>3</code>)</li><li><code>HM</code> and <code>HP</code> are the minus and plus evaluation of <code>gradient_transform!</code> on either side of the face</li><li><code>QM</code> and <code>QP</code> are the minus and plus side states (<code>MArray</code>); filled only with <code>states_for_gradient_transform</code> states.</li><li><code>auxM</code> and <code>auxP</code> are the auxiliary states (<code>MArray</code>)</li><li><code>t</code> is the current simulation time</li></ul><p>The viscous penalty function is should compute on the faces</p><div>\[n^{-} \cdot H^{*} - n^{-} \cdot H^{-}\]</div><p>where <span>$n^{-} \cdot H^{*}$</span> is the &quot;numerical-flux&quot; for the viscous state computation and <span>$H^{-}$</span> is the value of <code>viscous_transform!</code> evaluated on the minus side <span>$n^{-} \cdot G^{-}$</span> as an argument.</p><p>If <code>grid.topology</code> has a boundary then the function <code>viscous_boundary_penalty!</code> must be specified. This function is called with the data from the neighbouring DOF as</p><pre><code class="language-none">viscous_boundary_penalty!(V, nM, HM, QM, auxM, HP, QP, auxP, bctype, t)</code></pre><p>where the required behaviour mimics that of <code>viscous_penalty!</code> and <code>numerical_boundary_flux!</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If <code>(x, y, z)</code>, or data derived from this such as spherical coordinates, is needed in the flux or source the user is responsible to storing this in the auxiliary state</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/af4371e9a6658c1c9b529fbd73e4765271322ed3/src/DGmethods/DGBalanceLawDiscretizations.jl#L148-L324">source</a></section><h3><a class="nav-anchor" id="Functions-2" href="#Functions-2">Functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.writevtk" href="#CLIMA.DGBalanceLawDiscretizations.writevtk"><code>CLIMA.DGBalanceLawDiscretizations.writevtk</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">writevtk(prefix, Q::MPIStateArray, disc::DGBalanceLaw [, fieldnames])</code></pre><p>Write a vtk file for all the fields in the state array <code>Q</code> using geometry and connectivity information from <code>disc.grid</code>. The filename will start with <code>prefix</code> which may also contain a directory path. The names used for each of the fields in the vtk file can be specified through the collection of strings <code>fieldnames</code>; if not specified the fields names will be <code>&quot;Q1&quot;</code> through <code>&quot;Qk&quot;</code> where <code>k</code> is the number of states in <code>Q</code>, i.e., <code>k = size(Q,2)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/af4371e9a6658c1c9b529fbd73e4765271322ed3/src/DGmethods/DGBalanceLawDiscretizations.jl#L529-L539">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.writevtk_helper" href="#CLIMA.DGBalanceLawDiscretizations.writevtk_helper"><code>CLIMA.DGBalanceLawDiscretizations.writevtk_helper</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">writevtk_helper(prefix, vgeo::Array, Q::Array, grid, fieldnames)</code></pre><p>Internal helper function for <code>writevtk</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/af4371e9a6658c1c9b529fbd73e4765271322ed3/src/DGmethods/DGBalanceLawDiscretizations.jl#L549-L553">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.grad_auxiliary_state!" href="#CLIMA.DGBalanceLawDiscretizations.grad_auxiliary_state!"><code>CLIMA.DGBalanceLawDiscretizations.grad_auxiliary_state!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">grad_auxiliary_state!(disc, i, (ix, iy, iz))</code></pre><p>Computes the gradient of a the field <code>i</code> of the constant auxiliary state of <code>disc</code> and stores the <code>x, y, z</code> compoment in fields <code>ix, iy, iz</code> of constant auxiliary state.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This only computes the element gradient not a DG gradient. If your constant auxiliary state is discontinuous this may or may not be what you want!</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/af4371e9a6658c1c9b529fbd73e4765271322ed3/src/DGmethods/DGBalanceLawDiscretizations.jl#L663-L674">source</a></section><h3><a class="nav-anchor" id="Pirated-Type-Functions-1" href="#Pirated-Type-Functions-1">Pirated Type Functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.MPIStateArrays.MPIStateArray-Tuple{CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw}" href="#CLIMA.MPIStateArrays.MPIStateArray-Tuple{CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw}"><code>CLIMA.MPIStateArrays.MPIStateArray</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">MPIStateArray(disc::DGBalanceLaw; commtag=888)</code></pre><p>Given a discretization <code>disc</code> constructs an <code>MPIStateArrays</code> for holding a solution state. The optional <code>commtag</code> allows the user to set the tag to use for communication with this <code>MPIStateArray</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/af4371e9a6658c1c9b529fbd73e4765271322ed3/src/DGmethods/DGBalanceLawDiscretizations.jl#L411-L417">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.MPIStateArrays.MPIStateArray-Tuple{CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw,Function}" href="#CLIMA.MPIStateArrays.MPIStateArray-Tuple{CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw,Function}"><code>CLIMA.MPIStateArrays.MPIStateArray</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">MPIStateArray(disc::DGBalanceLaw, initialization!::Function; commtag=888)</code></pre><p>Given a discretization <code>disc</code> constructs an <code>MPIStateArrays</code> for holding a solution state. The optional <code>commtag</code> allows the user to set the tag to use for communication with this <code>MPIStateArray</code>.</p><p>After allocation the <code>MPIStateArray</code> is initialized using the function <code>initialization!</code> which will be called as:</p><pre><code class="language-none">initialization!(Q, x, y, z, [aux])</code></pre><p>where <code>Q</code> is an <code>MArray</code> with the solution state at a single degree of freedom (DOF) to initialize and <code>(x,y,z)</code> is the coordinate point for the allocation. If <code>disc</code> contains an auxiliary data the values of this at the DOF are passed through as an <code>MArray</code> through the <code>aux</code> argument</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>Q</code> is <code>undef</code> at start the function (i.e., not initialized to zero)</p></div></div><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Modifications of the <code>aux</code> array will be discarded.</p></div></div><div class="admonition todo"><div class="admonition-title">Todo</div><div class="admonition-text"><p>GPUify this function to remove <code>host</code> and <code>device</code> data transfers</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/af4371e9a6658c1c9b529fbd73e4765271322ed3/src/DGmethods/DGBalanceLawDiscretizations.jl#L440-L469">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.SpaceMethods.odefun!-Tuple{CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw,Any,Any,Any}" href="#CLIMA.SpaceMethods.odefun!-Tuple{CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw,Any,Any,Any}"><code>CLIMA.SpaceMethods.odefun!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">odefun!(disc::AbstractSpaceMethod, dQ, Q, t)</code></pre><p>Evaluates the right-hand side of the spatial discretization defined by <code>disc</code> at time <code>t</code> with state <code>Q</code>. The result is added into <code>dQ</code>. Namely, the semi-discretization is of the form <span>$Q̇ = F(Q, t)$</span> and after the call <code>dQ += F(Q, t)</code></p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>There is no generic implementation of this function. This must be implemented for each subtype of <code>AbstractSpaceMethod</code></p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/af4371e9a6658c1c9b529fbd73e4765271322ed3/src/DGmethods/SpaceMethods.jl#L19-L34">source</a></section><h3><a class="nav-anchor" id="Kernels-1" href="#Kernels-1">Kernels</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.volumerhs!" href="#CLIMA.DGBalanceLawDiscretizations.volumerhs!"><code>CLIMA.DGBalanceLawDiscretizations.volumerhs!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">volumerhs!(::Val{dim}, ::Val{N}, ::Val{nstate}, ::Val{nviscstate},
           ::Val{nauxstate}, flux!, source!, rhs::Array, Q, Qvisc, auxstate,
           vgeo, t, D, elems) where {dim, N, nstate, nviscstate,</code></pre><p>Computational kernel: Evaluate the volume integrals on right-hand side of a <code>DGBalanceLaw</code> semi-discretization.</p><p>See <a href="#CLIMA.SpaceMethods.odefun!"><code>odefun!</code></a> for usage.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/af4371e9a6658c1c9b529fbd73e4765271322ed3/src/DGmethods/DGBalanceLawDiscretizations_kernels.jl#L1-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.facerhs!" href="#CLIMA.DGBalanceLawDiscretizations.facerhs!"><code>CLIMA.DGBalanceLawDiscretizations.facerhs!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">facerhs!(::Val{dim}, ::Val{N}, ::Val{nstate}, ::Val{nviscstate},
         ::Val{nauxstate}, numerical_flux!,
         numerical_boundary_flux!, rhs::Array, Q, Qvisc, auxstate,
         vgeo, sgeo, t, vmapM, vmapP, elemtobndy,
         elems) where {dim, N, nstate, nviscstate, nauxstate}</code></pre><p>Computational kernel: Evaluate the surface integrals on right-hand side of a <code>DGBalanceLaw</code> semi-discretization.</p><p>See <a href="#CLIMA.SpaceMethods.odefun!"><code>odefun!</code></a> for usage.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/af4371e9a6658c1c9b529fbd73e4765271322ed3/src/DGmethods/DGBalanceLawDiscretizations_kernels.jl#L105-L116">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.initauxstate!" href="#CLIMA.DGBalanceLawDiscretizations.initauxstate!"><code>CLIMA.DGBalanceLawDiscretizations.initauxstate!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">initauxstate!(::Val{dim}, ::Val{N}, ::Val{nauxstate}, auxstatefun!,
              auxstate, vgeo, elems) where {dim, N, nauxstate}</code></pre><p>Computational kernel: Initialize the auxiliary state</p><p>See <a href="#CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw"><code>DGBalanceLaw</code></a> for usage.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/af4371e9a6658c1c9b529fbd73e4765271322ed3/src/DGmethods/DGBalanceLawDiscretizations_kernels.jl#L372-L379">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.elem_grad_field!" href="#CLIMA.DGBalanceLawDiscretizations.elem_grad_field!"><code>CLIMA.DGBalanceLawDiscretizations.elem_grad_field!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">elem_grad_field!(::Val{dim}, ::Val{N}, ::Val{nstate}, Q, vgeo, D, elems, s,
                 sx, sy, sz) where {dim, N, nstate}</code></pre><p>Computational kernel: Compute the element gradient of state <code>s</code> of <code>Q</code> and store it in <code>sx</code>, <code>sy</code>, and <code>sz</code> of <code>Q</code>.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>This does not compute a DG gradient, but only over the element. If <span>$Q_s$</span> is discontinuous you may want to consider another approach.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/af4371e9a6658c1c9b529fbd73e4765271322ed3/src/DGmethods/DGBalanceLawDiscretizations_kernels.jl#L415-L427">source</a></section><h2><a class="nav-anchor" id="DGBalanceLawDiscretizations.NumericalFluxes-1" href="#DGBalanceLawDiscretizations.NumericalFluxes-1"><code>DGBalanceLawDiscretizations.NumericalFluxes</code></a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.NumericalFluxes.rusanov!" href="#CLIMA.DGBalanceLawDiscretizations.NumericalFluxes.rusanov!"><code>CLIMA.DGBalanceLawDiscretizations.NumericalFluxes.rusanov!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rusanov!(F::MArray, nM, QM, QVM, auxM, QP, QVP, auxP, t, flux!, wavespeed,
         [preflux = (_...) -&gt; (), computeQjump!])</code></pre><p>Calculate the Rusanov (aka local Lax-Friedrichs) numerical flux given the plus and minus side states/viscous states <code>QP</code>/<code>QVP</code> and <code>QM</code>/<code>QVM</code> using the physical flux function <code>flux!</code> and <code>wavespeed</code> calculation.</p><p>The <code>flux!</code> has almost the same calling convention as <code>flux!</code> from <a href="@ref"><code>DGBalanceLaw</code></a> except that <code>preflux(Q, aux, t)</code> is splatted at the end of the call.</p><p>The function <code>wavespeed</code> should return the maximum wavespeed for a state and is called as <code>wavespeed(nM, QM, auxM, t, preflux(QM, auxM, t)...)</code> and <code>wavespeed(nM, QP, auxP, t, preflux(QP, auxP, t)...)</code> where <code>nM</code> is the outward unit normal for the minus side.</p><p>When present <code>computeQjump!(ΔQ, QM, auxM, QP, auxP)</code> will be called after so that the user specify the value to use for <code>QM - QP</code>; this is useful for correcting <code>Q</code> to include discontinuous reference states.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The undocumented arguments <code>PM</code> and <code>PP</code> for the function should not be used by external callers and are used only internally by the function <code>rusanov_boundary_flux!</code></p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/af4371e9a6658c1c9b529fbd73e4765271322ed3/src/DGmethods/NumericalFluxes.jl#L4-L31">source</a></section><footer><hr/><a class="previous" href="../Arrays/"><span class="direction">Previous</span><span class="title">Arrays</span></a><a class="next" href="../CodingConventions/"><span class="direction">Next</span><span class="title">Coding Conventions</span></a></footer></article></body></html>
