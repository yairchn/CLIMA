var documenterSearchIndex = {"docs":
[{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"EditURL = \"https://github.com/climate-machine/CLIMA/blob/master/examples/DGmethods_old/ex_001_periodic_advection.jl\"","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#Example-001:-Periodic-Advection-1","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"jupyter: Jupyter\nThis example is also available as a Jupyter notebook: ex_001_periodic_advection.ipynb","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Key ideas of this tutorial:","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Setting up PDE\nDefining a numerical flux\nDefining finite element mesh\nUsing the ODE solving framework\nUsing VTK visualization","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#Introduction-1","page":"Example 001: Periodic Advection","title":"Introduction","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"In this example we will solve the constant coefficient advection equation on a periodic domain; the domain is taken to be the unit square or cube depending on whether the problem is two- or three-dimensional.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"The partial differential equation we wish to solve is","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":" fracpartial qpartial t + nabla cdot (vecu q) = 0","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"where q is the advected scalar quantity and vecu is the constant velocity field. The quantity vecu q is more generally called the flux and denoted in the tutorial below as boldsymbolF(q) = vecu q.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Below is a program interspersed with comments. The full program, without comments, can be found in the next section.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#Commented-Program-1","page":"Example 001: Periodic Advection","title":"Commented Program","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#Preliminaries-1","page":"Example 001: Periodic Advection","title":"Preliminaries","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Load in modules needed for solving the problem","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"using MPI\nusing CLIMA.Mesh.Topologies\nusing CLIMA.Mesh.Grids\nusing CLIMA.DGBalanceLawDiscretizations\nusing CLIMA.MPIStateArrays\nusing CLIMA.LowStorageRungeKuttaMethod\nusing CLIMA.ODESolvers\nusing CLIMA.GenericCallbacks\nusing CLIMA.VTK\nusing LinearAlgebra\nusing Logging\nusing Dates\nusing Printf\nusing StaticArrays","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Start up MPI if this has not already been done","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"MPI.Initialized() || MPI.Init()\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"define the velocity field for advection","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"const uvec = (1, 2, 3)\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#Physical-Flux-1","page":"Example 001: Periodic Advection","title":"Physical Flux","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Now we define a function which given a value for q computes the physical flux boldsymbolF = vecu q. Since we only have a single state, q, the state will come in as an MVector of length 1 and the flux to fill as an MMatrix of size (3, 1).","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Note: for two-dimensional simulations the flux MMatrix will also be of size (3, 1) but the function need only fill the first two rows","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"function advectionflux!(F, state, _...)\n  FT = eltype(state) # get the floating point type we are using\n  @inbounds begin\n    q = state[1]\n    F[:, 1] = SVector{3, FT}(uvec) * q\n  end\nend\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#Numerical-Flux-1","page":"Example 001: Periodic Advection","title":"Numerical Flux","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"In the discontinuous Galerkin method the continuity of the solution across element interfaces is imposed weakly through the use of a numerical flux. The numerical flux is a function that given the solution state on either side of an interface returns a unique value approximating boldsymbolFcdot vecn on the interface:","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"f^* = f^*(q^- q^+ vecn)","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"We call the two sides of the interface the \"minus side\" and \"plus side\" hence the pm superscripts in q in the notation above; the choice of which element is on the minus side and plus side is arbitrary. Here vecn is a unit normal to the interface and is typically taken to point from the minus side to the plus side. The numerical flux is required to be symmetric with respect to q^- and q^+:","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"f^*(q^- q^+ vecn) = f^*(q^+ q^- vecn)","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"and consistent with the physical flux in the sense that","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"boldsymbolF(q) cdot vecn = f^*(q q vecn)","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Taken together these two conditions also imply that","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"f^*(q^- q^+ vecn^-) = -f^*(q^+ q^- vecn^+)","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"that is f^* is skew-symmetry with respect to the unit normals vecn^+ = -vecn^-.  The choice of numerical flux has important implications for the stability of the method. Though it is beyond the scope of these tutorials to dive into this in detail, often the \"best\" numerical fluxes are the ones that are constructed specifically for given set of equations by solving the Riemann problem; the Riemann problem is an initial value problem where the initial data are piecewise constant with a single discontinuity.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"In the CLIMA balance law solver the numerical flux function is a user-defined function that fills in an MVector for the numerical flux given two states, the \"viscous state\", a unit normal to the face, the simulation time, and a user-defined auxiliary state; the viscous and auxiliary states will be discussed in a subsequent examples. In the function below F is the numerical flux to fill, nM is the unit normal pointing away from the minus side and toward the plus side, QM and QP are MVectors of the solution state on the minus and plus sides of the interface, viscM and viscP are the viscous states on the minus and plus sides, auxM and auxP are the user-defined auxiliary state values on the minus and plus sides, and t is the simulation time.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"For linear advection the solution to the Riemann problem is trivial, since if vecn^- cdot vecu  0 the state q is being advected from the minus side to the plus side otherwise the reverse occurs. Thus the upwind numerical flux for advection is","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"f^*(q^- q^+ vecn^-) =\nbegincases\n  vecn^-cdotvecu  q^- text if  vecn cdot vecu  0\n  vecn^-cdotvecu  q^+ text otherwise\nendcases","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"This is done in the following function","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"function upwindflux!(fs, nM, stateM, viscM, auxM, stateP, viscP, auxP, t)\n  FT = eltype(fs)\n  @inbounds begin\n    # determine the advection speed and direction\n    un = dot(nM, FT.(uvec))\n    qM = stateM[1]\n    qP = stateP[1]\n    # Determine which state is \"upwind\" of the minus side\n    fs[1] = un ≥ 0 ? un * qM : un * qP\n  end\nend\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"In later examples we will demonstrate how to use the Rusanov flux which is included in the CLIMA.DGBalanceLawDiscretizations.NumericalFluxes submodule. This is a more general-purpose flux which approximates the solution Riemann problem by using an average of the flux on either side of the interface with additional dissipation added based on the local wave speed.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#Initial-Condition-1","page":"Example 001: Periodic Advection","title":"Initial Condition","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"In this example we take the initial condition to be","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"q(vecx t=0) = prod_i=1^d exp(sin(2pi x_i))","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"where d is the dimensionality of the problem. To use this initial condition we need a function that given vecx sets q.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"The initial condition is set by the solver through a function which takes q as an MVector to initialize based on the pointwise coordinate location (x_1, x_2, x_3).","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Note: The initial condition will always be called as though the dimensionality of the problem is 3. For the domain used below x_3 = 0 when the problem is actually two-dimensional; since when x_3 = 0 the function exp(sin(2pi x_3)) = 1 we can safely assume the dimensionality is always 3 in our implication of the initial condition.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Note: The last argument needs to be caught but not used for this example","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"function initialcondition!(Q, x_1, x_2, x_3, _...)\n  @inbounds Q[1] = exp(sin(2π * x_1)) * exp(sin(2π * x_2)) * exp(sin(2π * x_3))\nend\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#Exact-Solution-1","page":"Example 001: Periodic Advection","title":"Exact Solution","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"For periodic constant-velocity advection the exact solution is trivial to compute. Assuming that phi(x) is the periodically replicated initial condition, the analytic solution is","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"q(vecx t) = phi(vecx - vecu t)","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"This will be useful later since it will allow us to check our work by computing the error in our solution and estimating the convergence rate.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"For a general initial condition on the unit domain the following function can be used:","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"function exactsolution!(dim, Q, t, x_1, x_2, x_3, _...)\n  @inbounds begin\n    FT = eltype(Q)\n\n    # trace back the point (x_1, x_2, x_3) in the velocity field and\n    # determine where in our \"original\" [0, L_1] X [0, L_2] X [0, L_3] domain\n    # this point is located\n    y_1 = mod(x_1 - FT(uvec[1]) * t, 1)\n    y_2 = mod(x_2 - FT(uvec[2]) * t, 1)\n\n    # if we are really just 2-D we do not want to change the x_3 coordinate\n    y_3 = dim == 3 ? mod(x_3 - FT(uvec[3]) * t, 1) : x_3\n\n    initialcondition!(Q, y_1, y_2, y_3)\n  end\nend\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"The input argument dim is the \"real\" dimensionality of the problem and is needed in case uvec[3] != 0.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#Initialize-the-DG-Method-1","page":"Example 001: Periodic Advection","title":"Initialize the DG Method","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"We are now at the point that we can initialize the structure for the DG method.  For convenience we define a function that initializes the DG method over a given MPI communicator mpicomm, for a given polynomialorder, using dim dimensions. The mesh used will be Ne x Ne elements when dim == 2 and Ne x Ne x Ne elements when dim == 3. The floating point type of the computation is FT and whether the CPU or GPU is used is determined by ArrayType; ArrayType === Array is for the CPU and ArrayType === CuArray is for NVIDIA GPUs.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Note: This whole code chunk is in a function block","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"function setupDG(mpicomm, dim, Ne, polynomialorder, FT=Float64,\n                 ArrayType=Array)\n\n  @assert ArrayType === Array","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"We will use the BrickTopology from CLIMA.Mesh.Topologies to define the mesh. The \"topology\" in CLIMA is the element connectivity information (e.g., neighbouring elements and interface data) along with coordinate locations for corners of the elements. The BrickTopology creates a regular mesh of a rectangular or regular hexahedral domain. This is done by specifying the coordinate points of the element corners along each dimension. Here, we want to mesh the unit square or cube with Ne elements in each dimension, thus we specify the following Tuple of ranges:","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"  brickrange = (range(FT(0); length=Ne+1, stop=1), # x_1 corner locations\n                range(FT(0); length=Ne+1, stop=1), # x_2 corner locations\n                range(FT(0); length=Ne+1, stop=1)) # x_3 corner locations","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"these coordinates will be combined in a tensor product fashion to define the element corners.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"By default the BrickTopology is not periodic, so we need to define a Tuple of boolean defining which dimensions are periodic.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"  periodicity = (true, true, true)","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Note: We have defined both the brickrange and periodicity as though we are working in three-dimensions, and in when in two-dimensions we will discard the third element of the Tuple; this could also be done from the start by using the ntuple function.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Using brickrange and periodicity we can now initialize the topology using the BrickTopology constructor. This will both create the topology as well as do the partitioning of the elements across the MPI ranks available in the mpi communicator mpicomm","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"  topology = BrickTopology(mpicomm, brickrange[1:dim];\n                           periodicity=periodicity[1:dim])","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"The topology only has element connectivity and corner information, thus we still need to create a grid (or mesh) of degrees of freedom. In CLIMA the so-called discontinuous spectral element grid is used (aka tensor-product quadrilateral and hexahedral elements with Legendre-Gauss-Lobatto interpolation and quadrature weights). Given a topology and polynomial order we can create the grid of degrees of free using","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"  grid = DiscontinuousSpectralElementGrid(topology; polynomialorder =\n                                          polynomialorder, FloatType = FT,\n                                          DeviceArray = ArrayType,)","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Note: This constructor also takes in a FloatType which specifies the floating point type to be used (e.g., for the coordinate points and geometry metric terms). The argument ArrayType is used to determine the compute device to use (i.e., Array will signify the CPU is being used and CuArray will signal that an NVIDIA GPU is being used).","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"We can now define the discretization from the grid using the physical flux advectionflux! and numerical flux upwindflux! defined above; we only have a single state variable q hence length_state_vector = 1","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"  spatialdiscretization = DGBalanceLaw(grid = grid, length_state_vector = 1,\n                                       flux! = advectionflux!,\n                                       numerical_flux! = upwindflux!)","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"(end of function)","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"end\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#Initializing-and-run-the-DG-method-1","page":"Example 001: Periodic Advection","title":"Initializing and run the DG method","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Note: This whole code chunk is in a let block","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"let","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"We will just use the whole MPI communicator","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"  mpicomm = MPI.COMM_WORLD","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Since this is an MPI enabled code, we use the Julia logging functionality to ensure that only one MPI rank prints to the screen. Namely, MPI rank 0 does all the logging and all other ranks dump their ouput to devnull.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"  mpi_logger = ConsoleLogger(MPI.Comm_rank(mpicomm) == 0 ? stderr : devnull)","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Note: The NullLogger should not be used because if any MPI functions are called in a logging block deadlock will occur since NullLogger code is not executed.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Dimensionality to run","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"  dim = 2","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Mesh size along each dimension","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"  Ne = 20","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"order of polynomials to use","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"  polynomialorder = 4","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Setup the DG discretization","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"  spatialdiscretization = setupDG(mpicomm, dim, Ne, polynomialorder)","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Given the spatialdiscretization and the initialcondition! function we can create and initialize storage for the solution. This is an MPI-aware array","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"  Q = MPIStateArray(spatialdiscretization, initialcondition!)","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"A VTK file, which can be viewed in ParaView or VisIt, can be generated with the following command (the last Tuple gives strings for the names of the state fields)","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"  filename = @sprintf(\"initialcondition_mpirank%04d\", MPI.Comm_rank(mpicomm))\n  writevtk(filename, Q, spatialdiscretization,\n                                       (\"q\",))","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Note: Currently the writevtk function writes one file for each MPI rank, and the user is responsible for opening each of the files to \"stitch\" together the image.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"In order to run the simulation we need to use an ODE solver. In this example we will use a low storage Runge-Kutta method which can be initialized with a spatial discretization, solution vector (not stored but used to define needed auxiliary arrays), initial solution time, and a time step size; this particular Runge-Kutta method uses a fixed time step.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Since we are using a regular mesh, with a constant wave speed, a \"CFL\" restriction for the mesh is","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"  h = 1 / Ne                           # element size\n  CFL = h / maximum(abs.(uvec[1:dim])) # time to cross the element once\n  dt = CFL / polynomialorder^2         # DG time step scaling (for this\n                                       # particular RK scheme could go with a\n                                       # factor of ~2 larger time step)\n  lsrk = LSRK54CarpenterKennedy(spatialdiscretization, Q; dt = dt, t0 = 0)","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Here we run the ODE solver until the final time timeend using Q as the initial condition Q. The solution will be updated in place so that the final solution will also be stored in Q.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"  finaltime = 1.0\n  solve!(Q, lsrk; timeend = finaltime)","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"The final solution can be visualized in a similar manner to the initial condition","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"  filename = @sprintf(\"finalsolution_mpirank%04d\", MPI.Comm_rank(mpicomm))\n  writevtk(filename, Q, spatialdiscretization,\n                                       (\"q\",))","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Using the finaltime and exactsolution! we can calculate the exact solution","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"  Qe = MPIStateArray(spatialdiscretization) do Qin, x, y, z, aux\n    exactsolution!(dim, Qin, finaltime, x, y, z)\n  end","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"and then compute the error by evaluating the Euclidean distance between the computed solution Q and the exact solution Qe","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"  error = euclidean_distance(Q, Qe)\n  with_logger(mpi_logger) do\n    @info @sprintf(\"\"\"Run with\n                   dim              = %d\n                   Ne               = %d\n                   polynomial order = %d\n                   error            = %e\n                   \"\"\", dim, Ne, polynomialorder, error)\n  end\nend\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#Using-ODE-solver-callback-functions-1","page":"Example 001: Periodic Advection","title":"Using ODE solver callback functions","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"The above simulation run with solve! runs from the initial time to the final time. The ODE solver framework in CLIMA gives functionality that allows the user to inject code into the solver during execution. Here we show how to use some of the generic callback functions provided to","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Save diagnostic information\ndisplay runtime simulation information\nsave VTK files during the simulation","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Note: This whole code chunk is in a let block","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"let","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"code is the same as above until the solve! call","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"  mpicomm = MPI.COMM_WORLD\n  mpi_logger = ConsoleLogger(MPI.Comm_rank(mpicomm) == 0 ? stderr : devnull)\n  dim = 2\n  Ne = 20\n  polynomialorder = 4\n  spatialdiscretization = setupDG(mpicomm, dim, Ne, polynomialorder)\n  Q = MPIStateArray(spatialdiscretization, initialcondition!)\n  filename = @sprintf(\"initialcondition_mpirank%04d\", MPI.Comm_rank(mpicomm))\n  writevtk(filename, Q, spatialdiscretization,\n                                       (\"q\",))\n  h = 1 / Ne\n  CFL = h / maximum(abs.(uvec[1:dim]))\n  dt = CFL / polynomialorder^2\n  lsrk = LSRK54CarpenterKennedy(spatialdiscretization, Q; dt = dt, t0 = 0)\n  finaltime = 1.0","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"The ODE solver callback functions are called both before the ODE solver begins and then after each time step.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"For instance if a user wanted to store the norm of the solution every time step the following callback could be used","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"  store_norm_index = 0\n  normQ = Array{Float64}(undef, ceil(Int, finaltime / dt))\n  function cb_store_norm()\n    store_norm_index += 1\n    normQ[store_norm_index] = norm(Q)\n    nothing\n  end","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Note: that callbacks must return either nothing or 0 if the ODE solver should continue, 1 is the ODE solver should stop after all the callbacks have executed, or 2 is the time stepping should immediately stop with no further callbacks executed.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Several generic callbacks are provided in the CLIMA.GenericCallbacks submodule. For instance, the EveryXSimulationSteps callbacks will execute every X time steps. This could be used to say write VTK output every 20 time steps","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"  vtk_step = 0\n  mkpath(\"vtk\")\n  cb_vtk = GenericCallbacks.EveryXSimulationSteps(20) do\n    vtk_step += 1\n    filename = @sprintf(\"vtk/advection_mpirank%04d_step%04d\",\n                         MPI.Comm_rank(mpicomm), vtk_step)\n    writevtk(filename, Q, spatialdiscretization,\n                                         (\"q\",))\n    nothing\n  end","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Another provided generic callback is EveryXWallTimeSeconds which will be called every X seconds of wall clock time (as opposed to simulation time). This could be used to dump diagnostic information about the simulation. In this case we display the norm of the simulation time, the run time, and the norm of the solution.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"One unique feature of this call back is that it takes in a single optional argument init which allows the ODE solver to call the callback for initialization; all callbacks get called for initialization with a single boolean argument set to true, but this occurs in a try/catch statement in case the callback does not require initialization (such as the two above).","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"  starttime = Ref(now())\n  cb_info = GenericCallbacks.EveryXWallTimeSeconds(1, mpicomm) do (init=false)\n    if init\n      starttime[] = now()\n    else\n      with_logger(mpi_logger) do\n        @info @sprintf(\"\"\"Update\n                       simtime = %.16e\n                       runtime = %s\n                       norm(Q) = %.16e\"\"\", ODESolvers.gettime(lsrk),\n                       Dates.format(convert(Dates.DateTime,\n                                            Dates.now()-starttime[]),\n                                    Dates.dateformat\"HH:MM:SS\"),\n                       norm(Q))\n      end\n    end\n  end","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Note that this callback also takes in the MPI communicator. This is necessary because the callback needs to execute an MPI.Allreduce to ensure that all the MPI ranks are using the same global run time.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"the defined callbacks are based to the ODE solve! function through the keyword argument callbacks as a tuple:","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"  solve!(Q, lsrk; timeend = finaltime,\n         callbacks = (cb_store_norm, cb_vtk, cb_info))","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"The remainder of the function is the same as above","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"  filename = @sprintf(\"finalsolution_mpirank%04d\", MPI.Comm_rank(mpicomm))\n  writevtk(filename, Q, spatialdiscretization,\n                                       (\"q\",))\n\n  Qe = MPIStateArray(spatialdiscretization) do Qin, x, y, z, aux\n    exactsolution!(dim, Qin, finaltime, x, y, z)\n  end\n  error = euclidean_distance(Q, Qe)\n  with_logger(mpi_logger) do\n    @info @sprintf(\"\"\"Run with\n                   dim              = %d\n                   Ne               = %d\n                   polynomial order = %d\n                   error            = %e\n                   \"\"\", dim, Ne, polynomialorder, error)\n  end\nend\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#Computing-rates-and-errors-1","page":"Example 001: Periodic Advection","title":"Computing rates and errors","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"If the above code is put in a loop over increasing Ne then a rate of convergence for the scheme can be established which we expect to be on the order of the polynomial order plus sim 12.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"let\n  mpicomm = MPI.COMM_WORLD\n  mpi_logger = ConsoleLogger(MPI.Comm_rank(mpicomm) == 0 ? stderr : devnull)\n\n  dim = 2\n  polynomialorder = 4\n  finaltime = 1.0\n\n  with_logger(mpi_logger) do\n    @info @sprintf(\"\"\"Running with\n                   dim              = %d\n                   polynomial order = %d\n                   \"\"\", dim, polynomialorder)\n  end\n\n  base_Ne = 5\n  lvl_error = zeros(4) # number of levels to compute is length(lvl_error)\n  for lvl = 1:length(lvl_error)\n    # `Ne` for this mesh level\n    Ne = base_Ne * 2^(lvl-1)\n    spatialdiscretization = setupDG(mpicomm, dim, Ne, polynomialorder)\n\n    Q = MPIStateArray(spatialdiscretization, initialcondition!)\n    h = 1 / Ne\n    CFL = h / maximum(abs.(uvec[1:dim]))\n    dt = CFL / polynomialorder^2\n    lsrk = LSRK54CarpenterKennedy(spatialdiscretization, Q; dt = dt, t0 = 0)\n\n    solve!(Q, lsrk; timeend = finaltime)\n\n    Qe = MPIStateArray(spatialdiscretization) do Qin, x, y, z, aux\n      exactsolution!(dim, Qin, finaltime, x, y, z)\n    end\n\n    lvl_error[lvl] = euclidean_distance(Q, Qe)\n    msg =  @sprintf   \"Level      = %d\" lvl\n    msg *= @sprintf \"\\nNe               = %d\" Ne\n    msg *= @sprintf \"\\nerror            = %.4e\" lvl_error[lvl]\n    if lvl > 1\n      rate = log2(lvl_error[lvl-1]) - log2(lvl_error[lvl])\n      msg *= @sprintf \"\\nconvergence rate = %.4e\" rate\n    end\n    with_logger(mpi_logger) do\n      @info msg\n    end\n  end\nend\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#ex_001_periodic_advection-plain-program-1","page":"Example 001: Periodic Advection","title":"Plain Program","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"Below follows a version of the program without any comments. The file is also available here: ex_001_periodic_advection.jl","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"using MPI\nusing CLIMA.Mesh.Topologies\nusing CLIMA.Mesh.Grids\nusing CLIMA.DGBalanceLawDiscretizations\nusing CLIMA.MPIStateArrays\nusing CLIMA.LowStorageRungeKuttaMethod\nusing CLIMA.ODESolvers\nusing CLIMA.GenericCallbacks\nusing CLIMA.VTK\nusing LinearAlgebra\nusing Logging\nusing Dates\nusing Printf\nusing StaticArrays\n\nMPI.Initialized() || MPI.Init()\n\nconst uvec = (1, 2, 3)\n\nfunction advectionflux!(F, state, _...)\n  FT = eltype(state) # get the floating point type we are using\n  @inbounds begin\n    q = state[1]\n    F[:, 1] = SVector{3, FT}(uvec) * q\n  end\nend\n\nfunction upwindflux!(fs, nM, stateM, viscM, auxM, stateP, viscP, auxP, t)\n  FT = eltype(fs)\n  @inbounds begin\n    # determine the advection speed and direction\n    un = dot(nM, FT.(uvec))\n    qM = stateM[1]\n    qP = stateP[1]\n    # Determine which state is \"upwind\" of the minus side\n    fs[1] = un ≥ 0 ? un * qM : un * qP\n  end\nend\n\nfunction initialcondition!(Q, x_1, x_2, x_3, _...)\n  @inbounds Q[1] = exp(sin(2π * x_1)) * exp(sin(2π * x_2)) * exp(sin(2π * x_3))\nend\n\nfunction exactsolution!(dim, Q, t, x_1, x_2, x_3, _...)\n  @inbounds begin\n    FT = eltype(Q)\n\n    # trace back the point (x_1, x_2, x_3) in the velocity field and\n    # determine where in our \"original\" [0, L_1] X [0, L_2] X [0, L_3] domain\n    # this point is located\n    y_1 = mod(x_1 - FT(uvec[1]) * t, 1)\n    y_2 = mod(x_2 - FT(uvec[2]) * t, 1)\n\n    # if we are really just 2-D we do not want to change the x_3 coordinate\n    y_3 = dim == 3 ? mod(x_3 - FT(uvec[3]) * t, 1) : x_3\n\n    initialcondition!(Q, y_1, y_2, y_3)\n  end\nend\n\nfunction setupDG(mpicomm, dim, Ne, polynomialorder, FT=Float64,\n                 ArrayType=Array)\n\n  @assert ArrayType === Array\n\n  brickrange = (range(FT(0); length=Ne+1, stop=1), # x_1 corner locations\n                range(FT(0); length=Ne+1, stop=1), # x_2 corner locations\n                range(FT(0); length=Ne+1, stop=1)) # x_3 corner locations\n\n  periodicity = (true, true, true)\n\n  topology = BrickTopology(mpicomm, brickrange[1:dim];\n                           periodicity=periodicity[1:dim])\n\n  grid = DiscontinuousSpectralElementGrid(topology; polynomialorder =\n                                          polynomialorder, FloatType = FT,\n                                          DeviceArray = ArrayType,)\n\n  spatialdiscretization = DGBalanceLaw(grid = grid, length_state_vector = 1,\n                                       flux! = advectionflux!,\n                                       numerical_flux! = upwindflux!)\n\nend\n\nlet\n\n  mpicomm = MPI.COMM_WORLD\n\n  mpi_logger = ConsoleLogger(MPI.Comm_rank(mpicomm) == 0 ? stderr : devnull)\n\n  dim = 2\n\n  Ne = 20\n\n  polynomialorder = 4\n\n  spatialdiscretization = setupDG(mpicomm, dim, Ne, polynomialorder)\n\n  Q = MPIStateArray(spatialdiscretization, initialcondition!)\n\n  filename = @sprintf(\"initialcondition_mpirank%04d\", MPI.Comm_rank(mpicomm))\n  writevtk(filename, Q, spatialdiscretization,\n                                       (\"q\",))\n\n  h = 1 / Ne                           # element size\n  CFL = h / maximum(abs.(uvec[1:dim])) # time to cross the element once\n  dt = CFL / polynomialorder^2         # DG time step scaling (for this\n                                       # particular RK scheme could go with a\n                                       # factor of ~2 larger time step)\n  lsrk = LSRK54CarpenterKennedy(spatialdiscretization, Q; dt = dt, t0 = 0)\n\n  finaltime = 1.0\n  solve!(Q, lsrk; timeend = finaltime)\n\n  filename = @sprintf(\"finalsolution_mpirank%04d\", MPI.Comm_rank(mpicomm))\n  writevtk(filename, Q, spatialdiscretization,\n                                       (\"q\",))\n\n  Qe = MPIStateArray(spatialdiscretization) do Qin, x, y, z, aux\n    exactsolution!(dim, Qin, finaltime, x, y, z)\n  end\n\n  error = euclidean_distance(Q, Qe)\n  with_logger(mpi_logger) do\n    @info @sprintf(\"\"\"Run with\n                   dim              = %d\n                   Ne               = %d\n                   polynomial order = %d\n                   error            = %e\n                   \"\"\", dim, Ne, polynomialorder, error)\n  end\nend\n\nlet\n\n  mpicomm = MPI.COMM_WORLD\n  mpi_logger = ConsoleLogger(MPI.Comm_rank(mpicomm) == 0 ? stderr : devnull)\n  dim = 2\n  Ne = 20\n  polynomialorder = 4\n  spatialdiscretization = setupDG(mpicomm, dim, Ne, polynomialorder)\n  Q = MPIStateArray(spatialdiscretization, initialcondition!)\n  filename = @sprintf(\"initialcondition_mpirank%04d\", MPI.Comm_rank(mpicomm))\n  writevtk(filename, Q, spatialdiscretization,\n                                       (\"q\",))\n  h = 1 / Ne\n  CFL = h / maximum(abs.(uvec[1:dim]))\n  dt = CFL / polynomialorder^2\n  lsrk = LSRK54CarpenterKennedy(spatialdiscretization, Q; dt = dt, t0 = 0)\n  finaltime = 1.0\n\n  store_norm_index = 0\n  normQ = Array{Float64}(undef, ceil(Int, finaltime / dt))\n  function cb_store_norm()\n    store_norm_index += 1\n    normQ[store_norm_index] = norm(Q)\n    nothing\n  end\n\n  vtk_step = 0\n  mkpath(\"vtk\")\n  cb_vtk = GenericCallbacks.EveryXSimulationSteps(20) do\n    vtk_step += 1\n    filename = @sprintf(\"vtk/advection_mpirank%04d_step%04d\",\n                         MPI.Comm_rank(mpicomm), vtk_step)\n    writevtk(filename, Q, spatialdiscretization,\n                                         (\"q\",))\n    nothing\n  end\n\n  starttime = Ref(now())\n  cb_info = GenericCallbacks.EveryXWallTimeSeconds(1, mpicomm) do (init=false)\n    if init\n      starttime[] = now()\n    else\n      with_logger(mpi_logger) do\n        @info @sprintf(\"\"\"Update\n                       simtime = %.16e\n                       runtime = %s\n                       norm(Q) = %.16e\"\"\", ODESolvers.gettime(lsrk),\n                       Dates.format(convert(Dates.DateTime,\n                                            Dates.now()-starttime[]),\n                                    Dates.dateformat\"HH:MM:SS\"),\n                       norm(Q))\n      end\n    end\n  end\n\n  solve!(Q, lsrk; timeend = finaltime,\n         callbacks = (cb_store_norm, cb_vtk, cb_info))\n\n  filename = @sprintf(\"finalsolution_mpirank%04d\", MPI.Comm_rank(mpicomm))\n  writevtk(filename, Q, spatialdiscretization,\n                                       (\"q\",))\n\n  Qe = MPIStateArray(spatialdiscretization) do Qin, x, y, z, aux\n    exactsolution!(dim, Qin, finaltime, x, y, z)\n  end\n  error = euclidean_distance(Q, Qe)\n  with_logger(mpi_logger) do\n    @info @sprintf(\"\"\"Run with\n                   dim              = %d\n                   Ne               = %d\n                   polynomial order = %d\n                   error            = %e\n                   \"\"\", dim, Ne, polynomialorder, error)\n  end\nend\n\nlet\n  mpicomm = MPI.COMM_WORLD\n  mpi_logger = ConsoleLogger(MPI.Comm_rank(mpicomm) == 0 ? stderr : devnull)\n\n  dim = 2\n  polynomialorder = 4\n  finaltime = 1.0\n\n  with_logger(mpi_logger) do\n    @info @sprintf(\"\"\"Running with\n                   dim              = %d\n                   polynomial order = %d\n                   \"\"\", dim, polynomialorder)\n  end\n\n  base_Ne = 5\n  lvl_error = zeros(4) # number of levels to compute is length(lvl_error)\n  for lvl = 1:length(lvl_error)\n    # `Ne` for this mesh level\n    Ne = base_Ne * 2^(lvl-1)\n    spatialdiscretization = setupDG(mpicomm, dim, Ne, polynomialorder)\n\n    Q = MPIStateArray(spatialdiscretization, initialcondition!)\n    h = 1 / Ne\n    CFL = h / maximum(abs.(uvec[1:dim]))\n    dt = CFL / polynomialorder^2\n    lsrk = LSRK54CarpenterKennedy(spatialdiscretization, Q; dt = dt, t0 = 0)\n\n    solve!(Q, lsrk; timeend = finaltime)\n\n    Qe = MPIStateArray(spatialdiscretization) do Qin, x, y, z, aux\n      exactsolution!(dim, Qin, finaltime, x, y, z)\n    end\n\n    lvl_error[lvl] = euclidean_distance(Q, Qe)\n    msg =  @sprintf   \"Level      = %d\" lvl\n    msg *= @sprintf \"\\nNe               = %d\" Ne\n    msg *= @sprintf \"\\nerror            = %.4e\" lvl_error[lvl]\n    if lvl > 1\n      rate = log2(lvl_error[lvl-1]) - log2(lvl_error[lvl])\n      msg *= @sprintf \"\\nconvergence rate = %.4e\" rate\n    end\n    with_logger(mpi_logger) do\n      @info msg\n    end\n  end\nend\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/DGmethods_old/generated/ex_001_periodic_advection.html#","page":"Example 001: Periodic Advection","title":"Example 001: Periodic Advection","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Atmos/TurbulenceConvection.html#TurbulenceConvection-1","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"","category":"section"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"CurrentModule = CLIMA.TurbulenceConvection","category":"page"},{"location":"Atmos/TurbulenceConvection.html#Grids-1","page":"TurbulenceConvection","title":"Grids","text":"","category":"section"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"Grids.Grid\nGrids.over_elems\nGrids.over_elems_real\nGrids.over_elems_ghost\nGrids.first_elem_above_surface\nGrids.get_z","category":"page"},{"location":"Atmos/TurbulenceConvection.html#Grid-Operators-1","page":"TurbulenceConvection","title":"Grid Operators","text":"","category":"section"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"GridOperators.∇_z\nGridOperators.Δ_z\nGridOperators.adv_upwind","category":"page"},{"location":"Atmos/TurbulenceConvection.html#State-Vector-1","page":"TurbulenceConvection","title":"State Vector","text":"","category":"section"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"StateVecs.StateVec\nStateVecs.over_sub_domains\nStateVecs.Cut","category":"page"},{"location":"Atmos/TurbulenceConvection.html#CLIMA.TurbulenceConvection.StateVecs.StateVec","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.StateVecs.StateVec","text":"StateVec{VM}\n\nA state vector containing the number of subdomains, n_subdomains, a NamedTuple variable mapper, a tuple of the variable names, and a vector of vectors, containing the values for all of the variables.\n\n\n\n\n\n","category":"type"},{"location":"Atmos/TurbulenceConvection.html#CLIMA.TurbulenceConvection.StateVecs.over_sub_domains","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.StateVecs.over_sub_domains","text":"over_sub_domains(sv::StateVec, ϕ::Symbol)\n\nGet list of indexes over all subdomains for variable ϕ.\n\n\n\n\n\n","category":"function"},{"location":"Atmos/TurbulenceConvection.html#CLIMA.TurbulenceConvection.StateVecs.Cut","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.StateVecs.Cut","text":"Cut{I} <: AbstractCut{I}\n\nA Cut struct used to slice the state vector along the grid-element dimension. This is used as an API to pass Cuts into local derivative/interpolation routines.\n\n\n\n\n\n","category":"type"},{"location":"Atmos/TurbulenceConvection.html#Boundary-Conditions-1","page":"TurbulenceConvection","title":"Boundary Conditions","text":"","category":"section"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"BoundaryConditions.Dirichlet!\nBoundaryConditions.Neumann!\nBoundaryConditions.Top\nBoundaryConditions.Bottom","category":"page"},{"location":"Atmos/TurbulenceConvection.html#State-Vector-Functions-1","page":"TurbulenceConvection","title":"State Vector Functions","text":"","category":"section"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"StateVecFuncs.first_elem_above_surface_val\nStateVecFuncs.surface_val\nStateVecFuncs.extrap!\nStateVecFuncs.assign_ghost!\nStateVecFuncs.domain_average!\nStateVecFuncs.distribute!\nStateVecFuncs.total_covariance!\nStateVecFuncs.export_state","category":"page"},{"location":"Atmos/TurbulenceConvection.html#Solving-a-diffusion-equation-1","page":"TurbulenceConvection","title":"Solving a diffusion equation","text":"","category":"section"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"Here, we solve a simple diffusion equation","category":"page"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"_t T = K ΔT + 1 qquad T = 0  Ω","category":"page"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"using Explicit Euler with StateVec and Grid constructs.","category":"page"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"\nusing CLIMA.TurbulenceConvection.Grids\nusing CLIMA.TurbulenceConvection.GridOperators\nusing CLIMA.TurbulenceConvection.BoundaryConditions\nusing CLIMA.TurbulenceConvection.StateVecs\nusing CLIMA.TurbulenceConvection.StateVecFuncs\nusing Plots\n\nn_sd = 1 # number of sub-domains\nK = 1.0 # diffusion coefficient\nmaxiter = 1000 # time-step iterations\nΔt = 0.001 # time step\n\ngrid = Grid(0.0, 1.0, 10)\nq = StateVec(((:T, n_sd),), grid)\nrhs = deepcopy(q)\n\nfor i in 1:maxiter\n  for k in over_elems_real(grid)\n    rhs[:T, k] = K*Δ_z(q[:T, Cut(k)], grid) + 1\n  end\n  for k in over_elems(grid)\n    q[:T, k] += Δt*rhs[:T, k]\n  end\n  Dirichlet!(q, :T, 0.0, grid, Top())\n  Dirichlet!(q, :T, 0.0, grid, Bottom())\nend\nplot_state(q, grid, \"./\", \"T.svg\", :T) # for visualizing\nnothing # hide","category":"page"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"(Image: )","category":"page"},{"location":"Atmos/TurbulenceConvection.html#Solving-a-diffusion-equation-Neumann-BCs-Top-1","page":"TurbulenceConvection","title":"Solving a diffusion equation Neumann BCs Top","text":"","category":"section"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"Here, we solve a simple diffusion equation","category":"page"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"_t T = K ΔT qquad _z T = 1  z_min T = 0  z_max","category":"page"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"using Explicit Euler with StateVec and Grid constructs.","category":"page"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"\nusing CLIMA.TurbulenceConvection.Grids\nusing CLIMA.TurbulenceConvection.GridOperators\nusing CLIMA.TurbulenceConvection.BoundaryConditions\nusing CLIMA.TurbulenceConvection.StateVecs\nusing CLIMA.TurbulenceConvection.StateVecFuncs\nusing Plots\n\nn_sd = 1 # number of sub-domains\nK = 1.0 # diffusion coefficient\nmaxiter = 200 # time-step iterations\nΔt = 0.001 # time step\n\ngrid = Grid(0.0, 1.0, 10)\nq = StateVec(((:T, n_sd),), grid)\nrhs = deepcopy(q)\n\nfor i in 1:maxiter\n  for k in over_elems_real(grid)\n    rhs[:T, k] = K*Δ_z(q[:T, Cut(k)], grid)\n  end\n  for k in over_elems(grid)\n    q[:T, k] += Δt*rhs[:T, k]\n  end\n  q_flux = 1 # Leaving domain\n  q_bc = -q_flux/K\n  Neumann!(q, :T, q_bc, grid, Top())\n  Dirichlet!(q, :T, 0.0, grid, Bottom())\nend\nplot_state(q, grid, \"./\", \"T_NeumannTop.svg\", :T) # for visualizing\nnothing # hide","category":"page"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"(Image: )","category":"page"},{"location":"Atmos/TurbulenceConvection.html#Solving-a-diffusion-equation-Neumann-BCs-Bottom-1","page":"TurbulenceConvection","title":"Solving a diffusion equation Neumann BCs Bottom","text":"","category":"section"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"Here, we solve a simple diffusion equation","category":"page"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"_t T = K ΔT qquad _z T = 1  z_min T = 0  z_max","category":"page"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"using Explicit Euler with StateVec and Grid constructs.","category":"page"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"\nusing CLIMA.TurbulenceConvection.Grids\nusing CLIMA.TurbulenceConvection.GridOperators\nusing CLIMA.TurbulenceConvection.BoundaryConditions\nusing CLIMA.TurbulenceConvection.StateVecs\nusing CLIMA.TurbulenceConvection.StateVecFuncs\nusing Plots\n\nn_sd = 1 # number of sub-domains\nK = 1.0 # diffusion coefficient\nmaxiter = 200 # time-step iterations\nΔt = 0.001 # time step\n\ngrid = Grid(0.0, 1.0, 10)\nq = StateVec(((:T, n_sd),), grid)\nrhs = deepcopy(q)\n\nfor i in 1:maxiter\n  for k in over_elems_real(grid)\n    rhs[:T, k] = K*Δ_z(q[:T, Cut(k)], grid)\n  end\n  for k in over_elems(grid)\n    q[:T, k] += Δt*rhs[:T, k]\n  end\n  Dirichlet!(q, :T, 0.0, grid, Top())\n\n  q_flux = 1 # Entering domain\n  q_bc = -q_flux/K\n  Dirichlet!(q, :T, q_bc, grid, Bottom())\nend\nplot_state(q, grid, \"./\", \"T_NeumannBot.svg\", :T) # for visualizing\nnothing # hide","category":"page"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"(Image: )","category":"page"},{"location":"Atmos/TurbulenceConvection.html#Solving-a-variable-coefficient-diffusion-equation-1","page":"TurbulenceConvection","title":"Solving a variable coefficient diffusion equation","text":"","category":"section"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"Here, we solve a variable coefficient diffusion equation","category":"page"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"_t T =   (K(z)T) + 1 qquad T = 0  Ω","category":"page"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"K(z) = 1 - 9 times H(z-5) qquad H = textheaviside","category":"page"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"using Explicit Euler.","category":"page"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"\nusing CLIMA.TurbulenceConvection.Grids\nusing CLIMA.TurbulenceConvection.GridOperators\nusing CLIMA.TurbulenceConvection.BoundaryConditions\nusing CLIMA.TurbulenceConvection.StateVecs\nusing CLIMA.TurbulenceConvection.StateVecFuncs\nusing Plots\n\nn_sd = 1 # number of sub-domains\nmaxiter = 10000 # time-step iterations\nΔt = 0.001 # time step\n\ngrid = Grid(0.0, 1.0, 10)\nunknowns = ( (:T, n_sd), )\nvars = ( (:ΔT, n_sd), (:K_thermal, n_sd) )\nq = StateVec(unknowns, grid)\ntmp = StateVec(vars, grid)\nrhs = deepcopy(q)\n\ncond_thermal(z) = z > .5 ? 1 : .1\nfor i in 1:maxiter\n  for k in over_elems_real(grid)\n    tmp[:K_thermal, k] = cond_thermal(get_z(grid, k))\n    tmp[:ΔT, k] = Δ_z(q[:T, Cut(k)], grid, tmp[:K_thermal, Cut(k)])\n    rhs[:T, k] = tmp[:ΔT, k] + 1\n  end\n  for k in over_elems(grid)\n    q[:T, k] += Δt*rhs[:T, k]\n  end\n  Dirichlet!(q, :T, 0.0, grid, Top())\n  Dirichlet!(q, :T, 0.0, grid, Bottom())\nend\nplot_state(q, grid, \"./\", \"T_varK.svg\", :T) # for visualizing\nnothing # hide","category":"page"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"(Image: )","category":"page"},{"location":"Atmos/TurbulenceConvection.html#Solving-a-linear-advection-equation-1","page":"TurbulenceConvection","title":"Solving a linear advection equation","text":"","category":"section"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"Here, we solve a linear advection equation","category":"page"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"_t u + cu = 0 qquad u = 0  Ω","category":"page"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"u(t=0) = Gaussian(σ μ)","category":"page"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"using Explicit Euler method.","category":"page"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"\nusing CLIMA.TurbulenceConvection.Grids\nusing CLIMA.TurbulenceConvection.GridOperators\nusing CLIMA.TurbulenceConvection.BoundaryConditions\nusing CLIMA.TurbulenceConvection.StateVecs\nusing CLIMA.TurbulenceConvection.StateVecFuncs\nusing Plots\n\nn_sd = 1 # number of sub-domains\nmaxiter = 400 # time-step iterations\nΔt = 0.0005 # time step\n\ngrid = Grid(0.0, 1.0, 200)\nunknowns = ( (:u, n_sd), )\nvars = ( (:u_initial, n_sd), )\nq = StateVec(unknowns, grid)\ntmp = StateVec(vars, grid)\nrhs = deepcopy(q)\n\nσ, μ, c = .05, 0.3, 1.0\nT = maxiter*Δt\nic(z) = 1/(σ*sqrt(2*π))*exp(-1/2*((z-μ)/σ)^2)\nfor k in over_elems_real(grid)\n  tmp[:u_initial, k] = ic(get_z(grid, k))\n  q[:u, k] = tmp[:u_initial, k]\nend\nplot_state(tmp, grid, \"./\", \"u_initial.svg\", :u_initial) # for visualizing\nfor i in 1:maxiter\n  for k in over_elems_real(grid)\n    rhs[:u, k] = - adv_upwind(q[:u, Cut(k)], c .* [1,1,1], grid)\n  end\n  for k in over_elems(grid)\n    q[:u, k] += Δt*rhs[:u, k]\n  end\n  Dirichlet!(q, :u, 0.0, grid, Top())\n  Dirichlet!(q, :u, 0.0, grid, Bottom())\nend\nplot_state(q, grid, \"./\", \"u_final.svg\", :u) # for visualizing\nnothing # hide","category":"page"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"(Image: ) (Image: )","category":"page"},{"location":"Atmos/TurbulenceConvection.html#Solving-a-non-linear-advection-equation-conservative-form-1","page":"TurbulenceConvection","title":"Solving a non-linear advection equation conservative form","text":"","category":"section"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"Here, we solve a non-linear advection equation","category":"page"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"_t u + (uu) = 0 qquad u = 0  Ω","category":"page"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"u(t=0) = Gaussian(σ μ)","category":"page"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"using Explicit Euler method.","category":"page"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"\nusing CLIMA.TurbulenceConvection.Grids\nusing CLIMA.TurbulenceConvection.GridOperators\nusing CLIMA.TurbulenceConvection.BoundaryConditions\nusing CLIMA.TurbulenceConvection.StateVecs\nusing CLIMA.TurbulenceConvection.StateVecFuncs\nusing Plots\n\nn_sd = 1 # number of sub-domains\nmaxiter = 400 # time-step iterations\nΔt = 0.00001 # time step\n\ngrid = Grid(0.0, 1.0, 200)\nunknowns = ( (:u, n_sd), )\nvars = ( (:u_initial, n_sd), )\nq = StateVec(unknowns, grid)\ntmp = StateVec(vars, grid)\nrhs = deepcopy(q)\n\nσ, μ, c = .05, 0.3, 1.0\nT = maxiter*Δt\nic(z) = 1/(σ*sqrt(2*π))*exp(-1/2*((z-μ)/σ)^2)\nfor k in over_elems_real(grid)\n  tmp[:u_initial, k] = ic(get_z(grid, k))\n  q[:u, k] = tmp[:u_initial, k]\nend\nplot_state(tmp, grid, \"./\", \"u_initialNonLinear.svg\", :u_initial) # for visualizing\nfor i in 1:maxiter\n  for k in over_elems_real(grid)\n    rhs[:u, k] = - adv_upwind_conservative(q[:u, Cut(k)], q[:u, Cut(k)], grid)\n  end\n  for k in over_elems(grid)\n    q[:u, k] += Δt*rhs[:u, k]\n  end\n  Dirichlet!(q, :u, 0.0, grid, Top())\n  Dirichlet!(q, :u, 0.0, grid, Bottom())\nend\nplot_state(q, grid, \"./\", \"u_finalNonLinear.svg\", :u) # for visualizing\nnothing # hide","category":"page"},{"location":"Atmos/TurbulenceConvection.html#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"(Image: ) (Image: )","category":"page"},{"location":"CodingConventions.html#Coding-Conventions-1","page":"Coding Conventions","title":"Coding Conventions","text":"","category":"section"},{"location":"CodingConventions.html#","page":"Coding Conventions","title":"Coding Conventions","text":"A list of recommended coding conventions.","category":"page"},{"location":"CodingConventions.html#","page":"Coding Conventions","title":"Coding Conventions","text":"There are good recommendations in the Julia style-guide:\nhttps://docs.julialang.org/en/v1/manual/style-guide/index.html\nhttps://docs.julialang.org/en/v0.6/manual/packages/#Guidelines-for-naming-a-package-1\nPlease only use Unicode characters that are within our list of acceptable Unicode characters (in AcceptableUnicode.md).\nModules, and class names (structs), should follow TitleCase convention. Note that class names cannot coincide with module names.\nFunction names should be lowercase, with words separated by underscores as necessary to improve readability.\nVariable names follow the format used in the VariableList. In addition, follow CMIP conventions (http://clipc-services.ceda.ac.uk/dreq/) where possible and practicable.\nMake names consistent, distinctive, and meaningful.\nDocument design and purpose, rather than mechanics and implementation (document interfaces and embed documentation in code).\nAvoid variable names that coincide with module and class names, as well as function/variable names that are natively supported.\nNever use the characters 'l' (lowercase letter el), 'O' (uppercase letter oh), or 'I' (uppercase letter eye) as single character variable names.\nTwo white spaces are used for indent. This is not part of the standard convention, but recent development efforts have been using this indentation style (e.g., Google's Tensorflow), and this style is being used here also.\nKISS (keep it simple stupid).\nTry to limit all lines to a maximum of 79 characters.\nSingle access point - if a variable/constant is defined more than once, then move it into a module and import (or \"using\") to that module to access the variable in order to enforce a single access point (to avoid consistency issues). Any time a chunk of code is used more than once, or when several similar versions exist across the codebase, consider generalizing this functionality and using a new function to avoid replicating code\n\"import\"/\"using\" should be grouped in the following order:\nStandard library imports.\nRelated third party imports.\nLocal application/library specific imports.\nUse a blank line between each group of imports.","category":"page"},{"location":"CodingConventions.html#Why-do-we-limit-our-Unicode-use?-1","page":"Coding Conventions","title":"Why do we limit our Unicode use?","text":"","category":"section"},{"location":"CodingConventions.html#","page":"Coding Conventions","title":"Coding Conventions","text":"Some characters are visibly indistinguishable. Capital \"a\" and capital alpha are visibly indistinguishable, but are recognized as separate characters (e.g., search distinguishable).\nSome characters are difficult to read. Sometimes, the overline/overdot/hats overlap with characters making them difficult to see.\nPortability issues. Unicode does not render in Jupyter notebook natively (on OSX).\nIf it does improve readability enough, and are not worried about portability, we may introduce a list of permissible characters that are commonly used.","category":"page"},{"location":"Mesh.html#Meshing-Stuff-1","page":"Mesh","title":"Meshing Stuff","text":"","category":"section"},{"location":"Mesh.html#","page":"Mesh","title":"Mesh","text":"CurrentModule = CLIMA.Mesh","category":"page"},{"location":"Mesh.html#Topologies-1","page":"Mesh","title":"Topologies","text":"","category":"section"},{"location":"Mesh.html#","page":"Mesh","title":"Mesh","text":"Topologies encode the connectivity of the elements, spatial domain interval and MPI communication.","category":"page"},{"location":"Mesh.html#Types-1","page":"Mesh","title":"Types","text":"","category":"section"},{"location":"Mesh.html#","page":"Mesh","title":"Mesh","text":"Topologies.AbstractTopology\nTopologies.BoxElementTopology\nTopologies.BrickTopology\nTopologies.StackedBrickTopology\nTopologies.CubedShellTopology\nTopologies.StackedCubedSphereTopology","category":"page"},{"location":"Mesh.html#CLIMA.Mesh.Topologies.AbstractTopology","page":"Mesh","title":"CLIMA.Mesh.Topologies.AbstractTopology","text":"AbstractTopology{dim}\n\nRepresents the connectivity of individual elements, with local dimension dim.\n\n\n\n\n\n","category":"type"},{"location":"Mesh.html#CLIMA.Mesh.Topologies.BoxElementTopology","page":"Mesh","title":"CLIMA.Mesh.Topologies.BoxElementTopology","text":"BoxElementTopology{dim, T} <: AbstractTopology{dim}\n\nThe local topology of a larger MPI-distributed topology, represented by dim-dimensional box elements.\n\nThis contains the necessary information for the connectivity elements of the elements on the local process, along with \"ghost\" elements from neighbouring processes.\n\nFields\n\nmpicomm\nMPI communicator for communicating with neighbouring processes.\n\nelems\nRange of element indices\n\nrealelems\nRange of real (aka nonghost) element indices\n\nghostelems\nRange of ghost element indices\n\nghostfaces\nGhost element to face is received; ghostfaces[f,ge] == true if face f of ghost element ge is received.\n\nsendelems\nArray of send element indices\n\nsendfaces\nSend element to face is sent; sendfaces[f,se] == true if face f of send element se is sent.\n\nelemtocoord\nElement to vertex coordinates; elemtocoord[d,i,e] is the dth coordinate of corner i of element e\nnote: Note\ncurrently coordinates always are of size 3 for (x1, x2, x3)\n\nelemtoelem\nElement to neighboring element; elemtoelem[f,e] is the number of the element neighboring element e across face f.  If there is no neighboring element then elemtoelem[f,e] == e.\n\nelemtoface\nElement to neighboring element face; elemtoface[f,e] is the face number of the element neighboring element e across face f.  If there is no neighboring element then elemtoface[f,e] == f.\"\n\nelemtoordr\nelement to neighboring element order; elemtoordr[f,e] is the ordering number of the element neighboring element e across face f.  If there is no neighboring element then elemtoordr[f,e] == 1.\n\nelemtobndy\nElement to boundary number; elemtobndy[f,e] is the boundary number of face f of element e.  If there is a neighboring element then elemtobndy[f,e] == 0.\n\nnabrtorank\nList of the MPI ranks for the neighboring processes\n\nnabrtorecv\nRange in ghost elements to receive for each neighbor\n\nnabrtosend\nRange in sendelems to send for each neighbor\n\nhasboundary\nboolean for whether or not this topology has a boundary\n\n\n\n\n\n","category":"type"},{"location":"Mesh.html#CLIMA.Mesh.Topologies.BrickTopology","page":"Mesh","title":"CLIMA.Mesh.Topologies.BrickTopology","text":"BrickTopology{dim, T} <: AbstractTopology{dim}\n\nA simple grid-based topology. This is a convenience wrapper around BoxElementTopology.\n\n\n\n\n\n","category":"type"},{"location":"Mesh.html#CLIMA.Mesh.Topologies.StackedBrickTopology","page":"Mesh","title":"CLIMA.Mesh.Topologies.StackedBrickTopology","text":"StackedBrickTopology{dim, T} <: AbstractTopology{dim}\n\nA simple grid-based topology, where all elements on the trailing dimension are stacked to be contiguous. This is a convenience wrapper around BoxElementTopology.\n\n\n\n\n\n","category":"type"},{"location":"Mesh.html#CLIMA.Mesh.Topologies.CubedShellTopology","page":"Mesh","title":"CLIMA.Mesh.Topologies.CubedShellTopology","text":"CubedShellTopology{T} <: AbstractTopology{2}\n\nA cube-shell topology. This is a convenience wrapper around BoxElementTopology.\n\n\n\n\n\n","category":"type"},{"location":"Mesh.html#CLIMA.Mesh.Topologies.StackedCubedSphereTopology","page":"Mesh","title":"CLIMA.Mesh.Topologies.StackedCubedSphereTopology","text":"StackedCubedSphereTopology{3, T} <: AbstractTopology{3}\n\nA cube-sphere topology. All elements on the same \"vertical\" dimension are stacked to be contiguous. This is a convenience wrapper around BoxElementTopology.\n\n\n\n\n\n","category":"type"},{"location":"Mesh.html#Constructors-1","page":"Mesh","title":"Constructors","text":"","category":"section"},{"location":"Mesh.html#","page":"Mesh","title":"Mesh","text":"Topologies.BrickTopology(mpicomm, Nelems)\nTopologies.StackedBrickTopology(mpicomm, elemrange)\nTopologies.CubedShellTopology(mpicomm, Neside, T)\nTopologies.StackedCubedSphereTopology(mpicomm, Nhorz, Rrange)","category":"page"},{"location":"Mesh.html#CLIMA.Mesh.Topologies.BrickTopology-Tuple{Any,Any}","page":"Mesh","title":"CLIMA.Mesh.Topologies.BrickTopology","text":"BrickTopology{dim, T}(mpicomm, elemrange; boundary, periodicity)\n\nGenerate a brick mesh topology with coordinates given by the tuple elemrange and the periodic dimensions given by the periodicity tuple.\n\nThe elements of the brick are partitioned equally across the MPI ranks based on a space-filling curve.\n\nBy default boundary faces will be marked with a one and other faces with a zero.  Specific boundary numbers can also be passed for each face of the brick in boundary.  This will mark the nonperiodic brick faces with the given boundary number.\n\nExamples\n\nWe can build a 3 by 2 element two-dimensional mesh that is periodic in the x2-direction with\n\n\nusing CLIMA.Topologies\nusing MPI\nMPI.Init()\ntopology = BrickTopology(MPI.COMM_SELF, (2:5,4:6);\n                         periodicity=(false,true),\n                         boundary=((1,2),(3,4)))\n\nThis returns the mesh structure for\n\n         x2\n\n          ^\n          |\n         6-  +-----+-----+-----+\n          |  |     |     |     |\n          |  |  3  |  4  |  5  |\n          |  |     |     |     |\n         5-  +-----+-----+-----+\n          |  |     |     |     |\n          |  |  1  |  2  |  6  |\n          |  |     |     |     |\n         4-  +-----+-----+-----+\n          |\n          +--|-----|-----|-----|--> x1\n             2     3     4     5\n\nFor example, the (dimension by number of corners by number of elements) array elemtocoord gives the coordinates of the corners of each element.\n\njulia> topology.elemtocoord\n2×4×6 Array{Int64,3}:\n[:, :, 1] =\n 2  3  2  3\n 4  4  5  5\n\n[:, :, 2] =\n 3  4  3  4\n 4  4  5  5\n\n[:, :, 3] =\n 2  3  2  3\n 5  5  6  6\n\n[:, :, 4] =\n 3  4  3  4\n 5  5  6  6\n\n[:, :, 5] =\n 4  5  4  5\n 5  5  6  6\n\n[:, :, 6] =\n 4  5  4  5\n 4  4  5  5\n\nNote that the corners are listed in Cartesian order.\n\nThe (number of faces by number of elements) array elemtobndy gives the boundary number for each face of each element.  A zero will be given for connected faces.\n\njulia> topology.elemtobndy\n4×6 Array{Int64,2}:\n 1  0  1  0  0  0\n 0  0  0  0  2  2\n 0  0  0  0  0  0\n 0  0  0  0  0  0\n\nNote that the faces are listed in Cartesian order.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#CLIMA.Mesh.Topologies.StackedBrickTopology-Tuple{Any,Any}","page":"Mesh","title":"CLIMA.Mesh.Topologies.StackedBrickTopology","text":"StackedBrickTopology{dim, T}(mpicomm, elemrange; boundary, periodicity)\n\nGenerate a stacked brick mesh topology with coordinates given by the tuple elemrange and the periodic dimensions given by the periodicity tuple.\n\nThe elements are stacked such that the elements associated with range elemrange[dim] are contiguous in the element ordering.\n\nThe elements of the brick are partitioned equally across the MPI ranks based on a space-filling curve.  Further, stacks are not split at MPI boundaries.\n\nBy default boundary faces will be marked with a one and other faces with a zero.  Specific boundary numbers can also be passed for each face of the brick in boundary.  This will mark the nonperiodic brick faces with the given boundary number.\n\nExamples\n\nWe can build a 3 by 2 element two-dimensional mesh that is periodic in the x2-direction with\n\n\nusing CLIMA.Topologies\nusing MPI\nMPI.Init()\ntopology = StackedBrickTopology(MPI.COMM_SELF, (2:5,4:6);\n                                periodicity=(false,true),\n                                boundary=((1,2),(3,4)))\n\nThis returns the mesh structure stacked in the x2-direction for\n\n         x2\n\n          ^\n          |\n         6-  +-----+-----+-----+\n          |  |     |     |     |\n          |  |  2  |  4  |  6  |\n          |  |     |     |     |\n         5-  +-----+-----+-----+\n          |  |     |     |     |\n          |  |  1  |  3  |  5  |\n          |  |     |     |     |\n         4-  +-----+-----+-----+\n          |\n          +--|-----|-----|-----|--> x1\n             2     3     4     5\n\nFor example, the (dimension by number of corners by number of elements) array elemtocoord gives the coordinates of the corners of each element.\n\njulia> topology.elemtocoord\n2×4×6 Array{Int64,3}:\n[:, :, 1] =\n 2  3  2  3\n 4  4  5  5\n\n[:, :, 2] =\n 2  3  2  3\n 5  5  6  6\n\n[:, :, 3] =\n 3  4  3  4\n 4  4  5  5\n\n[:, :, 4] =\n 3  4  3  4\n 5  5  6  6\n\n[:, :, 5] =\n 4  5  4  5\n 4  4  5  5\n\n[:, :, 6] =\n 4  5  4  5\n 5  5  6  6\n\nNote that the corners are listed in Cartesian order.\n\nThe (number of faces by number of elements) array elemtobndy gives the boundary number for each face of each element.  A zero will be given for connected faces.\n\njulia> topology.elemtobndy\n4×6 Array{Int64,2}:\n 1  0  1  0  0  0\n 0  0  0  0  2  2\n 0  0  0  0  0  0\n 0  0  0  0  0  0\n\nNote that the faces are listed in Cartesian order.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#CLIMA.Mesh.Topologies.CubedShellTopology-Tuple{Any,Any,Any}","page":"Mesh","title":"CLIMA.Mesh.Topologies.CubedShellTopology","text":"CubedShellTopology(mpicomm, Nelem, T) <: AbstractTopology{dim}\n\nGenerate a cubed shell mesh with the number of elements along each dimension of the cubes being Nelem. This topology actual creates a cube mesh, and the warping should be done after the grid is created using the cubedshellwarp function. The coordinates of the points will be of type T.\n\nThe elements of the shell are partitioned equally across the MPI ranks based on a space-filling curve.\n\nNote that this topology is logically 2-D but embedded in a 3-D space\n\nExamples\n\nWe can build a cubed shell mesh with 10 elements on each cube, total elements is 10 * 10 * 6 = 600, with\n\nusing CLIMA.Topologies\nusing MPI\nMPI.Init()\ntopology = CubedShellTopology(MPI.COMM_SELF, 10, Float64)\n\n# Typically the warping would be done after the grid is created, but the cell\n# corners could be warped with...\n\n# Shell radius = 1\nx1, x2, x3 = ntuple(j->topology.elemtocoord[j, :, :], 3)\nfor n = 1:length(x1)\n   x1[n], x2[n], x3[n] = Topologies.cubedshellwarp(x1[n], x2[n], x3[n])\nend\n\n# Shell radius = 10\nx1, x2, x3 = ntuple(j->topology.elemtocoord[j, :, :], 3)\nfor n = 1:length(x1)\n  x1[n], x2[n], x3[n] = Topologies.cubedshellwarp(x1[n], x2[n], x3[n], 10)\nend\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#CLIMA.Mesh.Topologies.StackedCubedSphereTopology-Tuple{Any,Any,Any}","page":"Mesh","title":"CLIMA.Mesh.Topologies.StackedCubedSphereTopology","text":"StackedCubedSphereTopology(mpicomm, Nhorz, Rrange;                               boundary=(1,1)) <: AbstractTopology{3}\n\nGenerate a stacked cubed sphere topology with Nhorz by Nhorz cells for each horizontal face and Rrange is the radius edges of the stacked elements.  This topology actual creates a cube mesh, and the warping should be done after the grid is created using the cubedshellwarp function. The coordinates of the points will be of type eltype(Rrange). The inner boundary condition type is boundary[1] and the outer boundary condition type is boundary[2].\n\nThe elements are stacked such that the vertical elements are contiguous in the element ordering.\n\nThe elements of the brick are partitioned equally across the MPI ranks based on a space-filling curve. Further, stacks are not split at MPI boundaries.\n\nExamples\n\nWe can build a cubed sphere mesh with 10 x 10 x 5 elements on each cube, total elements is 10 * 10 * 5 * 6 = 3000, with\n\nusing CLIMA.Topologies\nusing MPI\nMPI.Init()\nNhorz = 10\nNstack = 5\nRrange = Float64.(accumulate(+,1:Nstack+1))\ntopology = StackedCubedSphereTopology(MPI.COMM_SELF, Nhorz, Rrange)\n\nx1, x2, x3 = ntuple(j->reshape(topology.elemtocoord[j, :, :],\n                            2, 2, 2, length(topology.elems)), 3)\nfor n = 1:length(x1)\n   x1[n], x2[n], x3[n] = Topologies.cubedshellwarp(x1[n], x2[n], x3[n])\nend\n\nNote that the faces are listed in Cartesian order.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#Functions-1","page":"Mesh","title":"Functions","text":"","category":"section"},{"location":"Mesh.html#","page":"Mesh","title":"Mesh","text":"Topologies.cubedshellmesh\nTopologies.cubedshellwarp\nTopologies.hasboundary","category":"page"},{"location":"Mesh.html#CLIMA.Mesh.Topologies.cubedshellmesh","page":"Mesh","title":"CLIMA.Mesh.Topologies.cubedshellmesh","text":"cubedshellmesh(T, Ne; part=1, numparts=1)\n\nGenerate a cubed mesh with each of the \"cubes\" has an Ne X Ne grid of elements.\n\nThe mesh can optionally be partitioned into numparts and this returns partition part.  This is a simple Cartesian partition and further partitioning (e.g, based on a space-filling curve) should be done before the mesh is used for computation.\n\nThis mesh returns the cubed spehere in a flatten fashion for the vertex values, and a remapping is needed to embed the mesh in a 3-D space.\n\nThe mesh structures for the cubes is as follows:\n\nx2\n   ^\n   |\n4Ne-           +-------+\n   |           |       |\n   |           |   6   |\n   |           |       |\n3Ne-           +-------+\n   |           |       |\n   |           |   5   |\n   |           |       |\n2Ne-           +-------+\n   |           |       |\n   |           |   4   |\n   |           |       |\n Ne-   +-------+-------+-------+\n   |   |       |       |       |\n   |   |   1   |   2   |   3   |\n   |   |       |       |       |\n  0-   +-------+-------+-------+\n   |\n   +---|-------|-------|------|-> x1\n       0      Ne      2Ne    3Ne\n\n\n\n\n\n","category":"function"},{"location":"Mesh.html#CLIMA.Mesh.Topologies.cubedshellwarp","page":"Mesh","title":"CLIMA.Mesh.Topologies.cubedshellwarp","text":"cubedshellwarp(a, b, c, R = max(abs(a), abs(b), abs(c)))\n\nGiven points (a, b, c) on the surface of a cube, warp the points out to a spherical shell of radius R based on the equiangular gnomonic grid proposed by Ronchi, Iacono, Paolucci (1996) https://dx.doi.org/10.1006/jcph.1996.0047\n\n@article{RonchiIaconoPaolucci1996,\n  title={The ``cubed sphere'': a new method for the solution of partial\n         differential equations in spherical geometry},\n  author={Ronchi, C. and Iacono, R. and Paolucci, P. S.},\n  journal={Journal of Computational Physics},\n  volume={124},\n  number={1},\n  pages={93--114},\n  year={1996},\n  doi={10.1006/jcph.1996.0047}\n}\n\n\n\n\n\n","category":"function"},{"location":"Mesh.html#CLIMA.Mesh.Topologies.hasboundary","page":"Mesh","title":"CLIMA.Mesh.Topologies.hasboundary","text":"hasboundary(topology::AbstractTopology)\n\nquery function to check whether a topology has a boundary (i.e., not fully periodic)\n\n\n\n\n\n","category":"function"},{"location":"Mesh.html#Grids-1","page":"Mesh","title":"Grids","text":"","category":"section"},{"location":"Mesh.html#","page":"Mesh","title":"Mesh","text":"Grids specify the approximation within each element, and any necessary warping.","category":"page"},{"location":"Mesh.html#","page":"Mesh","title":"Mesh","text":"Grids.DiscontinuousSpectralElementGrid","category":"page"},{"location":"Mesh.html#CLIMA.Mesh.Grids.DiscontinuousSpectralElementGrid","page":"Mesh","title":"CLIMA.Mesh.Grids.DiscontinuousSpectralElementGrid","text":"DiscontinuousSpectralElementGrid(topology; FloatType, DeviceArray,\n                                 polynomialorder,\n                                 meshwarp = (x...)->identity(x))\n\nGenerate a discontinuous spectral element (tensor product, Legendre-Gauss-Lobatto) grid/mesh from a topology, where the order of the elements is given by polynomialorder. DeviceArray gives the array type used to store the data (CuArray or Array), and the coordinate points will be of FloatType.\n\nThe optional meshwarp function allows the coordinate points to be warped after the mesh is created; the mesh degrees of freedom are orginally assigned using a trilinear blend of the element corner locations.\n\n\n\n\n\n","category":"type"},{"location":"Mesh.html#Filters-1","page":"Mesh","title":"Filters","text":"","category":"section"},{"location":"Mesh.html#","page":"Mesh","title":"Mesh","text":"There are methods used to cleanup state vectors.","category":"page"},{"location":"Mesh.html#","page":"Mesh","title":"Mesh","text":"Filters.CutoffFilter\nFilters.ExponentialFilter\nFilters.TMARFilter","category":"page"},{"location":"Mesh.html#CLIMA.Mesh.Filters.CutoffFilter","page":"Mesh","title":"CLIMA.Mesh.Filters.CutoffFilter","text":"CutoffFilter(grid, Nc=polynomialorder(grid))\n\nReturns the spectral filter that zeros out polynomial modes greater than or equal to Nc.\n\n\n\n\n\n","category":"type"},{"location":"Mesh.html#CLIMA.Mesh.Filters.ExponentialFilter","page":"Mesh","title":"CLIMA.Mesh.Filters.ExponentialFilter","text":"ExponentialFilter(grid, Nc=0, s=32, α=-log(eps(eltype(grid))))\n\nReturns the spectral filter with the filter function\n\nσ(η) = xp(-α η^s)\n\nwhere s is the filter order (must be even), the filter starts with polynomial order Nc, and alpha is a parameter controlling the smallest value of the filter function.\n\n\n\n\n\n","category":"type"},{"location":"Mesh.html#CLIMA.Mesh.Filters.TMARFilter","page":"Mesh","title":"CLIMA.Mesh.Filters.TMARFilter","text":"TMARFilter()\n\nReturns the truncation and mass aware rescaling nonnegativity preservation filter.  The details of this filter are described in\n\n@article{doi:10.1175/MWR-D-16-0220.1,\n  author = {Light, Devin and Durran, Dale},\n  title = {Preserving Nonnegativity in Discontinuous Galerkin\n           Approximations to Scalar Transport via Truncation and Mass\n           Aware Rescaling (TMAR)},\n  journal = {Monthly Weather Review},\n  volume = {144},\n  number = {12},\n  pages = {4771-4786},\n  year = {2016},\n  doi = {10.1175/MWR-D-16-0220.1},\n}\n\nNote this needs to be used with a restrictive time step or a flux correction to ensure that grid integral is conserved.\n\nExamples\n\nThis filter can be applied to the 3rd and 4th fields of an MPIStateArray Q with the code\n\nFilters.apply!(Q, (3, 4), grid, TMARFilter())\n\nwhere grid is the associated DiscontinuousSpectralElementGrid.\n\n\n\n\n\n","category":"type"},{"location":"Arrays.html#Arrays-1","page":"Arrays","title":"Arrays","text":"","category":"section"},{"location":"Arrays.html#","page":"Arrays","title":"Arrays","text":"CurrentModule = CLIMA","category":"page"},{"location":"Arrays.html#MPIStateArrays-1","page":"Arrays","title":"MPIStateArrays","text":"","category":"section"},{"location":"Arrays.html#","page":"Arrays","title":"Arrays","text":"Storage for the state of a discretization.","category":"page"},{"location":"Arrays.html#","page":"Arrays","title":"Arrays","text":"MPIStateArrays.MPIStateArray\nMPIStateArrays.post_Irecvs!\nMPIStateArrays.start_ghost_exchange!\nMPIStateArrays.finish_ghost_exchange!","category":"page"},{"location":"Arrays.html#CLIMA.MPIStateArrays.MPIStateArray","page":"Arrays","title":"CLIMA.MPIStateArrays.MPIStateArray","text":"MPIStateArray{FT, DATN<:AbstractArray{FT,3}, DAI1, DAV,\n              DAT2<:AbstractArray{FT,2}} <: AbstractArray{FT, 3}\n\n\n\n\n\n","category":"type"},{"location":"Arrays.html#CLIMA.MPIStateArrays.post_Irecvs!","page":"Arrays","title":"CLIMA.MPIStateArrays.post_Irecvs!","text":"post_Irecvs!(Q::MPIStateArray)\n\nposts the MPI.Irecv! for Q\n\n\n\n\n\n","category":"function"},{"location":"Arrays.html#CLIMA.MPIStateArrays.start_ghost_exchange!","page":"Arrays","title":"CLIMA.MPIStateArrays.start_ghost_exchange!","text":"start_ghost_exchange!(Q::MPIStateArray; dorecvs=true)\n\nStart the MPI exchange of the data stored in Q. If dorecvs is true then post_Irecvs!(Q) is called, otherwise the caller is responsible for this.\n\nThis function will fill the send buffer (on the device), copies the data from the device to the host, and then issues the send. Previous sends are waited on to ensure that they are complete.\n\n\n\n\n\n","category":"function"},{"location":"Arrays.html#CLIMA.MPIStateArrays.finish_ghost_exchange!","page":"Arrays","title":"CLIMA.MPIStateArrays.finish_ghost_exchange!","text":"finish_ghost_exchange!(Q::MPIStateArray)\n\nComplete the exchange of data and fill the data array on the device. Note this completes both the send and the receive communication. For more fine level control see finishghostrecv! and finishghostsend!\n\n\n\n\n\n","category":"function"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"newcommandparamT1     textcolorblue  text1\nnewcommandhyperparamT1textcolororangetext1\nnewcommandsimparamT1  textcolorpurpletext1\n\nnewcommandexp1mathrmexpleft(1right)\nnewcommandatan1mathrmatanleft(1right)\nnewcommandsign1mathrmsignleft(1right)\nnewcommanderf1mathrmerfleft(1right)\nnewcommanderfinv1mathrmerfinvleft(1right)\n\nnewcommandparam1     textcolorblue  1\nnewcommandhyperparam1textcolororange1\nnewcommandsimparam1  textcolorpurple1\n\nnewcommandCROSStimes\nnewcommandGRADnabla\nnewcommandDOTbullet\nnewcommandPDpartial\nnewcommandPDFzfracPDPD z\nnewcommandDM1langle 1 rangle\nnewcommandiEnve\nnewcommandSD2overline1_2\nnewcommandSDi1SD1i\nnewcommandSDj1SD1j\nnewcommandSDe1SD1iEnv\nnewcommandSDiog21_2\nnewcommandSDio1SDiog1i\nnewcommandSDjo1SDiog1j\nnewcommandSDeo1SDiog1iEnv\nnewcommandaSD21_2\nnewcommandaSDi1aSD1i\nnewcommandaSDj1aSD1j\nnewcommandaSDe1aSD1iEnv\nnewcommandotherDefswhere additional variable definitions are in\n\nnewcommandIntraCVSDi2overline1_i      2_i      \nnewcommandIntraCVSDj2overline1_j      2_j      \nnewcommandIntraCVSDe2overline1_iEnv2_iEnv\n\nnewcommandInterCVSDi2overline1_i      overline2_i      \nnewcommandInterCVSDj2overline1_j      overline2_j      \nnewcommandInterCVSDe2overline1_iEnvoverline2_iEnv\n\nnewcommandTCV2langle 1^*2^* rangle\n\nnewcommandBC11_z_min\nnewcommandBCT11_z_max\nnewcommandBCB11_z_min\nnewcommandBCG11_z_boundary\n\nnewcommandKmK^m\nnewcommandKhK^h\nnewcommandTEquilibT_mathrmiterated\nnewcommandPhasePartitionq\nnewcommandExnerDPi_dry\nnewcommandExnerMPi_moist\nnewcommandWindSpeedu\nnewcommandLayerThicknessparamDelta z\nnewcommandSurfaceRoughness1paramz_01\nnewcommandSensibleSurfaceHeatFluxF_mathrmsensible\nnewcommandLatentSurfaceHeatFluxF_mathrmlatent\nnewcommandFrictionVelocityu_*\nnewcommandBuoyancyb\nnewcommandBuoyancyGradPD_z Buoyancy\nnewcommandBuoyancyFluxIntraCVSDiwb\nnewcommandTemperatureScaletheta_*\nnewcommandSurfaceMomentumFluxBCoverlinewu\nnewcommandSurfaceHeatFluxBCoverlinewtheta\nnewcommandSurfaceBuoyancyFluxBCIntraCVSDiwtheta\nnewcommandConvectiveVelocityw_*  Convective velocity near the surface\nnewcommandInversionHeightz_*\nnewcommandMOLenLambda_M-O\nnewcommandzLLparamz_  z at the first surface level (we should make this grid-independent)\n\nnewcommandqtq_mathrmtot\nnewcommandqrq_mathrmrain\nnewcommandqlq_mathrmliq\nnewcommandqiq_mathrmice\nnewcommandqvq_mathrmvap\nnewcommandqvsatq_mathrmvap^*\nnewcommandpvsatp_mathrmvap^*\nnewcommandqcq_mathrmcon\nnewcommandThetaVaptheta_mathrmvap\nnewcommandThetaVirttheta_mathrmvirt\nnewcommandThetaRhotheta_rho\nnewcommandThetaLiqtheta_mathrmliq\nnewcommandThetaLiqIcetheta_mathrmliq-ice\nnewcommandThetaLiqIceSattheta^*_mathrmliq-ice\nnewcommandThetaDrytheta_mathrmdry\nnewcommandTDryT_dry\nnewcommandeinte_mathrmint\nnewcommandetote_mathrmtot\n\nnewcommandTRefT_0\nnewcommandalphaRefalpha_0\nnewcommandrhoRefrho_0\nnewcommandpRefp_0\nnewcommandHeavisidemathcal H\n\nnewcommandalphaLLalphaRef_zLL\nnewcommanduHsimparammathbfu_h\n\nnewcommandCoriolisParamhyperparammathrmcoriolis_param\nnewcommandSubsidenceParamhyperparammathrmsubsidence\nnewcommandbetaMhyperparambeta_m\nnewcommandbetaHhyperparambeta_h\nnewcommandgammaMhyperparamgamma_m\nnewcommandgammaHhyperparamgamma_h\n\nnewcommandPTildeparamtildep\nnewcommandVKConstparamkappa_mathrmVon-Karman\nnewcommandNsdhyperparamN_sd\nnewcommandgravparamg\nnewcommandTZeroparamT_0\nnewcommandRefHintVparameint_v0\nnewcommandRefHintIparameint_i0\n\nnewcommandEpsDVparamvarepsilon_dv\nnewcommandEpsVDparamvarepsilon_vd\nnewcommandRmR_m\nnewcommandCpmc_pm\nnewcommandCvmc_vm\nnewcommandRdparamR_d\nnewcommandRvparamR_v\nnewcommandCp1paramc_p1\nnewcommandCv1paramc_v1\nnewcommandCvdCvd\nnewcommandCvvCvv\nnewcommandCvlCvl\nnewcommandCviCvi\n\nnewcommandDeltaCpparamDelta c_p\nnewcommandTTripleparamT_mathrmtr\nnewcommandPTripleparamp_mathrmtr\nnewcommandTFreezeparamT_mathrmfreeze\n\nnewcommandRefLHvparamL_v0\nnewcommandRefLHsparamL_s0\nnewcommandRefLHfparamL_f0\nnewcommandLatentHeatV1L_vap(1)\nnewcommandLatentHeatS1L_sub(1)\nnewcommandLatentHeatF1L_fus(1)","category":"page"},{"location":"Atmos/EDMFEquations.html#Eddy-Diffusivity-Mass-Flux-(EDMF)-equations-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"This document is concerned with defining the set of equations solved in the atmospheric turbulence convection model: the EDMF equations. Color-coding is used to indicate:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"paramTConstant parameters that are fixed in space and time (eg those defined in PlanetParametersjl)\nsimparamTSingle column (SC) inputs (eg variables that are fed into the SC model from the dynamical core (eg horizontal velocity))\nhyperparamTTunable hyper-parameters that will need to be changeable but will only include single numbers (eg Float64)","category":"page"},{"location":"Atmos/EDMFEquations.html#Domain-decomposition-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Domain decomposition","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"While our model is 1D along z and there is no spatial discretization in the horizontal directions (x and y), the horizontal space is broken into Nsd (sim 5-10) \"bins\", or \"subdomains\" (SDs), denoted by subscript i, where 1 le i le Nsd. One of the subdomains, the \"environment\", is treated different compared to others, termed \"updrafts\". This environment subdomain is denoted with a special index iEnv (which we usually set to 1). For dummy variables phi and psi, we use several domain and SD representations of interest:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\n  SDiphi                                                                                   quad  texthorizontal mean of variable phi over SD i \n  SDiphi = phi_i - SDiphi                                                            quad  textfluctuations of phi about the SD mean \n  IntraCVSDiphipsi                                                                      quad  textintra subdomain covariance \n  DMphi = sum_i aSDia SDiphi                                                       quad  texthorizontal mean of phi over the total domain \n  SDiphi^* = SDiphi - DMphi                                                        quad  textdifference between SD  domain means \n  InterCVSDiphipsi                                                                      quad  textinter subdomain covariance among SD means \n  phi^* = phi - DMphi                                                                    quad  textdifference between SD  domain means \n  TCVphipsi = sum_forall i a_i IntraCVSDiphipsi +\n  sum_forall i sum_forall j  aSDia aSDja SDiphi(SDipsi - SDjpsi)     quad  texttotal covariance\nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Here, SDiphi and SDipsi are a dummy variables for the following 7 unknowns:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\n  SDiw                    quad textvertical velocity \n  SDieint                quad textinternal energy  \n  SDiqt                  quad texttotal water specific humidity  \n  SDiTKE                  quad textturbulent kinetic energy (05(IntraCVSDiuu+IntraCVSDivv+IntraCVSDiww))  \n  IntraCVSDieinteint  quad textintra subdomain covariance of eint and eint  \n  IntraCVSDiqtqt      quad textintra subdomain covariance of qt and qt \n  IntraCVSDieintqt    quad textintra subdomain covariance of eint and qt\nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"From the large-scale model perspective, DMphi represents the resolved grid-scale (GS) mean, and TCVphipsi represents the SGS fluxes and (co)-variances of scalars that need to be parameterized. Equations in the following sections, \\eqref{eq:AreaFracGov}, \\eqref{eq:1stMoment} and \\eqref{eq:2ndMoment}, are solved on z_min le z le z_max and t ge 0. There are 8 Nsd equations in total.","category":"page"},{"location":"Atmos/EDMFEquations.html#Domain-averaged-equations-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Domain averaged equations","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"The EDMF model can be used in the context of a stand-alone single column, or integrated with a dynamical core. Either way, the EDMF model relies on domain-averaged variables, which may be prescribed or solved for. Taking an area fraction-weighted average of the SD equations yields the domain-averaged equations (which should be consistent with variables in the dynamical core).","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"The domain-averaged equations for DMphi in w qt eint uH are:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nPD_t (rhoRef DMphi)\n+ PD_z (rhoRef DMw DMphi)\n+ nabla_h DOT left( rhoRef DMphi otimes DMphi right)\n= \n  DMS_textdiff^DMphi\n+ DMS_textpress\n+ DMS_textcoriolis\n+ DMS_textsubsidence\nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nDMS_textdiff^DMphi  = PD_z (rhoRef aSDea SDeKm PD_z DMphi)   labeleqgm_diffusion \nDMS_textdiff^w          = PD_z (rhoRef aSDea SDeKm PD_z DMw)      labeleqgm_diffusion_w \nDMS_textpress             = - GRAD_h DMp                                       labeleqgm_pressure \nDMS_textcoriolis          = CoriolisParam DMphi CROSS mathbfk             labeleqgm_coriolis \nDMS_textsubsidence        = - SubsidenceParam GRAD phi                          labeleqgm_subsidence \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#Sub-domain-equations:-Area-fraction-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Sub-domain equations: Area fraction","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"The EDMF equations take the form of advection-diffusion equations. The size of these SDs are tracked by solving an equation governing the area fraction in the ith SD (aSDia), given by:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"begingather\n  PD_t (rhoRef aSDia)\n  + PD_z (rhoRef aSDia SDiw)\n  + GRAD_h DOT\n  (rhoRef aSDia DMuH)\n  =\n  SDiS^a\n   quad i ne iEnv labeleqAreaFracGov \n  aSDia = 1 - sum_jneiEnv aSDja quad i = iEnv labeleqAreaFracConserve \n  qquad 0  aSDia  1 labeleqAreaFracConstraint\nendgather","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Here, rhoRef SDiw uH is fluid density, mean vertical velocity along z, and domain-mean of the horizontal velocity respectively. The area fraction constraints are necessary to ensure the system of equations is well-posed. All source terms (SDiS^a) will be discussed in later sections.","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"note: Note\nThe greater than zero constraint must be satisfied at every step of the solution process, since it is necessary to avoid division by zero in the mean field equations.","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nSDiS^a = SDiS_epsilondelta^a\nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#Source-term-definitions-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Source term definitions","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"We note that the net exchange is zero sum_i SDiS_epsilondelta^a = 0. Therefore, we may define the environment source term as the negative sum of all updraft source terms. The entrainment-detrainment source is:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nSDiS_epsilondelta^a =\nbegincases\n  rho a_i SDiw left( -delta_i + epsilon_i right)  i ne iEnv \n  0 - sum_j ne iEnv SDjS_epsilondelta^a  i = iEnv \nendcases\nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nEntrainment-Detrainment (epsilon_i) and (delta_i).","category":"page"},{"location":"Atmos/EDMFEquations.html#Sub-domain-equations:-1st-moment-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Sub-domain equations: 1st moment","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"The 1st moment sub-domain equations are:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleq1stMoment\n  PD_t (rhoRef aSDia SDiphi)\n  + PD_z (rhoRef aSDia SDiw SDiphi)\n  + GRAD_h DOT\n  (rhoRef aSDia DMuH SDiphi)\n  =\n  SDiS^phi\n   quad forall i \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Here, SDiS^phi are source terms, including diffusion, and many other sub-grid-scale (SGS) physics. In general, SDiS^phi and SDiS^a may depend on SDjphi and or aSDja for any j.","category":"page"},{"location":"Atmos/EDMFEquations.html#Source-terms-per-equation-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Source terms per equation","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"The source terms common to all unknowns are:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nSDiS^phi =\n  SDiS_epsilondelta^phi\n+ SDiS_textturb-transp^phi quad forall phi\nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Additional source terms exist in other equations:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nSDiS^w =\n  SDiS_epsilondelta^w\n+ SDiS_textturb-transp^w\n+ SDiS_textbuoy\n+ SDiS_textnh-press\n+ SDiS_textcoriolis \nSDiS^eint =\n  SDiS_epsilondelta^eint\n+ SDiS_textturb-transp^eint\n+ SDiS_textMP-MSS^eint\n+ SDiS_textrad \nSDiS^qt =\n  SDiS_epsilondelta^qt\n+ SDiS_textturb-transp^qt\n+ SDiS_textMP-MSS^qt\nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#Source-term-definitions-2","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Source term definitions","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Note: The sum of the total pressure and gravity are recast into the sum of the non-hydrostatic pressure and buoyancy sources.","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nSDiS_epsilondelta^phi =\nbegincases\n  rhoRef a_i SDiw left( -delta_i SDiphi + epsilon_i SDephi right)  i ne iEnv \n  0 - sum_j ne iEnv SDjS_epsilondelta^phi  i=iEnv \nendcases \nSDiS_textturb-transp^phi  =  -PD_z (rhoRef a_i IntraCVSDiwphi) \n  = PD_z (rhoRef a_i SDiKm PD_z SDiphi) \nSDiS_textnh-press = -rhoRef aSDia left( alpha_b SDib  + alpha_d frac(SDiw - SDew)  SDiw - SDew  r_d aSDia^12 right) \nalpha_b = 13 quad alpha_d = 0375 quad r_d      = 500 m \nSDiS_textbuoy = rhoRef aSDia SDib \nSDiS_textcoriolis  = f(SDimathbfu - SDimathbfu_textgeo-wind) \nSDiS_textrad  = left( PD_t SDieint right)_radiation \nSDiS_textMP-MSS^qt  = \nSDiS_textMP-MSS^eint  = \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nEntrainment-Detrainment (epsilon_i) and (delta_i).\nBuoyancy (Buoyancy).\nEddy diffusivity (Km Kh).","category":"page"},{"location":"Atmos/EDMFEquations.html#Sub-domain-equations:-2nd-moment-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Sub-domain equations: 2nd moment","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"The 2nd moment sub-domain equations are of the exact same form as the 1st moment equations (equation \\eqref{eq:1stMoment}):","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleq2ndMoment\n  PD_t (rhoRef aSDia SDiphi)\n  + PD_z (rhoRef aSDia SDiw SDiphi)\n  + GRAD_h DOT\n  (rhoRef aSDia DMuH SDiphi)\n  =\n  SDiS^phi\n   quad forall i \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Here, SDiS^phi are source terms, including diffusion, and many other sub-grid-scale (SGS) physics. In general, SDiS^phi and SDiS^a may depend on SDjphi and or aSDja for any j.","category":"page"},{"location":"Atmos/EDMFEquations.html#Source-terms-per-equation-2","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Source terms per equation","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"The source terms common to all unknowns are:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nSDiS^phipsi =\n  SDiS_epsilondelta^phipsi\n+ SDiS_textx-grad flux^phipsi\n+ SDiS_textturb-transp^phipsi\nquad forall phi psi\nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Additional source terms exist in other equations:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nSDiS^TKE =\n  SDiS_epsilondelta^TKE\n+ SDiS_textx-grad flux^TKE\n+ SDiS_textturb-transp^TKE\n+ SDiS_textdissip\n+ SDiS_textpress\n+ SDiS_textbuoyancy \nSDiS^phipsi =\n  SDiS_epsilondelta^phipsi\n+ SDiS_textx-grad flux^phipsi\n+ SDiS_textturb-transp^phipsi\n+ SDiS_textdissip^phipsi\n+ SDiS_textMP-MSS^phipsi\nquad phipsi in qtqt einteint eint qt\nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#Source-term-definitions-3","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Source term definitions","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nSDiS_epsilondelta^phipsi =\nbegincases\n  rhoRef a_i SDiw left -delta_i IntraCVSDiphipsi + epsilon_i\nleft(\nIntraCVSDephipsi + (SDephi - SDiphi)(SDepsi - SDipsi)\nright) right  i ne iEnv \n  0 - sum_jne iEnv SDjS_epsilondelta^phipsi  i=iEnv \nendcases \nSDiS_epsilondelta^TKE =\nbegincases\n  rhoRef a_i SDiw left -delta_i SDiTKE + epsilon_i\nleft(\nSDeTKE + frac12 (SDew - SDiw)^2\nright) right  i ne iEnv \n  0 - sum_jne iEnv SDjS_epsilondelta^TKE  i=iEnv \nendcases \nSDiS_textx-grad flux^phipsi\n =\n- rhoRef a_i IntraCVSDiwpsi PD_z SDiphi\n- rhoRef a_i IntraCVSDiwphi PD_z SDipsi \n =\n 2 rhoRef a_i SDiKh PD_z SDipsi PD_z SDiphi \nSDiS_textx-grad flux^TKE\n =\nrhoRef a_i SDiKm left left(PD_zDMuright)^2 + left(PD_zDMvright)^2 + left(PD_zDMwright)^2 right \nSDiS_textturb-transp^phipsi  = - PD_z (rhoRef a_i overlinew_iphi_ipsi_i) \n = PD_z (rhoRef a_i SDiKh PD_z IntraCVSDiphipsi) \nSDiS_textturb-transp^TKE  = PD_z (rhoRef a_i SDiKm PD_z SDiTKE) \nSDiS_textdissip\n = - rhoRef a_i c_e IntraCVSDiphipsi fracSDiTKE^12SDiol_mix quad textEquation 38 in Tan et al \nc_e  = 2 \nSDiS_textpress\n = - aSDia left IntraCVSDiu(partial_x p^dagger) +\n                      IntraCVSDiv(partial_y p^dagger) +\n                      IntraCVSDiw(partial_z p^dagger)right  \n = 0 qquad textfor now need to derive correct formulation \nSDiS_textbuoyancy^TKE  = rhoRef aSDia BuoyancyFlux \nSDiS_textMP-MSSP^qtqt\n = \nSDiS_textMP-MSSP^einteint\n = \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nEntrainment-Detrainment (epsilon_i) and (delta_i).\nEddy diffusivity (Km Kh).\nMixing length (l_mix).\nBuoyancy flux (BuoyancyFlux).","category":"page"},{"location":"Atmos/EDMFEquations.html#EDMF-variable-definitions-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"EDMF variable definitions","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"The following definitions are ordered in a dependency fashion; all variables are defined from variables already defined in previous subsections.","category":"page"},{"location":"Atmos/EDMFEquations.html#Constants-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Constants","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nc_K  = 01 \ntexttol_InversionHeightmathrm-stable  = 001 \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#Phase-partition-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Phase partition","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nPhasePartition = qv ql qi \nqv = qt - ql - qi \npvsat(T) = PTriple left( fracTTTriple right)^fracDeltaCpRv expfracRefLHv - DeltaCp TZeroRv left( frac1TTriple - frac1T right) labeleqpvsat \nqvsat(T rho) = fracpvsat(T)rho Rv T                                                                                                                            labeleqqvsat \nqc = max(qt - qvsat 0)                                                                                                                                               labeleqqc \nql = lambda qc                                                                                                                                                         labeleqql \nqi = (1-lambda) qc                                                                                                                                                     labeleqqi \nlambda(T) = Heaviside(T-TFreeze)                                                                                                                                       labeleqlambda \nHeaviside = textHeaviside function \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Functionally,","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nPhasePartition  = PhasePartition(qt T rho) \nqvsat  = qvsat(T rho) \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#Gas-constants-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Gas constants","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nEpsDV  = fracRvRd approx 161 \nEpsVD  = fracRdRv approx 062 \nRm  = Rd left1 + (EpsDV-1) qt - EpsDV (ql+qi) right \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#Specific-heats-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Specific heats","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nCvm = (1 - SDiqt) Cvd + SDiqv Cvv + SDiql Cvl + SDiqi Cvi \nCpm = (1 - SDiqt) Cpd + SDiqt Cpv \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#Latent-heat-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Latent heat","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nLatentHeatVT = RefLHv + (Cpv - Cpl) (T - TTriple) \nLatentHeatST = RefLHs + (Cpv - Cpi) (T - TTriple) \nLatentHeatFT = RefLHf + (Cpl - Cpi) (T - TTriple) \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#Exner-functions-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Exner functions","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nExnerD(pRef)    = left(fracpRefPTilde right)^RdCpd \nExnerM(pRef PhasePartition) = left(fracpRefPTilde right)^RmCpm \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Specific heats Cpm and Cvm.\nGas constants (Rm).\nPhase partition PhasePartition qt qv ql qi qvsat.","category":"page"},{"location":"Atmos/EDMFEquations.html#Temperature-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Temperature","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Note that, while temperature may be computed using different thermodynamic formulations, ThermodynamicState's are immediately converted to the (qt eint rhoRef)-formulation.","category":"page"},{"location":"Atmos/EDMFEquations.html#Dry-temperature-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Dry temperature","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nTDry  = ThetaLiqIce ExnerD \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Exner functions ExnerD and ExnerM.","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Functionally,","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nTDry  = TDry(ThetaLiqIce pRef) \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#(\\qt,-\\eint,-\\rhoRef{})-formulation-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"(qt eint rhoRef)-formulation","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Here, T conditionally satisfies the non-linear set of equations, which can be solved using a standard root solver (e.g., Secant method):","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nT =\nbegincases\nmathrmsatisfies  eint(T) = Cvm (T - TZero)  + qv RefHintV - qi RefHintI  qt  qvsat(T rhoRef) \n TZero + fraceint(T)(1-qt)Cvd + qt Cvv + qt RefHintV  textotherwise \nendcases\nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Phase partition PhasePartition qt qv ql qi qvsat.\nSpecific heats Cpm and Cvm.\nReference state profiles (pRef, rhoRef, and alphaRef).","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Functionally,","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nT  = T(qt eint rhoRef) \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#(\\qt,-\\ThetaLiqIce,-\\rhoRef,-\\pRef)-formulation-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"(qt ThetaLiqIce rhoRef pRef)-formulation","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Here, T conditionally satisfies the non-linear set of equations, which can be solved using a standard root solver (e.g., Secant method):","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nT =\nbegincases\nmathrmsatisfies  ThetaLiqIce ExnerM = T left(1 - frac RefLHv ql + RefLHs qiCpm T right)  qt  qvsat(T rhoRef) \n TDry  textotherwise \nendcases\nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Dry temperature TDry.\nPhase partition PhasePartition qt qv ql qi qvsat.\nSpecific heats Cpm and Cvm.\nExner functions ExnerD and ExnerM.","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Functionally,","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nT  = T(qt ThetaLiqIce rhoRef pRef) \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#Reference-state-profiles-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Reference state profiles","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Using the hydrostatic balance, PD_z pRef = - rhoRef grav, and the ideal gas law, pRef = rhoRef Rm TRef, the reference state profiles are computed as:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nPD_z pRef  = - grav fracpRefTRef Rm \nint_BCpRef^pRef fracTDry(BCDMThetaLiqIce pRef)pRef PD pRef  = - fracgravBCDMRm int_z_min^z PD z \nrhoRef(pRef)  = fracpRefTDry(BCDMThetaLiqIce pRef) BCDMRm \nalphaRef  = frac1rhoRef(pRef) \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Temperature (T and TDry).\nGas constants (Rm).\nSpecific heats Cpm and Cvm.","category":"page"},{"location":"Atmos/EDMFEquations.html#Mixing-ratios-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Mixing ratios","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqMixingRatios\nr_con  = fracqt+ql1 - qt \nr_vap  = fracqt-ql    - qi1 - qt \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#Potential-temperatures-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Potential temperatures","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Fix: which virtual potential temperature is used","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqTheta\nThetaDry     = TExnerD \nThetaLiqIce  = ThetaDry (1 - (RefLHv ql + RefLHs qi)(Cpm T)) \nThetaVirt    = ThetaDry (1 - r_con + 061 r_vap) \nThetaVirt    = theta left(1 + 061 qr - ql right) \nThetaRho     = T RmExnerD \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nExner functions (ExnerM).\nMixing ratios (r_con, r_vap).","category":"page"},{"location":"Atmos/EDMFEquations.html#Shear-production-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Shear production","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqShearProduction\nS^2 = (PD_z DMu)^2 + (PD_z DMv)^2 + (PD_z SDew)^2 \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#Buoyancy-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Buoyancy","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqBuoyancy\nSDib^dagger  = grav (SDialpha - alphaRef)alphaRef \nSDib  = SDib^dagger - sum_j a_j SDjb^dagger \nalpha_i  = fracSDiRm SDiTpRef \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nPhase partition PhasePartition qt qv ql qi qvsat.\nTemperature (T and TDry).","category":"page"},{"location":"Atmos/EDMFEquations.html#Buoyancy-gradient-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Buoyancy gradient","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#(\\qt,-\\ThetaLiqIce,-\\pRef,-\\rhoRef)-formulation-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"(qt ThetaLiqIce pRef rhoRef)-formulation","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqBuoyancyGradLong\nSDiBuoyancyGrad  = PD_z SDiThetaLiqIce\nleft (1-f_c) PD_ThetaLiqIce b _d  + f_c PD_ThetaLiqIce b _s right +\nPD_z SDiqt      left (1-f_c) PD_qt b _d + f_c PD_qt b _s right \nf_c = 0 qquad textgood for simple cases need to confirm for more complex cases \nPD_ThetaLiqIce b _d  = fracgravDMThetaVirt left 1 + left( fracRvRd - 1 right) SDiqt right \nPD_ThetaLiqIce b _s = fracgravDMThetaVirt left 1 + fracRvRd left(1 + fracLatentHeatVSDiTRv SDiT right) SDiqvsat - SDiqt right left( 1 + fracLatentHeatVSDiT^2Cpm Rv SDiT^2 SDiqvsat right)^-1 \nPD_qt b _d = fracgravDMThetaVirt left( fracRvRd - 1 right) SDiThetaDry \nPD_qt b _s = left( fracLatentHeatVSDiTCpm SDiT PD_ThetaLiqIce b _s - fracgravDMThetaVirt right) SDiThetaDry \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nPotential temperatures (ThetaDry, ThetaVirt).\nPhase partition PhasePartition qt qv ql qi qvsat.\nLatent heat (LatentHeatVT).","category":"page"},{"location":"Atmos/EDMFEquations.html#(\\qt,-\\eint,-\\rhoRef{})-formulation-2","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"(qt eint rhoRef)-formulation","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Pending.","category":"page"},{"location":"Atmos/EDMFEquations.html#Surface-fluxes-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Surface fluxes","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"todo: Todo\nAdd definitions for universal functions (e.g., Psi_m).","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Variables in this section must be computed simultaneously because it requires the solution of a non-linear equation.","category":"page"},{"location":"Atmos/EDMFEquations.html#Monin-Obhukov-length-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Monin-Obhukov length","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"NOTE: All variables (Monin-Obhukov length, friction velocity, temperature scale) in Surface fluxes must be solved simultaneously","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqMOLen\nMOLen = begincases\n- fracFrictionVelocity^3 thetaVKConst grav SurfaceHeatFlux  SurfaceHeatFlux  0 \n0  textotherwise \nendcases \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#Friction-velocity-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Friction velocity","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"NOTE: All variables (Monin-Obhukov length, friction velocity, temperature scale) in Surface fluxes must be solved simultaneously","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Knowns: u_mathrmave = sqrtDMu^2+DMv^2 LayerThickness SurfaceRoughnessm\nUnknowns: FrictionVelocity MOLen, and SurfaceMomentumFlux","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqFrictionVelocity\nu_mathrmave      = fracFrictionVelocityVKConst    left logleft(fracLayerThicknessSurfaceRoughnessmright) - Psi_mleft(fracLayerThicknessMOLenright) + fracSurfaceRoughnessmLayerThickness Psi_mleft(fracSurfaceRoughnessmMOLenright) + R_z0m left psi_mleft(fracSurfaceRoughnessmMOLenright) - 1 right right \nR_z0m               = 1 - SurfaceRoughnesshLayerThickness \nSurfaceMomentumFlux  = -FrictionVelocity^2                 labeleqSurfaceMomentumFlux  \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where Psi_m is defined in Appendix A, equations A6 in Nishizawa, S., and Y. Kitamura. \"A Surface Flux Scheme Based on the Monin‐Obukhov Similarity for Finite Volume Models.\" Journal of Advances in Modeling Earth Systems 10.12 (2018): 3159-3175.","category":"page"},{"location":"Atmos/EDMFEquations.html#Temperature-scale-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Temperature scale","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"NOTE: All variables (Monin-Obhukov length, friction velocity, temperature scale) in Surface fluxes must be solved simultaneously","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Knowns: theta_mathrmave theta_s LayerThickness SurfaceRoughnessh\nUnknowns: FrictionVelocity MOLen, and SurfaceHeatFlux","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqTemperatureScale\ntheta_mathrmave - theta_s  = fracPr TemperatureScaleVKConst left logleft(fracLayerThicknessSurfaceRoughnesshright) - Psi_hleft(fracLayerThicknessMOLenright) + fracSurfaceRoughnesshLayerThickness Psi_mleft(fracSurfaceRoughnesshMOLenright) + R_z0h left psi_hleft(fracSurfaceRoughnesshMOLenright) - 1 right right \nR_z0h                           = 1 - SurfaceRoughnesshLayerThickness \nSurfaceHeatFlux                  = -FrictionVelocityTemperatureScale  labeleqSurfaceHeatFlux  \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where Psi_h is defined in Appendix A, equation A6 in Nishizawa, S., and Y. Kitamura. \"A Surface Flux Scheme Based on the Monin‐Obukhov Similarity for Finite Volume Models.\" Journal of Advances in Modeling Earth Systems 10.12 (2018): 3159-3175.","category":"page"},{"location":"Atmos/EDMFEquations.html#Prandtl-number-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Prandtl number","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqPrandtlNumber\nPr_neut = 074 \nPr(z) = begincases\n    Pr_neut  MOLen  0 \n    Pr_neut left frac1 + omega_2 R_g - sqrt-4 R_g + (1+omega_2 R_g)^22 R_g right  textotherwise \nendcases \nomega_2 = omega_1+1 \nomega_1 = frac4013 \nR_g = fracBuoyancyGradS^2 \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Shear production (S).\nMonin-Obhukov length (MOLen).\nBuoyancy gradient (BuoyancyGrad).","category":"page"},{"location":"Atmos/EDMFEquations.html#Mixing-length-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Mixing length","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"note: Note\nThese mixing length have been tested for the environment, not the updrafts","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqMixingLength\nSDiol_mix^m = fracsum_j l_j e^-l_jsum_j e^-l_j qquad j = 123 \nl_1 = fracsqrtc_wSDeTKESDeN \nc_w = 04 \nSDeN = fracgrav PD_z SDeThetaVirtSDeThetaVirt  qquad text(buoyancy frequency of environment) \nl_2 = fracVKConst zc_K kappa^* phi_m(zMOLen) \nphi_m(xi) = left( 1 + a_l xi right)^-b_l \n(a_l b_l) =\nbegincases\n  (-100 02)  MOLen  0 \n  (27 -1)  textotherwise \nendcases \nkappa^* = fracFrictionVelocitysqrtSDeTKE \nl_3 = sqrtfracc_varepsilonc_K sqrtSDeTKE\nleft max(S^2 - frac1Pr(z) BuoyancyGrad 0) right^-12 \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Constants.\nShear production (S).\nMonin-Obhukov length (MOLen).\nFriction velocity (FrictionVelocity).\nBuoyancy gradient (BuoyancyGrad).\nPotential temperatures (ThetaDry, ThetaVirt).\nPrandtl number (Pr).","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Smoothing function is provided in python file. The Prandtl number was used from Eq. 75 in Dan Li 2019 \"Turbulent Prandtl number in the atmospheric BL - where are we now\".","category":"page"},{"location":"Atmos/EDMFEquations.html#Eddy-diffusivity-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy diffusivity","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqEddyDiffusivity\nSDiKm  = begincases\nc_K SDiol_mix sqrtSDiTKE  i = iEnv \n0  textotherwise\nendcases \nSDiKh  = fracSDiKmPr \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Constants.\nMixing length (l_mix).\nPrandtl number (Pr).","category":"page"},{"location":"Atmos/EDMFEquations.html#Buoyancy-flux-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Buoyancy flux","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"todo: Todo\nCurrently, BuoyancyFlux is hard-coded from the first expression (which was used in SCAMPy), however, this value should be computed from the SurfaceFluxes section.","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqBuoyancyFlux\nSurfaceBuoyancyFlux  = fracgrav BCalphaRefCpm BCSDiT (SensibleSurfaceHeatFlux + (EpsDV - 1) Cpm BCSDiT LatentSurfaceHeatFlux  LatentHeatVBCSDiT) \nBuoyancyFlux  = - SDiKh SDiBuoyancyGrad \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Eddy diffusivity (Km Kh).\nLatent heat (LatentHeatVT).\nBuoyancy gradient (BuoyancyGrad).\nSpecific heats Cpm and Cvm.","category":"page"},{"location":"Atmos/EDMFEquations.html#Entrainment-Detrainment-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Entrainment-Detrainment","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Entrainment (epsilon_i)","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqEntrainment\nepsilon_i = c_epsilon fracmax(SDib 0)SDiw^2 \nc_epsilon = 012 \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Detrainment (delta_j):","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqDetrainment\ndelta_i = c_delta fracmin(SDib 0)SDiw^2 + delta_B Heaviside(SDiql) \nc_delta = c_delta0 + Gamma(aSDia) \nGamma(aSDia) = 0 \nc_delta0 = c_epsilon = 012 \ndelta_B = 0004 m^-1 \nHeaviside = textHeaviside function \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nTemperature (T and TDry).\nBuoyancy (Buoyancy).","category":"page"},{"location":"Atmos/EDMFEquations.html#Inversion-height-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Inversion height","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqInversionHeight\nSDioInversionHeight =\nbegincases\n  left (PD_z ThetaRho)^-1 (BCThetaRho - ThetaRho_z_1) + z_1 right  simparamBCDMu^2 + simparamBCDMv^2 = texttol_InversionHeightmathrm-stable \n  left (PD_z Ri_bulk)^-1 (hyperparamRi_bulk crit - Ri_bulk_z_2) + z_2 right  textotherwise \nendcases \nz_1 = min_z (ThetaRho(z)  BCThetaRho) \nz_2 = min_z (Ri_bulk(z)  hyperparamRi_bulk crit) \nRi_bulk = grav z frac(ThetaRhoBCThetaRho - 1)simparamDMu^2 + simparamDMv^2 \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Potential temperatures (theta).","category":"page"},{"location":"Atmos/EDMFEquations.html#Convective-velocity-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Convective velocity","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqConvectiveVelocity\nSDioConvectiveVelocity = (max(BuoyancyFlux SDioInversionHeight 0))^13 \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Inversion height (SDioInversionHeight).\nBuoyancy flux (BuoyancyFlux).","category":"page"},{"location":"Atmos/EDMFEquations.html#Non-local-mixing-length-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Non-local mixing length","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqMixingLengthOld\nSDiol_mix = (l_A^-1 + l_B^-1)^-1 \nl_A = VKConst z left( 1 + a_l fraczMOLen right)^b_l \nSDiol_B = SDiotau SDiTKE \n(a_l b_l) =\nbegincases\n  (-100 02)  MOLen  0 \n  (27 -1)  textotherwise \nendcases \nSDiotau = SDioInversionHeightSDioConvectiveVelocity \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Inversion height (SDioInversionHeight).\nMonin-Obhukov length (MOLen).\nConvective velocity (SDioConvectiveVelocity).","category":"page"},{"location":"Atmos/EDMFEquations.html#Boundary-Conditions-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Boundary Conditions","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Here, we specify boundary conditions (BCs) by their type, Dirichlet (D) or Neumann (N), and their value.","category":"page"},{"location":"Atmos/EDMFEquations.html#BC-functions-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"BC functions","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nGamma_phi(F_1 F_2)\n = begincases\n    4 fracF_1 F_2FrictionVelocity^2 (1 - 83zLLMOLen)^-23  MOLen  0 \n    4 fracF_1 F_2FrictionVelocity^2  textotherwise\nendcases \nGamma_TKE\n = begincases\n    375 FrictionVelocity^2 + 02 ConvectiveVelocity^2 + FrictionVelocity^2 (-zLLMOLen)^23  MOLen  0 \n    375 FrictionVelocity^2  textotherwise\nendcases \nSensibleSurfaceHeatFlux  = BCTCVweint Cpm rhoRef \nLatentSurfaceHeatFlux    = BCTCVwqt  LatentHeatVT rhoRef \nF_eint(SensibleSurfaceHeatFlux)   = fracSensibleSurfaceHeatFluxCpm       = BCTCVweint rhoRef \nF_qt(LatentSurfaceHeatFlux)       = fracLatentSurfaceHeatFluxLatentHeatVT = BCTCVwqt   rhoRef \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nMonin-Obhukov length (MOLen).\nConvective velocity (SDioConvectiveVelocity).\nFriction velocity (FrictionVelocity).\nLatent heat (LatentHeatVT).","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"and equation \\eqref{eq:TopPercentile} represents the mean of the top x-fraction of a standard normal distribution (Neggers et al., 2009).","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nPhi^-1(x)  = textinverse cumulative distribution function labeleqInverseCDF \nmathcal D(x) = frac1sqrt2pi x exp- frac12 (Phi^-1(1-x))^2   labeleqTopPercentile \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#Area-fraction-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Area fraction","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nc_frac = 01 quad\nBCBaSDia =\nbegincases\n    1-c_frac  i = iEnv \n  fracc_fracNsd  i ne iEnv\nendcases quad\nBCTaSDia =\nbegincases\n    1-c_frac  i = iEnv \n  fracc_fracNsd  i ne iEnv\nendcases\nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#st-order-moments-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"1st order moments","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Top boundary","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nBCTSDiw           = 0 \nPD_z BCTSDiqt   = 0 \nPD_z BCTSDieint = 0 \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Bottom boundary","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"todo: Todo\nNeed value for C_eint.","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nBCBSDiw     = 0 \n- SDiKh PD_z BCBSDiqt   = TCVwqt   + mathcal D(aSDia) sqrtC_qt^2   WindSpeed^2Gamma_phi(TCVwqt   TCVwqt   ) \n- SDiKh PD_z BCBSDieint = TCVweint + mathcal D(aSDia) sqrtC_eint^2 WindSpeed^2Gamma_phi(TCVweint TCVweint ) \nC_qt = 0001133 \nC_ThetaLiqIce = 0001094 \nC_eint =  \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable/function definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"BC functions mathcal D.","category":"page"},{"location":"Atmos/EDMFEquations.html#nd-order-moments-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"2nd order moments","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Top boundary","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nBCTSDiTKE                          = 0 \nPD_z BCTIntraCVSDiqtqt        = 0 \nPD_z BCTIntraCVSDieinteint    = 0 \nPD_z BCTIntraCVSDieintqt      = 0 \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"todo: Todo\nCurrently, we only account for the intra sub-domain covariance, but we would like to also account for the inter sub-domain covariance for all but the TKE.","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Bottom boundary","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nBCBSDiTKE                    = Gamma_TKE \nBCBIntraCVSDiqtqt        = Gamma_phi(TCVwqt   TCVwqt   ) \nBCBIntraCVSDieinteint    = Gamma_phi(TCVwqt   TCVweint ) \nBCBIntraCVSDieintqt      = Gamma_phi(TCVweint TCVweint ) \nendalign","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable/function definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"BC functions Gamma_TKE, Gamma_phi, F_eint, SensibleSurfaceHeatFlux, F_qt, LatentSurfaceHeatFlux.","category":"page"},{"location":"Atmos/EDMFEquations.html#Case-specific-configurations-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Case-specific configurations","text":"","category":"section"},{"location":"Atmos/EDMFEquations.html#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Case Variable Value Reference\nBomex BCp_s 1000 [hPa] \nBomex BCDMqt 5 [g/kg] \nBomex BCDMThetaLiqIce 300 [K] \nBomex BCTCVwqt 52 times 10^-5 m s^-1 \nBomex BCTCVwThetaLiqIce 8 times 10^-3 K m s^-1 \nSoares BCTCVwqt 25 times 10^-5 m s^-1 \nSoares BCTCVwThetaLiqIce 6 times 10^-2 K m s^-1 \n   ","category":"page"},{"location":"BalanceLawOverview.html#DG-Balance-Law-Method-1","page":"DG Balance Law Method","title":"DG Balance Law Method","text":"","category":"section"},{"location":"BalanceLawOverview.html#Continuous-Balance-Law-Formulation-1","page":"DG Balance Law Method","title":"Continuous Balance Law Formulation","text":"","category":"section"},{"location":"BalanceLawOverview.html#","page":"DG Balance Law Method","title":"DG Balance Law Method","text":"to be filled","category":"page"},{"location":"BalanceLawOverview.html#Discontinuous-Galerkin-Method-Formulation-1","page":"DG Balance Law Method","title":"Discontinuous Galerkin Method Formulation","text":"","category":"section"},{"location":"BalanceLawOverview.html#","page":"DG Balance Law Method","title":"DG Balance Law Method","text":"to be filled","category":"page"},{"location":"BalanceLawOverview.html#Examples-1","page":"DG Balance Law Method","title":"Examples","text":"","category":"section"},{"location":"BalanceLawOverview.html#","page":"DG Balance Law Method","title":"DG Balance Law Method","text":"attribution: Attribution\nThe style of examples we use here is heavily inspired by JuAFEM.jl","category":"page"},{"location":"BalanceLawOverview.html#","page":"DG Balance Law Method","title":"DG Balance Law Method","text":"to be filled","category":"page"},{"location":"InputOutput.html#InputOutput-1","page":"InputOutput","title":"InputOutput","text":"","category":"section"},{"location":"InputOutput.html#","page":"InputOutput","title":"InputOutput","text":"CurrentModule = CLIMA","category":"page"},{"location":"InputOutput.html#VTK-1","page":"InputOutput","title":"VTK","text":"","category":"section"},{"location":"InputOutput.html#Functions-1","page":"InputOutput","title":"Functions","text":"","category":"section"},{"location":"InputOutput.html#","page":"InputOutput","title":"InputOutput","text":"VTK.writevtk\nVTK.writevtk_helper","category":"page"},{"location":"InputOutput.html#CLIMA.VTK.writevtk","page":"InputOutput","title":"CLIMA.VTK.writevtk","text":"writevtk(prefix, Q::MPIStateArray, disc::DGBalanceLaw [, fieldnames])\n\nWrite a vtk file for all the fields in the state array Q using geometry and connectivity information from disc.grid. The filename will start with prefix which may also contain a directory path. The names used for each of the fields in the vtk file can be specified through the collection of strings fieldnames; if not specified the fields names will be \"Q1\" through \"Qk\" where k is the number of states in Q, i.e., k = size(Q,2).\n\n\n\n\n\nwritevtk(prefix, Q::MPIStateArray, disc::DGBalanceLaw, fieldnames,\n         auxstate::MPIStateArray, auxfieldnames)\n\nWrite a vtk file for all the fields in the state array Q and auxiliary state auxstate using geometry and connectivity information from disc.grid. The filename will start with prefix which may also contain a directory path. The names used for each of the fields in the vtk file can be specified through the collection of strings fieldnames and auxfieldnames.\n\nIf fieldnames === nothing then the fields names will be \"Q1\" through \"Qk\" where k is the number of states in Q, i.e., k = size(Q,2).\n\nIf auxfieldnames === nothing then the fields names will be \"aux1\" through \"auxk\" where k is the number of states in auxstate, i.e., k = size(auxstate,2).\n\n\n\n\n\n","category":"function"},{"location":"InputOutput.html#CLIMA.VTK.writevtk_helper","page":"InputOutput","title":"CLIMA.VTK.writevtk_helper","text":"writevtk_helper(prefix, vgeo::Array, Q::Array, grid, fieldnames)\n\nInternal helper function for writevtk\n\n\n\n\n\n","category":"function"},{"location":"AcceptableUnicode.html#Acceptable-Unicode-characters-1","page":"Acceptable Unicode characters","title":"Acceptable Unicode characters","text":"","category":"section"},{"location":"AcceptableUnicode.html#","page":"Acceptable Unicode characters","title":"Acceptable Unicode characters","text":"Using Unicode seems to be irresistible. However, we must ensure avoiding problematic Unicode usage.","category":"page"},{"location":"AcceptableUnicode.html#","page":"Acceptable Unicode characters","title":"Acceptable Unicode characters","text":"Below is a list of acceptable Unicode characters. All characters not listed below are forbidden. We forbid the use of accents (dot, hat, vec, etc.), because this can lead to visually ambiguous characters.","category":"page"},{"location":"AcceptableUnicode.html#Acceptable-lower-case-Greek-letters-1","page":"Acceptable Unicode characters","title":"Acceptable lower-case Greek letters","text":"","category":"section"},{"location":"AcceptableUnicode.html#","page":"Acceptable Unicode characters","title":"Acceptable Unicode characters","text":"α # (alpha)\nβ # (beta)\nδ # (delta)\nϵ # (epsilon)\nε # (varepsilon)\nγ # (gamma)\nκ # (kappa)\nλ # (lambda)\nμ # (mu)\nν # (nu)\nη # (eta)\nω # (omega)\nπ # (pi)\nρ # (rho)\nσ # (sigma)\nθ # (theta)\nχ # (chi)\nξ # (xi)\nζ # (zeta)\nϕ # (psi)\nφ # (varphi)","category":"page"},{"location":"AcceptableUnicode.html#Acceptable-upper-case-Greek-letters-1","page":"Acceptable Unicode characters","title":"Acceptable upper-case Greek letters","text":"","category":"section"},{"location":"AcceptableUnicode.html#","page":"Acceptable Unicode characters","title":"Acceptable Unicode characters","text":"Δ # (Delta)\n∑ # (Sigma)\nΓ # (Gamma)\nΩ # (Omega)\nΨ # (Psi)\n<!-- Φ # (Phi) removed in favor of lowercase psi -->","category":"page"},{"location":"AcceptableUnicode.html#Acceptable-mathematical-symbols-1","page":"Acceptable Unicode characters","title":"Acceptable mathematical symbols","text":"","category":"section"},{"location":"AcceptableUnicode.html#","page":"Acceptable Unicode characters","title":"Acceptable Unicode characters","text":"∫ # (int)\n∬ # (iint)\n∭ # (iiint)\n∞ # (infinity)\n≈ # (approx)\n∂ # (partial)\n∇ # (nabla/del), note that nabla and del are indistinguishable\n∀ # (forall)\n≥ # (greater than equal to)\n≤ # (less than equal to)\n<!-- ∈ # (in) removed in favor of epsilon -->","category":"page"},{"location":"ODESolvers.html#ODESolvers-1","page":"ODESolvers","title":"ODESolvers","text":"","category":"section"},{"location":"ODESolvers.html#","page":"ODESolvers","title":"ODESolvers","text":"CurrentModule = CLIMA","category":"page"},{"location":"ODESolvers.html#LowStorageRungeKutta-1","page":"ODESolvers","title":"LowStorageRungeKutta","text":"","category":"section"},{"location":"ODESolvers.html#","page":"ODESolvers","title":"ODESolvers","text":"LowStorageRungeKuttaMethod.LowStorageRungeKutta2N\nLowStorageRungeKuttaMethod.LSRK54CarpenterKennedy\nLowStorageRungeKuttaMethod.LSRK144NiegemannDiehlBusch","category":"page"},{"location":"ODESolvers.html#CLIMA.LowStorageRungeKuttaMethod.LowStorageRungeKutta2N","page":"ODESolvers","title":"CLIMA.LowStorageRungeKuttaMethod.LowStorageRungeKutta2N","text":"LowStorageRungeKutta2N(f, RKA, RKB, RKC, Q; dt, t0 = 0)\n\nThis is a time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ = f(Q t)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThe constructor builds a low-storage Runge-Kutta scheme using 2N storage based on the provided RKA, RKB and RKC coefficient arrays.\n\nThe available concrete implementations are:\n\nLSRK54CarpenterKennedy\nLSRK144NiegemannDiehlBusch\n\n\n\n\n\n","category":"type"},{"location":"ODESolvers.html#CLIMA.LowStorageRungeKuttaMethod.LSRK54CarpenterKennedy","page":"ODESolvers","title":"CLIMA.LowStorageRungeKuttaMethod.LSRK54CarpenterKennedy","text":"LSRK54CarpenterKennedy(f, Q; dt, t0 = 0)\n\nThis function returns a LowStorageRungeKutta2N time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ = f(Q t)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThis uses the fourth-order, low-storage, Runge–Kutta scheme of Carpenter and Kennedy (1994) (in their notation (5,4) 2N-Storage RK scheme).\n\nReferences\n\n@TECHREPORT{CarpenterKennedy1994,\n  author = {M.~H. Carpenter and C.~A. Kennedy},\n  title = {Fourth-order {2N-storage} {Runge-Kutta} schemes},\n  institution = {National Aeronautics and Space Administration},\n  year = {1994},\n  number = {NASA TM-109112},\n  address = {Langley Research Center, Hampton, VA},\n}\n\n\n\n\n\n","category":"function"},{"location":"ODESolvers.html#CLIMA.LowStorageRungeKuttaMethod.LSRK144NiegemannDiehlBusch","page":"ODESolvers","title":"CLIMA.LowStorageRungeKuttaMethod.LSRK144NiegemannDiehlBusch","text":"LSRK144NiegemannDiehlBusch((f, Q; dt, t0 = 0)\n\nThis function returns a LowStorageRungeKutta2N time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ = f(Q t)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThis uses the fourth-order, 14-stage, low-storage, Runge–Kutta scheme of Niegemann, Diehl, and Busch (2012) with optimized stability region\n\nReferences\n\n@article{niegemann2012efficient,\n  title={Efficient low-storage Runge--Kutta schemes with optimized stability regions},\n  author={Niegemann, Jens and Diehl, Richard and Busch, Kurt},\n  journal={Journal of Computational Physics},\n  volume={231},\n  number={2},\n  pages={364--372},\n  year={2012},\n  publisher={Elsevier}\n}\n\n\n\n\n\n","category":"function"},{"location":"ODESolvers.html#StrongStabilityPreservingRungeKutta-1","page":"ODESolvers","title":"StrongStabilityPreservingRungeKutta","text":"","category":"section"},{"location":"ODESolvers.html#","page":"ODESolvers","title":"ODESolvers","text":"StrongStabilityPreservingRungeKuttaMethod.StrongStabilityPreservingRungeKutta\nStrongStabilityPreservingRungeKuttaMethod.SSPRK33ShuOsher\nStrongStabilityPreservingRungeKuttaMethod.SSPRK34SpiteriRuuth","category":"page"},{"location":"ODESolvers.html#CLIMA.StrongStabilityPreservingRungeKuttaMethod.StrongStabilityPreservingRungeKutta","page":"ODESolvers","title":"CLIMA.StrongStabilityPreservingRungeKuttaMethod.StrongStabilityPreservingRungeKutta","text":"StrongStabilityPreservingRungeKutta(f, RKA, RKB, RKC, Q; dt, t0 = 0)\n\nThis is a time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ = f(Q t)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThe constructor builds a strong-stability-preserving Runge–Kutta scheme based on the provided RKA, RKB and RKC coefficient arrays.\n\nThe available concrete implementations are:\n\nSSPRK33ShuOsher  \nSSPRK34SpiteriRuuth  \n\n\n\n\n\n","category":"type"},{"location":"ODESolvers.html#CLIMA.StrongStabilityPreservingRungeKuttaMethod.SSPRK33ShuOsher","page":"ODESolvers","title":"CLIMA.StrongStabilityPreservingRungeKuttaMethod.SSPRK33ShuOsher","text":"SSPRK33ShuOsher(f, Q; dt, t0 = 0)\n\nThis function returns a StrongStabilityPreservingRungeKutta time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ = f(Q t)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThis uses the third-order, 3-stage, strong-stability-preserving, Runge–Kutta scheme of Shu and Osher (1988)\n\nReferences\n\n@article{shu1988efficient,\n  title={Efficient implementation of essentially non-oscillatory shock-capturing schemes},\n  author={Shu, Chi-Wang and Osher, Stanley},\n  journal={Journal of computational physics},\n  volume={77},\n  number={2},\n  pages={439--471},\n  year={1988},\n  publisher={Elsevier}\n}\n\n\n\n\n\n","category":"function"},{"location":"ODESolvers.html#CLIMA.StrongStabilityPreservingRungeKuttaMethod.SSPRK34SpiteriRuuth","page":"ODESolvers","title":"CLIMA.StrongStabilityPreservingRungeKuttaMethod.SSPRK34SpiteriRuuth","text":"SSPRK34SpiteriRuuth(f, Q; dt, t0 = 0)\n\nThis function returns a StrongStabilityPreservingRungeKutta time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ = f(Q t)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThis uses the third-order, 4-stage, strong-stability-preserving, Runge–Kutta scheme of Spiteri and Ruuth (1988)\n\nReferences\n\n@article{spiteri2002new,\n  title={A new class of optimal high-order strong-stability-preserving time discretization methods},\n  author={Spiteri, Raymond J and Ruuth, Steven J},\n  journal={SIAM Journal on Numerical Analysis},\n  volume={40},\n  number={2},\n  pages={469--491},\n  year={2002},\n  publisher={SIAM}\n}\n\n\n\n\n\n","category":"function"},{"location":"ODESolvers.html#AdditiveRungeKutta-1","page":"ODESolvers","title":"AdditiveRungeKutta","text":"","category":"section"},{"location":"ODESolvers.html#","page":"ODESolvers","title":"ODESolvers","text":"AdditiveRungeKuttaMethod.AdditiveRungeKutta \nAdditiveRungeKuttaMethod.ARK2GiraldoKellyConstantinescu\nAdditiveRungeKuttaMethod.ARK548L2SA2KennedyCarpenter ","category":"page"},{"location":"ODESolvers.html#CLIMA.AdditiveRungeKuttaMethod.AdditiveRungeKutta","page":"ODESolvers","title":"CLIMA.AdditiveRungeKuttaMethod.AdditiveRungeKutta","text":"AdditiveRungeKutta(f, l, linsol, RKAe, RKAi, RKB, RKC, Q; dt, t0 = 0)\n\nThis is a time stepping object for implicit-explicit time stepping of the decomposed differential equation given by the chosen linear operator l, the full right-hand-side function f and the state Q, i.e.,\n\n  dotQ = l(Q t) + f(Q t) - l(Q t)\n\nwith the required time step size dt and optional initial time t0. The linear operator l is integrated implicitly whereas the remaining part f - l is integrated explicitly. This time stepping object is intended to be passed to the solve! command.\n\nThe constructor builds an additive Runge–Kutta scheme  based on the provided RKAe, RKAi, RKB and RKC coefficient arrays. The resulting linear systems are solved using the provided linsol function.\n\nThe available concrete implementations are:\n\nARK2GiraldoKellyConstantinescu\nARK548L2SA2KennedyCarpenter\n\n\n\n\n\n","category":"type"},{"location":"ODESolvers.html#CLIMA.AdditiveRungeKuttaMethod.ARK2GiraldoKellyConstantinescu","page":"ODESolvers","title":"CLIMA.AdditiveRungeKuttaMethod.ARK2GiraldoKellyConstantinescu","text":"ARK2GiraldoKellyConstantinescu(f, l, linsol, Q; dt, t0 = 0)\n\nThis function returns an AdditiveRungeKutta  time stepping object for implicit-explicit time stepping of the decomposed differential equation given by the chosen linear operator l, the full right-hand-side function f and the state Q, i.e.,\n\n  dotQ = l(Q t) + f(Q t) - l(Q t)\n\nwith the required time step size dt and optional initial time t0. The linear operator l is integrated implicitly whereas the remaining part f - l is integrated explicitly. This time stepping object is intended to be passed to the solve! command.\n\nThe resulting linear systems are solved using the provided linsol function.\n\nThis uses the second-order-accurate 3-stage additive Runge–Kutta scheme of Giraldo, Kelly and Constantinescu (2013).\n\nReferences\n\n@article{giraldo2013implicit,\n  title={Implicit-explicit formulations of a three-dimensional nonhydrostatic unified model of the atmosphere ({NUMA})},\n  author={Giraldo, Francis X and Kelly, James F and Constantinescu, Emil M},\n  journal={SIAM Journal on Scientific Computing},\n  volume={35},\n  number={5},\n  pages={B1162--B1194},\n  year={2013},\n  publisher={SIAM}\n}\n\n\n\n\n\n","category":"function"},{"location":"ODESolvers.html#CLIMA.AdditiveRungeKuttaMethod.ARK548L2SA2KennedyCarpenter","page":"ODESolvers","title":"CLIMA.AdditiveRungeKuttaMethod.ARK548L2SA2KennedyCarpenter","text":"ARK548L2SA2KennedyCarpenter(f, l, linsol, Q; dt, t0 = 0)\n\nThis function returns an AdditiveRungeKutta  time stepping object for implicit-explicit time stepping of the decomposed differential equation given by the chosen linear operator l, the full right-hand-side function f and the state Q, i.e.,\n\n  dotQ = l(Q t) + f(Q t) - l(Q t)\n\nwith the required time step size dt and optional initial time t0. The linear operator l is integrated implicitly whereas the remaining part f - l is integrated explicitly. This time stepping object is intended to be passed to the solve! command.\n\nThe resulting linear systems are solved using the provided linsol function.\n\nThis uses the fifth-order-accurate 8-stage additive Runge–Kutta scheme of Kennedy and Carpenter (2013).\n\nReferences\n\n@article{kennedy2019higher,\n  title={Higher-order additive Runge--Kutta schemes for ordinary differential equations},\n  author={Kennedy, Christopher A and Carpenter, Mark H},\n  journal={Applied Numerical Mathematics},\n  volume={136},\n  pages={183--205},\n  year={2019},\n  publisher={Elsevier}\n}\n\n\n\n\n\n","category":"function"},{"location":"ODESolvers.html#GenericCallbacks-1","page":"ODESolvers","title":"GenericCallbacks","text":"","category":"section"},{"location":"ODESolvers.html#","page":"ODESolvers","title":"ODESolvers","text":"GenericCallbacks.EveryXWallTimeSeconds\nGenericCallbacks.EveryXSimulationSteps","category":"page"},{"location":"ODESolvers.html#CLIMA.GenericCallbacks.EveryXWallTimeSeconds","page":"ODESolvers","title":"CLIMA.GenericCallbacks.EveryXWallTimeSeconds","text":"EveryXWallTimeSeconds(f, time, mpicomm)\n\nThis callback will run the function 'f()' every time wallclock time seconds. The mpicomm is used to syncronize runtime across MPI ranks.\n\n\n\n\n\n","category":"type"},{"location":"ODESolvers.html#CLIMA.GenericCallbacks.EveryXSimulationSteps","page":"ODESolvers","title":"CLIMA.GenericCallbacks.EveryXSimulationSteps","text":"EveryXSimulationSteps(f, steps)\n\nThis callback will run the function 'f()' every steps of the time stepper\n\n\n\n\n\n","category":"type"},{"location":"ODESolvers.html#ODESolvers-2","page":"ODESolvers","title":"ODESolvers","text":"","category":"section"},{"location":"ODESolvers.html#","page":"ODESolvers","title":"ODESolvers","text":"ODESolvers.solve!\nODESolvers.gettime\nODESolvers.updatedt!","category":"page"},{"location":"ODESolvers.html#CLIMA.ODESolvers.solve!","page":"ODESolvers","title":"CLIMA.ODESolvers.solve!","text":"solve!(Q, solver::AbstractODESolver; timeend,\n       stopaftertimeend=true, numberofsteps, callbacks)\n\nSolves an ODE using the solver starting from a state Q. The state Q is updated inplace. The final time timeend or numberofsteps must be specified.\n\nA series of optional callback functions can be specified using the tuple callbacks; see GenericCallbacks.\n\n\n\n\n\n","category":"function"},{"location":"ODESolvers.html#CLIMA.ODESolvers.gettime","page":"ODESolvers","title":"CLIMA.ODESolvers.gettime","text":"gettime(solver::AbstractODESolver)\n\nReturns the current simulation time of the ODE solver solver\n\n\n\n\n\n","category":"function"},{"location":"ODESolvers.html#CLIMA.ODESolvers.updatedt!","page":"ODESolvers","title":"CLIMA.ODESolvers.updatedt!","text":"updatedt!(solver::AbstractODESolver, dt)\n\nChange the time step size to dt for the ODE solver solver.\n\n\n\n\n\n","category":"function"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"EditURL = \"https://github.com/climate-machine/CLIMA/blob/master/examples/DGmethods_old/ex_002_solid_body_rotation.jl\"","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#Example-002:-Solid-Body-Rotation-1","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"jupyter: Jupyter\nThis example is also available as a Jupyter notebook: ex_002_solid_body_rotation.ipynb","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"Key ideas of this tutorial:","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"Setting up auxiliary state variables\nDefining the boundary condition treatment","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#Introduction-1","page":"Example 002: Solid Body Rotation","title":"Introduction","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"In this example we will solve the variable coefficient advection equation. The velocity field used is solid body rotation where the domain is the square or domain Omega = -1 1^d where d=2 or 3.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"The partial differential equation we wish to solve is","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"fracpartial qpartial t + nabla cdot (vecu q) = 0","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"where q is the advected field and the velocity field is vecu = 2pi r (-sin(theta) cos(theta) 0)^T with r = sqrtx^2 + y^2 and theta = arctan(y  x).","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"The quantity vecu q is more generally called the flux and denoted in the tutorial below as boldsymbolF(q) = vecu q.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"Below is a program interspersed with comments. The full program, without comments, can be found in the next section.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#Commented-Program-1","page":"Example 002: Solid Body Rotation","title":"Commented Program","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#Preliminaries-1","page":"Example 002: Solid Body Rotation","title":"Preliminaries","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"Load in modules needed for solving the problem","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"using MPI\nusing CLIMA.Mesh.Topologies\nusing CLIMA.Mesh.Grids\nusing CLIMA.DGBalanceLawDiscretizations\nusing CLIMA.MPIStateArrays\nusing CLIMA.LowStorageRungeKuttaMethod\nusing CLIMA.ODESolvers\nusing CLIMA.GenericCallbacks\nusing CLIMA.VTK\nusing LinearAlgebra\nusing Logging\nusing Dates\nusing Printf\nusing StaticArrays","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"Start up MPI if this has not already been done","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"MPI.Initialized() || MPI.Init()\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#Initializing-the-Velocity-Field-1","page":"Example 002: Solid Body Rotation","title":"Initializing the Velocity Field","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"The key difference between this example and example 001 is that in this case we have a non-constant velocity field. In the balance law solver, in addition to the PDE state at every degree of freedom we can also define a constant in time auxiliary state, and it is in this auxiliary state that we will store the velocity field.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"Initialization of the auxiliary state can happen in several ways, but here we will use the default DGBalanceLaw initialization interface which requires the user-defined function which given x, y, and z defines the auxiliary state","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"const num_aux_states = 3\nfunction velocity_initilization!(uvec::MVector{num_aux_states, FT},\n                                 x, y, z) where FT\n  @inbounds begin\n    r = hypot(x, y)\n    θ = atan(y, x)\n    uvec .= 2FT(π) * r .* (-sin(θ), cos(θ), 0)\n  end\nend\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"Note: We have caught the type of the elements in order the properly cast pi since 2pi would be default be a Float64.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"Remark: Though not needed for this problem, if the user wishes to have access to the coordinate points during the simulation these should be stored in the auxiliary state which would increase the size of the auxiliary state.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#Physical-Flux-1","page":"Example 002: Solid Body Rotation","title":"Physical Flux","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"Now we define a function which given a value for q computes the physical flux boldsymbolF = vecu q. The balance law solver will will pass user-defined auxiliary state at a degree of freedom through to the flux function as the fourth argument; the third and fifth arguments which are not needed for this example is the viscous state and simulation time).","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"function advectionflux!(F, state, _, uvec, _)\n  FT = eltype(state) # get the floating point type we are using\n  @inbounds begin\n    q = state[1]\n    F[:, 1] = uvec * q\n  end\nend\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#Numerical-Flux-1","page":"Example 002: Solid Body Rotation","title":"Numerical Flux","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"As in example 001 we will use an upwind numerical flux; more discussion of this can be seen in the numerical flux section of example 001.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"The auxiliary state for the minus and plus sides of the interface will be passed in through arguments 4 and 6 of the numerical flux callback. Since the two sides of the interface are collocated the auxiliary state on the two sides should be the same.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"function upwindflux!(fs, nM, stateM, viscM, uvecM, stateP, viscP, uvecP, t)\n  FT = eltype(fs)\n  @inbounds begin\n    # determine the advection speed and direction\n    un = dot(nM, uvecM)\n    qM = stateM[1]\n    qP = stateP[1]\n    # Determine which state is \"upwind\" of the minus side\n    fs[1] = un ≥ 0 ? un * qM : un * qP\n  end\nend","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#Boundary-Numerical-Flux-1","page":"Example 002: Solid Body Rotation","title":"Boundary Numerical Flux","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"Since we will not assume that the domain is periodic, we also need to define a boundary numerical flux which will be used to define the boundary conditions. Generally speaking, boundary conditions for purely hyperbolic problems should be imposed by relating incoming characteristic variables to outgoing characteristics. In this case we will use characteristic outflow boundary conditions and zero inflow boundary conditions.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"The syntax of the boundary flux is almost the same as the numerical flux except that the boundary condition type is passed into the function, though in this case we can neglect the value of the boundary condition flag. In the case of boundary conditions the plus state is set to the minus side state; this is done since in the case of model coupling this could be set to some values derived from the neighbouring model.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"In the case of advection with the outflow boundary condition and zero inflow, the boundary numerical flux is the same as the upwind flux except with q^+ set to zero; more complicated PDES and boundary conditions would require more complex constructions.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"function upwindboundaryflux!(fs, nM, stateM, viscM, uvecM, stateP, viscP, uvecP,\n                             bctype, t)\n  FT = eltype(fs)\n  @inbounds begin\n    # determine the advection speed and direction\n    un = dot(nM, uvecM)\n    qM = stateM[1]\n    # Determine which state is \"upwind\" of the minus side\n    fs[1] = un ≥ 0 ? un * qM : 0\n  end\nend\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#Initial-Condition-1","page":"Example 002: Solid Body Rotation","title":"Initial Condition","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"In this example we take the initial condition to be","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"q(vecx t=0) =\nexpleft(-left(8leftvecx-frac12vece_1right_2right)^2right)","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"where vece_1 = (1 0 0)^T.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"Note: The initial condition will always be called as though the dimensionality of the problem is 3. For the domain used below z = 0 when the problem is actually two-dimensional and thus the hypot call before is not effected by z","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"Note: When the balance law solver calls the initial condition function the auxiliary state, in this case the velocity field, will also be included since the number of auxiliary variables is greater than zero.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"function initialcondition!(Q, x, y, z, _)\n  @inbounds Q[1] = exp(-(8 * hypot(x - 1//2, y, z))^2)\nend\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#Exact-Solution-1","page":"Example 002: Solid Body Rotation","title":"Exact Solution","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"For solid body rotation the exact solution is computed by tracing back the rotation to the initial state.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"Note: uvec is included to match calling convention of initialcondition!","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"function exactsolution!(Q, t, x, y, z, uvec)\n  @inbounds begin\n    FT = eltype(Q)\n\n    r = hypot(x, y)\n    θ = atan(y, x) - 2FT(π) * t\n\n    x, y = r * cos(θ), r * sin(θ)\n\n    initialcondition!(Q, x, y, z, uvec)\n  end\nend\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#Initialize-the-DG-Method-1","page":"Example 002: Solid Body Rotation","title":"Initialize the DG Method","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"The initialization of the DG method is largely the same as the intialization discussion of ex 001.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"function setupDG(mpicomm, dim, Ne, polynomialorder, FT=Float64,\n                 ArrayType=Array)\n\n  @assert ArrayType === Array\n\n  brickrange = (range(FT(-1); length=Ne+1, stop=1),\n                range(FT(-1); length=Ne+1, stop=1),\n                range(FT(-1); length=Ne+1, stop=1))","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"By default the BrickTopology is not periodic, so unlike ex 001, we do not need to specify the periodicity","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"  topology = BrickTopology(mpicomm, brickrange[1:dim])\n\n  grid = DiscontinuousSpectralElementGrid(topology; polynomialorder =\n                                          polynomialorder, FloatType = FT,\n                                          DeviceArray = ArrayType,)","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"Note the additional keyword arguments: numerical_boundary_flux! which is used to pass the numerical flux function that implements the boundary condition, auxiliary_state_length which defines the number of auxiliary state fields at each degree of freedom, and auxiliary_state_initialization! which initializes the auxiliary state.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"  spatialdiscretization = DGBalanceLaw(grid = grid, length_state_vector = 1,\n                                       flux! = advectionflux!,\n                                       numerical_flux! = upwindflux!,\n                                       numerical_boundary_flux! =\n                                       upwindboundaryflux!,\n                                       auxiliary_state_length = num_aux_states,\n                                       auxiliary_state_initialization! =\n                                       velocity_initilization!)\n\nend\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#Initializing-and-run-the-DG-method-1","page":"Example 002: Solid Body Rotation","title":"Initializing and run the DG method","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"This let statement is largely the same as the Using ODE solver callback functions block from ex 001. Difference are highlighted.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"let\n  mpicomm = MPI.COMM_WORLD\n  mpi_logger = ConsoleLogger(MPI.Comm_rank(mpicomm) == 0 ? stderr : devnull)\n  dim = 2\n  Ne = 20\n  polynomialorder = 4\n  spatialdiscretization = setupDG(mpicomm, dim, Ne, polynomialorder)\n  Q = MPIStateArray(spatialdiscretization, initialcondition!)\n  filename = @sprintf(\"initialcondition_mpirank%04d\", MPI.Comm_rank(mpicomm))\n  writevtk(filename, Q, spatialdiscretization,\n                                       (\"q\",))\n\n  h = 1 / Ne","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"Since we are on the -1 1^d domain, the maximum velocity will by 2pi, thus this defines the CFL restriction","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"  CFL = h / (2π)\n  dt = CFL / polynomialorder^2\n  lsrk = LSRK54CarpenterKennedy(spatialdiscretization, Q; dt = dt, t0 = 0)\n  finaltime = 1.0","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"For simplicity we only include the vtk callback","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"  vtk_step = 0\n  mkpath(\"vtk\")\n  cb_vtk = GenericCallbacks.EveryXSimulationSteps(20) do\n    vtk_step += 1\n    filename = @sprintf(\"vtk/solid_body_rotation_mpirank%04d_step%04d\",\n                         MPI.Comm_rank(mpicomm), vtk_step)\n    writevtk(filename, Q, spatialdiscretization,\n                                         (\"q\",))\n    nothing\n  end\n\n  solve!(Q, lsrk; timeend = finaltime, callbacks = (cb_vtk, ))\n\n  filename = @sprintf(\"finalsolution_mpirank%04d\", MPI.Comm_rank(mpicomm))\n  writevtk(filename, Q, spatialdiscretization,\n                                       (\"q\",))","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"As with the initial condition, we need to catch the auxiliary state uvec in this initialization call.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"  Qe = MPIStateArray(spatialdiscretization) do Qin, x, y, z, uvec\n    exactsolution!(Qin, finaltime, x, y, z, uvec)\n  end\n\n  error = euclidean_distance(Q, Qe)\n  with_logger(mpi_logger) do\n    @info @sprintf(\"\"\"Run with\n                   dim              = %d\n                   Ne               = %d\n                   polynomial order = %d\n                   error            = %e\n                   \"\"\", dim, Ne, polynomialorder, error)\n  end\nend\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#Computing-rates-and-errors-1","page":"Example 002: Solid Body Rotation","title":"Computing rates and errors","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"As with ex 001, since the analytic solution is known we can compute the rate of convergence of the scheme","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"let\n  mpicomm = MPI.COMM_WORLD\n  mpi_logger = ConsoleLogger(MPI.Comm_rank(mpicomm) == 0 ? stderr : devnull)\n\n  dim = 2\n  polynomialorder = 4\n  finaltime = 1.0\n\n  with_logger(mpi_logger) do\n    @info @sprintf(\"\"\"Running with\n                   dim              = %d\n                   polynomial order = %d\n                   \"\"\", dim, polynomialorder)\n  end\n\n  base_Ne = 5\n  lvl_error = zeros(4) # number of levels to compute is length(lvl_error)\n  for lvl = 1:length(lvl_error)\n    # `Ne` for this mesh level\n    Ne = base_Ne * 2^(lvl-1)\n    spatialdiscretization = setupDG(mpicomm, dim, Ne, polynomialorder)\n\n    Q = MPIStateArray(spatialdiscretization, initialcondition!)\n    h = 1 / Ne\n    CFL = h / (2π)\n    dt = CFL / polynomialorder^2\n    lsrk = LSRK54CarpenterKennedy(spatialdiscretization, Q; dt = dt, t0 = 0)\n\n    solve!(Q, lsrk; timeend = finaltime)\n\n    Qe = MPIStateArray(spatialdiscretization) do Qin, x, y, z, uvec\n      exactsolution!(Qin, finaltime, x, y, z, uvec)\n    end\n\n    lvl_error[lvl] = euclidean_distance(Q, Qe)\n    msg =  @sprintf   \"Level      = %d\" lvl\n    msg *= @sprintf \"\\nNe               = %d\" Ne\n    msg *= @sprintf \"\\nerror            = %.4e\" lvl_error[lvl]\n    if lvl > 1\n      rate = log2(lvl_error[lvl-1]) - log2(lvl_error[lvl])\n      msg *= @sprintf \"\\nconvergence rate = %.4e\" rate\n    end\n    with_logger(mpi_logger) do\n      @info msg\n    end\n  end\nend\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#ex_002_solid_body_rotation-plain-program-1","page":"Example 002: Solid Body Rotation","title":"Plain Program","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"Below follows a version of the program without any comments. The file is also available here: ex_002_solid_body_rotation_periodic_advection.jl","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"using MPI\nusing CLIMA.Mesh.Topologies\nusing CLIMA.Mesh.Grids\nusing CLIMA.DGBalanceLawDiscretizations\nusing CLIMA.MPIStateArrays\nusing CLIMA.LowStorageRungeKuttaMethod\nusing CLIMA.ODESolvers\nusing CLIMA.GenericCallbacks\nusing CLIMA.VTK\nusing LinearAlgebra\nusing Logging\nusing Dates\nusing Printf\nusing StaticArrays\n\nMPI.Initialized() || MPI.Init()\n\nconst num_aux_states = 3\nfunction velocity_initilization!(uvec::MVector{num_aux_states, FT},\n                                 x, y, z) where FT\n  @inbounds begin\n    r = hypot(x, y)\n    θ = atan(y, x)\n    uvec .= 2FT(π) * r .* (-sin(θ), cos(θ), 0)\n  end\nend\n\nfunction advectionflux!(F, state, _, uvec, _)\n  FT = eltype(state) # get the floating point type we are using\n  @inbounds begin\n    q = state[1]\n    F[:, 1] = uvec * q\n  end\nend\n\nfunction upwindflux!(fs, nM, stateM, viscM, uvecM, stateP, viscP, uvecP, t)\n  FT = eltype(fs)\n  @inbounds begin\n    # determine the advection speed and direction\n    un = dot(nM, uvecM)\n    qM = stateM[1]\n    qP = stateP[1]\n    # Determine which state is \"upwind\" of the minus side\n    fs[1] = un ≥ 0 ? un * qM : un * qP\n  end\nend\n\nfunction upwindboundaryflux!(fs, nM, stateM, viscM, uvecM, stateP, viscP, uvecP,\n                             bctype, t)\n  FT = eltype(fs)\n  @inbounds begin\n    # determine the advection speed and direction\n    un = dot(nM, uvecM)\n    qM = stateM[1]\n    # Determine which state is \"upwind\" of the minus side\n    fs[1] = un ≥ 0 ? un * qM : 0\n  end\nend\n\nfunction initialcondition!(Q, x, y, z, _)\n  @inbounds Q[1] = exp(-(8 * hypot(x - 1//2, y, z))^2)\nend\n\nfunction exactsolution!(Q, t, x, y, z, uvec)\n  @inbounds begin\n    FT = eltype(Q)\n\n    r = hypot(x, y)\n    θ = atan(y, x) - 2FT(π) * t\n\n    x, y = r * cos(θ), r * sin(θ)\n\n    initialcondition!(Q, x, y, z, uvec)\n  end\nend\n\nfunction setupDG(mpicomm, dim, Ne, polynomialorder, FT=Float64,\n                 ArrayType=Array)\n\n  @assert ArrayType === Array\n\n  brickrange = (range(FT(-1); length=Ne+1, stop=1),\n                range(FT(-1); length=Ne+1, stop=1),\n                range(FT(-1); length=Ne+1, stop=1))\n\n  topology = BrickTopology(mpicomm, brickrange[1:dim])\n\n  grid = DiscontinuousSpectralElementGrid(topology; polynomialorder =\n                                          polynomialorder, FloatType = FT,\n                                          DeviceArray = ArrayType,)\n\n  spatialdiscretization = DGBalanceLaw(grid = grid, length_state_vector = 1,\n                                       flux! = advectionflux!,\n                                       numerical_flux! = upwindflux!,\n                                       numerical_boundary_flux! =\n                                       upwindboundaryflux!,\n                                       auxiliary_state_length = num_aux_states,\n                                       auxiliary_state_initialization! =\n                                       velocity_initilization!)\n\nend\n\nlet\n  mpicomm = MPI.COMM_WORLD\n  mpi_logger = ConsoleLogger(MPI.Comm_rank(mpicomm) == 0 ? stderr : devnull)\n  dim = 2\n  Ne = 20\n  polynomialorder = 4\n  spatialdiscretization = setupDG(mpicomm, dim, Ne, polynomialorder)\n  Q = MPIStateArray(spatialdiscretization, initialcondition!)\n  filename = @sprintf(\"initialcondition_mpirank%04d\", MPI.Comm_rank(mpicomm))\n  writevtk(filename, Q, spatialdiscretization,\n                                       (\"q\",))\n\n  h = 1 / Ne\n\n  CFL = h / (2π)\n  dt = CFL / polynomialorder^2\n  lsrk = LSRK54CarpenterKennedy(spatialdiscretization, Q; dt = dt, t0 = 0)\n  finaltime = 1.0\n\n  vtk_step = 0\n  mkpath(\"vtk\")\n  cb_vtk = GenericCallbacks.EveryXSimulationSteps(20) do\n    vtk_step += 1\n    filename = @sprintf(\"vtk/solid_body_rotation_mpirank%04d_step%04d\",\n                         MPI.Comm_rank(mpicomm), vtk_step)\n    writevtk(filename, Q, spatialdiscretization,\n                                         (\"q\",))\n    nothing\n  end\n\n  solve!(Q, lsrk; timeend = finaltime, callbacks = (cb_vtk, ))\n\n  filename = @sprintf(\"finalsolution_mpirank%04d\", MPI.Comm_rank(mpicomm))\n  writevtk(filename, Q, spatialdiscretization,\n                                       (\"q\",))\n\n  Qe = MPIStateArray(spatialdiscretization) do Qin, x, y, z, uvec\n    exactsolution!(Qin, finaltime, x, y, z, uvec)\n  end\n\n  error = euclidean_distance(Q, Qe)\n  with_logger(mpi_logger) do\n    @info @sprintf(\"\"\"Run with\n                   dim              = %d\n                   Ne               = %d\n                   polynomial order = %d\n                   error            = %e\n                   \"\"\", dim, Ne, polynomialorder, error)\n  end\nend\n\nlet\n  mpicomm = MPI.COMM_WORLD\n  mpi_logger = ConsoleLogger(MPI.Comm_rank(mpicomm) == 0 ? stderr : devnull)\n\n  dim = 2\n  polynomialorder = 4\n  finaltime = 1.0\n\n  with_logger(mpi_logger) do\n    @info @sprintf(\"\"\"Running with\n                   dim              = %d\n                   polynomial order = %d\n                   \"\"\", dim, polynomialorder)\n  end\n\n  base_Ne = 5\n  lvl_error = zeros(4) # number of levels to compute is length(lvl_error)\n  for lvl = 1:length(lvl_error)\n    # `Ne` for this mesh level\n    Ne = base_Ne * 2^(lvl-1)\n    spatialdiscretization = setupDG(mpicomm, dim, Ne, polynomialorder)\n\n    Q = MPIStateArray(spatialdiscretization, initialcondition!)\n    h = 1 / Ne\n    CFL = h / (2π)\n    dt = CFL / polynomialorder^2\n    lsrk = LSRK54CarpenterKennedy(spatialdiscretization, Q; dt = dt, t0 = 0)\n\n    solve!(Q, lsrk; timeend = finaltime)\n\n    Qe = MPIStateArray(spatialdiscretization) do Qin, x, y, z, uvec\n      exactsolution!(Qin, finaltime, x, y, z, uvec)\n    end\n\n    lvl_error[lvl] = euclidean_distance(Q, Qe)\n    msg =  @sprintf   \"Level      = %d\" lvl\n    msg *= @sprintf \"\\nNe               = %d\" Ne\n    msg *= @sprintf \"\\nerror            = %.4e\" lvl_error[lvl]\n    if lvl > 1\n      rate = log2(lvl_error[lvl-1]) - log2(lvl_error[lvl])\n      msg *= @sprintf \"\\nconvergence rate = %.4e\" rate\n    end\n    with_logger(mpi_logger) do\n      @info msg\n    end\n  end\nend\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/DGmethods_old/generated/ex_002_solid_body_rotation.html#","page":"Example 002: Solid Body Rotation","title":"Example 002: Solid Body Rotation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Utilities/RootSolvers.html#RootSolvers-1","page":"RootSolvers","title":"RootSolvers","text":"","category":"section"},{"location":"Utilities/RootSolvers.html#","page":"RootSolvers","title":"RootSolvers","text":"CurrentModule = CLIMA.RootSolvers","category":"page"},{"location":"Utilities/RootSolvers.html#","page":"RootSolvers","title":"RootSolvers","text":"RootSolvers\nfind_zero","category":"page"},{"location":"Utilities/RootSolvers.html#CLIMA.RootSolvers","page":"RootSolvers","title":"CLIMA.RootSolvers","text":"RootSolvers\n\nModule containing functions for solving roots of non-linear equations. See find_zero.\n\nExample\n\nusing CLIMA.Utilities.RootSolvers\n\nx_root, converged = find_zero(x -> x^2 - 100^2, 0.0, 1000.0, SecantMethod())\n\n\n\n\n\n","category":"module"},{"location":"Utilities/RootSolvers.html#CLIMA.RootSolvers.find_zero","page":"RootSolvers","title":"CLIMA.RootSolvers.find_zero","text":"x, converged = find_zero(f, x0[, x1], method,\n                         xatol=1e-3,\n                         maxiters=10_000)\n\nFinds the nearest root of f to x0 and x1. Returns a the value of the root x such that f(x) ≈ 0, and a Boolean value converged indicating convergence.\n\nmethod can be one of:\n\nSecantMethod(): Secant method\nRegulaFalsiMethod(): Regula Falsi method.\nNewtonsMethod(): Newton's method\nThe x1 argument is omitted for Newton's method.\n\nThe keyword arguments:\n\nxatol is the absolute tolerance of the input.\nmaxiters is the maximum number of iterations.\n\n\n\n\n\n","category":"function"},{"location":"Atmos/SurfaceFluxes.html#SurfaceFluxes-1","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"","category":"section"},{"location":"Atmos/SurfaceFluxes.html#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"CurrentModule = CLIMA.SurfaceFluxes","category":"page"},{"location":"Atmos/SurfaceFluxes.html#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"Surface flux functions, e.g. for buoyancy flux, friction velocity, and exchange coefficients.","category":"page"},{"location":"Atmos/SurfaceFluxes.html#Byun1990-1","page":"SurfaceFluxes","title":"Byun1990","text":"","category":"section"},{"location":"Atmos/SurfaceFluxes.html#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"Compute surface fluxes using the approach in Byun (1990).","category":"page"},{"location":"Atmos/SurfaceFluxes.html#Plots-1","page":"SurfaceFluxes","title":"Plots","text":"","category":"section"},{"location":"Atmos/SurfaceFluxes.html#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"using CLIMA.SurfaceFluxes.Byun1990\nusing Plots, LaTeXStrings\n\nRi_range = range(-1.2, stop=0.24, length=100)\nscales = [50,200,600,1000,10_000]\n\nz_0 = 1.0\nγ_m, γ_h = 15.0, 9.0\nβ_m, β_h = 4.8, 7.8\nPr_0 = 0.74\n\nplot(Ri_range,\n    [Byun1990.compute_exchange_coefficients(Ri,scale*z_0,z_0,γ_m,γ_h,β_m,β_h,Pr_0)[1]\n        for Ri in Ri_range, scale in scales],\n    xlabel=\"Bulk Richardson number (Ri_b)\", ylabel=\"Drag coefficient\", title=\"Momentum exchange coefficient\",\n    labels=scales, legendtitle=L\"z/z_0\")\n\nsavefig(\"exchange_byun1990_fig4a.svg\") # hide\nnothing # hide","category":"page"},{"location":"Atmos/SurfaceFluxes.html#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"(Image: )","category":"page"},{"location":"Atmos/SurfaceFluxes.html#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"Recreation of Figure 4(a) from Byun (1990)","category":"page"},{"location":"Atmos/SurfaceFluxes.html#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"plot(Ri_range,\n    [Byun1990.compute_exchange_coefficients(Ri,scale*z_0,z_0,γ_m,γ_h,β_m,β_h,Pr_0)[2]\n        for Ri in Ri_range, scale in scales],\n    xlabel=\"Bulk Richardson number (Ri_b)\", ylabel=\"Exchange coefficient\", title=\"Heat exchange coefficient\",\n    labels=scales, legendtitle=L\"z/z_0\")\n\nsavefig(\"exchange_byun1990_fig4b.svg\") # hide\nnothing # hide","category":"page"},{"location":"Atmos/SurfaceFluxes.html#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"(Image: )","category":"page"},{"location":"Atmos/SurfaceFluxes.html#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"Recreation of Figure 4(b) from Byun (1990)","category":"page"},{"location":"Atmos/SurfaceFluxes.html#Nishizawa2018-1","page":"SurfaceFluxes","title":"Nishizawa2018","text":"","category":"section"},{"location":"Atmos/SurfaceFluxes.html#Plots-2","page":"SurfaceFluxes","title":"Plots","text":"","category":"section"},{"location":"Atmos/SurfaceFluxes.html#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"using CLIMA.SurfaceFluxes.Nishizawa2018\nusing Plots, LaTeXStrings\n\na = 4.7\nθ = 350\nz_0 = 10\nu_ave = 10\nflux = 1\nΔz = range(10.0, stop=100.0, length=100)\nΨ_m_tol, tol_abs, iter_max = 1e-3, 1e-3, 10\nu_star = Nishizawa2018.compute_friction_velocity.(\n    u_ave, θ, flux, Δz, z_0, a, Ψ_m_tol, tol_abs, iter_max)\nplot(u_star, Δz, title = \"Friction velocity vs dz\", xlabel = \"Friction velocity\", ylabel = \"dz\")\nsavefig(\"friction_velocity.svg\") # hide\nnothing # hide","category":"page"},{"location":"Atmos/SurfaceFluxes.html#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"(Image: )","category":"page"},{"location":"Atmos/SurfaceFluxes.html#API-1","page":"SurfaceFluxes","title":"API","text":"","category":"section"},{"location":"Atmos/SurfaceFluxes.html#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"compute_buoyancy_flux\nByun1990.compute_MO_len\nByun1990.compute_friction_velocity\nByun1990.compute_exchange_coefficients\nNishizawa2018.compute_MO_len\nNishizawa2018.compute_friction_velocity\nNishizawa2018.compute_exchange_coefficients","category":"page"},{"location":"Atmos/SurfaceFluxes.html#CLIMA.SurfaceFluxes.compute_buoyancy_flux","page":"SurfaceFluxes","title":"CLIMA.SurfaceFluxes.compute_buoyancy_flux","text":"compute_buoyancy_flux(shf, lhf, T_b, qt_b, ql_b, qi_b, alpha0_0)\n\nComputes buoyancy flux given sensible heat flux shf, latent heat flux lhf, surface boundary temperature T_b, total specific humidity qt_b, liquid specific humidity ql_b, ice specific humidity qi_b and specific alpha0_0.\n\n\n\n\n\n","category":"function"},{"location":"Atmos/SurfaceFluxes.html#CLIMA.SurfaceFluxes.Byun1990.compute_MO_len","page":"SurfaceFluxes","title":"CLIMA.SurfaceFluxes.Byun1990.compute_MO_len","text":"compute_MO_len(u, flux)\n\nComputes the Monin-Obukhov length (Eq. 3 Ref. Byun1990)\n\n\n\n\n\n","category":"function"},{"location":"Atmos/SurfaceFluxes.html#CLIMA.SurfaceFluxes.Byun1990.compute_friction_velocity","page":"SurfaceFluxes","title":"CLIMA.SurfaceFluxes.Byun1990.compute_friction_velocity","text":"compute_friction_velocity(u_ave, flux, z_0, z_1, β_m, γ_m, tol_abs, iter_max)\n\nComputes roots of friction velocity equation (Eq. 10 in Ref. Byun1990)\n\nu_ave = u_* ( ln(z/z_0) - ψ_m(z/L, z_0/L) ) /κ        Eq. 10 in Ref. Byun1990\n\n\n\n\n\n","category":"function"},{"location":"Atmos/SurfaceFluxes.html#CLIMA.SurfaceFluxes.Byun1990.compute_exchange_coefficients","page":"SurfaceFluxes","title":"CLIMA.SurfaceFluxes.Byun1990.compute_exchange_coefficients","text":"compute_exchange_coefficients(Ri, z_b, z_0, γ_m, γ_h, β_m, β_h, Pr_0)\n\nComputes exchange transfer coefficients:\n\nC_D  momentum exchange coefficient      (Eq. 36)\nC_H  thermodynamic exchange coefficient (Eq. 37)\nL_mo Monin-Obukhov length               (re-arranged Eq. 3)\n\n\n\n\n\n","category":"function"},{"location":"Atmos/SurfaceFluxes.html#CLIMA.SurfaceFluxes.Nishizawa2018.compute_MO_len","page":"SurfaceFluxes","title":"CLIMA.SurfaceFluxes.Nishizawa2018.compute_MO_len","text":"compute_MO_len(u, θ, flux)\n\nComputes Monin-Obukhov length. Eq. 3 Ref. Nishizawa2018\n\n\n\n\n\n","category":"function"},{"location":"Atmos/SurfaceFluxes.html#CLIMA.SurfaceFluxes.Nishizawa2018.compute_friction_velocity","page":"SurfaceFluxes","title":"CLIMA.SurfaceFluxes.Nishizawa2018.compute_friction_velocity","text":"compute_friction_velocity(u_ave, θ, flux, Δz, z_0, a, Ψ_m_tol, tol_abs, iter_max)\n\nComputes friction velocity, in Eq. 12 in Ref. Nishizawa2018, by solving the non-linear equation:\n\nu_ave = ustar/κ * ( ln(Δz/z_0) - Ψ_m(Δz/L) + z_0/Δz * Ψ_m(z_0/L) + R_z0 [ψ_m(z_0/L) - 1] )\n\nwhere L is a non-linear function of ustar (see compute_MO_len).\n\n\n\n\n\n","category":"function"},{"location":"Atmos/SurfaceFluxes.html#CLIMA.SurfaceFluxes.Nishizawa2018.compute_exchange_coefficients","page":"SurfaceFluxes","title":"CLIMA.SurfaceFluxes.Nishizawa2018.compute_exchange_coefficients","text":"compute_exchange_coefficients(z, F_m, F_h, a, u_star, θ, flux, Pr)\n\nComputes exchange transfer coefficients:\n\nK_D  momentum exchange coefficient\nK_H  thermodynamic exchange coefficient\nL_mo Monin-Obukhov length\n\n\n\n\n\n","category":"function"},{"location":"Atmos/SurfaceFluxes.html#References-1","page":"SurfaceFluxes","title":"References","text":"","category":"section"},{"location":"Atmos/SurfaceFluxes.html#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"Businger, Joost A., et al. \"Flux-profile relationships in the atmospheric surface layer.\" Journal of the atmospheric Sciences 28.2 (1971): 181-189. doi: 10.1175/1520-0469(1971)028<0181:FPRITA>2.0.CO;2\nNishizawa, S., and Y. Kitamura. \"A Surface Flux Scheme Based on the Monin-Obukhov Similarity for Finite Volume Models.\" Journal of Advances in Modeling Earth Systems 10.12 (2018): 3159-3175. doi: 10.1029/2018MS001534\nByun, Daewon W. \"On the analytical solutions of flux-profile relationships for the atmospheric surface layer.\" Journal of Applied Meteorology 29.7 (1990): 652-657. doi: 10.1175/1520-0450(1990)029<0652:OTASOF>2.0.CO;2\nWyngaard, John C. \"Modeling the planetary boundary layer-Extension to the stable case.\" Boundary-Layer Meteorology 9.4 (1975): 441-460. doi: 10.1007/BF00223393","category":"page"},{"location":"examples/DGmethods_old/generated/ex_004_nonnegative.html#","page":"-","title":"-","text":"EditURL = \"https://github.com/climate-machine/CLIMA/blob/master/examples/DGmethods_old/ex_004_nonnegative.jl\"","category":"page"},{"location":"examples/DGmethods_old/generated/ex_004_nonnegative.html#","page":"-","title":"-","text":"This example uses the TMAR Filter from","category":"page"},{"location":"examples/DGmethods_old/generated/ex_004_nonnegative.html#","page":"-","title":"-","text":"@article{doi:10.1175/MWR-D-16-0220.1,      author = {Light, Devin and Durran, Dale},      title = {Preserving Nonnegativity in Discontinuous Galerkin               Approximations to Scalar Transport via Truncation and Mass               Aware Rescaling (TMAR)},      journal = {Monthly Weather Review},      volume = {144},      number = {12},      pages = {4771-4786},      year = {2016},      doi = {10.1175/MWR-D-16-0220.1},    }","category":"page"},{"location":"examples/DGmethods_old/generated/ex_004_nonnegative.html#","page":"-","title":"-","text":"to reproduce the example in section 4b.  It is a shear swirling flow deformation of a transported quantity from LeVeque 1996.  The exact solution at the final time is the same as the initial condition.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_004_nonnegative.html#","page":"-","title":"-","text":"using MPI\nusing CLIMA\nusing CLIMA.Mesh.Topologies\nusing CLIMA.Mesh.Grids\nusing CLIMA.Mesh.Filters\nusing CLIMA.DGBalanceLawDiscretizations\nusing CLIMA.MPIStateArrays\nusing CLIMA.StrongStabilityPreservingRungeKuttaMethod\nusing CLIMA.ODESolvers\nusing CLIMA.GenericCallbacks\nusing CLIMA.VTK\nusing LinearAlgebra\nusing Logging\nusing Dates\nusing Printf\nusing StaticArrays\n\n@static if haspkg(\"CuArrays\")\n  using CUDAdrv\n  using CUDAnative\n  using CuArrays\n  CuArrays.allowscalar(false)\n  const DeviceArrayType = CuArray\nelse\n  const DeviceArrayType = Array\nend\n\nMPI.Initialized() || MPI.Init()\n\nconst finaltime = 5\n\nfunction velocity(x, y, t)\n  sx, cx = sinpi(x), cospi(x)\n  sy, cy = sinpi(y), cospi(y)\n  ct = cospi(t/finaltime)\n\n  u =  2sx^2*sy*cy*ct\n  v = -2sy^2*sx*cx*ct\n  (u, v)\nend\n\ncosbell(τ, q) = τ ≤ 1 ? ((1 + cospi(τ))/2)^q : zero(τ)\n\nfunction initialcondition!(Q, x, y, z, _)\n  FT = eltype(Q)\n  x0, y0 = FT(1//4), FT(1//4)\n  τ = 4hypot(x-x0, y-y0)\n  @inbounds Q[1] = cosbell(τ, 3)\nend\n\nconst num_aux_states = 4\nconst _a_x, _a_y, _a_u, _a_v = 1:num_aux_states\n\nfunction aux_init!(aux, x, y, z)\n  u, v = velocity(x, y, zero(x))\n\n  @inbounds aux[_a_x], aux[_a_y], aux[_a_u], aux[_a_v] = x, y, u, v\nend\n\nfunction advectionflux!(F, state, _, aux, _)\n  @inbounds begin\n    U, q = @SVector([aux[_a_u], aux[_a_v], 0]), state[1]\n    F[:, 1] .= U*q\n  end\nend\n\nfunction upwindflux!(fs, nM, stateM, _, auxM, stateP, viscP, auxP, t)\n  @inbounds begin\n    UM, qM, qP = @SVector([auxM[_a_u], auxM[_a_v], 0]), stateM[1], stateP[1]\n    un = dot(nM, UM)\n\n    fs[1] = un ≥ 0 ? un * qM : un * qP\n  end\nend\n\nfunction upwindboundaryflux!(fs, nM, stateM, viscM, auxM, stateP, viscP, auxP,\n                             bctype, t)\n  stateP .= 0\n  upwindflux!(fs, nM, stateM, viscM, auxM, stateP, viscP, auxP, t)\nend\n\nfunction preodefun!(disc, Q, t)","category":"page"},{"location":"examples/DGmethods_old/generated/ex_004_nonnegative.html#","page":"-","title":"-","text":"Update the velocity","category":"page"},{"location":"examples/DGmethods_old/generated/ex_004_nonnegative.html#","page":"-","title":"-","text":"  DGBalanceLawDiscretizations.dof_iteration!(disc.auxstate, disc, Q) do R, _, _, aux\n      @inbounds R[_a_u], R[_a_v] = velocity(aux[_a_x], aux[_a_y], t)\n  end\n\n  Filters.apply!(Q, 1, disc.grid, TMARFilter())\nend\n\nfunction setupDG(mpicomm, dim, Ne, polynomialorder, FT=Float64, ArrayType=Array)\n  brickrange = (range(FT(0); length=Ne+1, stop=1),\n                range(FT(0); length=Ne+1, stop=1),\n                range(FT(0); length=Ne+1, stop=1))\n\n  topology = BrickTopology(mpicomm, brickrange[1:dim])\n\n  grid = DiscontinuousSpectralElementGrid(topology; polynomialorder =\n                                          polynomialorder, FloatType = FT,\n                                          DeviceArray = ArrayType,)\n\n  spatialdiscretization = DGBalanceLaw(grid = grid, length_state_vector = 1,\n                                       flux! = advectionflux!,\n                                       numerical_flux! = upwindflux!,\n                                       numerical_boundary_flux! =\n                                       upwindboundaryflux!,\n                                       auxiliary_state_length = num_aux_states,\n                                       auxiliary_state_initialization! = aux_init!,\n                                       preodefun! = preodefun!)\nend\n\nfunction run()\n  mpicomm = MPI.COMM_WORLD\n  mpi_logger = ConsoleLogger(MPI.Comm_rank(mpicomm) == 0 ? stderr : devnull)\n  rank = MPI.Comm_rank(mpicomm)\n\n  @static if haspkg(\"CUDAnative\")\n    device!(rank % length(devices()))\n  end\n\n  dim = 2\n  Ne = 20\n  polynomialorder = 4\n  FT = Float64\n\n  spatialdiscretization = setupDG(mpicomm, dim, Ne, polynomialorder, FT,\n                                  DeviceArrayType)\n  Q = MPIStateArray(spatialdiscretization, initialcondition!)\n\n  maxvelosity = 2\n  elementsize = 1 / Ne\n  dx = elementsize / polynomialorder^2\n  CFL = 1\n\n  dt = CFL * dx / maxvelosity\n  @info @sprintf \"dt = %1.2e\" dt\n  sork = SSPRK33ShuOsher(spatialdiscretization, Q; dt = dt, t0 = 0)\n\n  initialsumQ = weightedsum(Q)\n\n  vtk_step = 0\n  mkpath(\"vtk\")\n  function vtkoutput()\n    Filters.apply!(Q, 1, spatialdiscretization.grid, TMARFilter())\n\n    filename = @sprintf(\"vtk/q_rank%04d_step%04d\", rank, vtk_step)\n    writevtk(filename, Q, spatialdiscretization, (\"q\",))\n\n    minQ = MPI.Reduce([minimum(Q.realdata)], MPI.MIN, 0, Q.mpicomm)\n    maxQ = MPI.Reduce([maximum(Q.realdata)], MPI.MAX, 0, Q.mpicomm)\n    sumQ = weightedsum(Q)\n\n    with_logger(mpi_logger) do\n      @info @sprintf(\"\"\"step = %d\n                           min Q = %25.16e\n                           max Q = %25.16e\n                     sum error Q = %25.16e\n                     \"\"\", vtk_step, minQ[1], maxQ[1], (initialsumQ -\n                                                       sumQ)/initialsumQ)\n    end\n\n    vtk_step += 1\n    nothing\n  end\n\n  cb_vtk = GenericCallbacks.EveryXSimulationSteps(vtkoutput, 40)\n\n  vtkoutput()","category":"page"},{"location":"examples/DGmethods_old/generated/ex_004_nonnegative.html#","page":"-","title":"-","text":"We integrate so that the final solution is equal to the initial solution","category":"page"},{"location":"examples/DGmethods_old/generated/ex_004_nonnegative.html#","page":"-","title":"-","text":"  Qe = copy(Q)\n\n  solve!(Q, sork; timeend = finaltime, callbacks = (cb_vtk, ))\n\n  vtkoutput()\n\n  minQ = MPI.Reduce([minimum(Q.realdata)], MPI.MIN, 0, Q.mpicomm)\n  maxQ = MPI.Reduce([maximum(Q.realdata)], MPI.MAX, 0, Q.mpicomm)\n  finalsumQ = weightedsum(Q)\n  sumerror = (initialsumQ - finalsumQ) / initialsumQ\n  error = euclidean_distance(Q, Qe)\n  with_logger(mpi_logger) do\n    @info @sprintf(\"\"\"Run with\n                   dim              = %d\n                   Ne               = %d\n                   polynomial order = %d\n                   min              = %e\n                   max              = %e\n                   L2 error         = %e\n                   sum error        = %e\n                   \"\"\", dim, Ne, polynomialorder, minQ[1], maxQ[1], error,\n                   sumerror)\n  end\nend\n\nrun()","category":"page"},{"location":"examples/DGmethods_old/generated/ex_004_nonnegative.html#","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"LinearSolvers.html#LinearSolvers-1","page":"LinearSolvers","title":"LinearSolvers","text":"","category":"section"},{"location":"LinearSolvers.html#","page":"LinearSolvers","title":"LinearSolvers","text":"CurrentModule = CLIMA","category":"page"},{"location":"LinearSolvers.html#GeneralizedConjugateResidual-1","page":"LinearSolvers","title":"GeneralizedConjugateResidual","text":"","category":"section"},{"location":"LinearSolvers.html#","page":"LinearSolvers","title":"LinearSolvers","text":"GeneralizedConjugateResidualSolver.GeneralizedConjugateResidual","category":"page"},{"location":"LinearSolvers.html#CLIMA.GeneralizedConjugateResidualSolver.GeneralizedConjugateResidual","page":"LinearSolvers","title":"CLIMA.GeneralizedConjugateResidualSolver.GeneralizedConjugateResidual","text":"GeneralizedConjugateResidual(K, Q, tolerance)\n\nThis is an object for solving linear systems using an iterative Krylov method. The constructor parameter K is the number of steps after which the algorithm is restarted (if it has not converged), Q is a reference state used only to allocate the solver internal state, and tolerance specifies the convergence criterion based on the relative residual norm. The amount of memory required by the solver state is roughly (2K + 2) * size(Q). This object is intended to be passed to the linearsolve! command.\n\nThis uses the restarted Generalized Conjugate Residual method of Eisenstat (1983).\n\nReferences\n\n@article{eisenstat1983variational,\n  title={Variational iterative methods for nonsymmetric systems of linear equations},\n  author={Eisenstat, Stanley C and Elman, Howard C and Schultz, Martin H},\n  journal={SIAM Journal on Numerical Analysis},\n  volume={20},\n  number={2},\n  pages={345--357},\n  year={1983},\n  publisher={SIAM}\n}\n\n\n\n\n\n","category":"type"},{"location":"LinearSolvers.html#GeneralizedMinimalResidual-1","page":"LinearSolvers","title":"GeneralizedMinimalResidual","text":"","category":"section"},{"location":"LinearSolvers.html#","page":"LinearSolvers","title":"LinearSolvers","text":"GeneralizedMinimalResidualSolver.GeneralizedMinimalResidual","category":"page"},{"location":"LinearSolvers.html#CLIMA.GeneralizedMinimalResidualSolver.GeneralizedMinimalResidual","page":"LinearSolvers","title":"CLIMA.GeneralizedMinimalResidualSolver.GeneralizedMinimalResidual","text":"GeneralizedMinimalResidual(M, Q, tolerance)\n\nThis is an object for solving linear systems using an iterative Krylov method. The constructor parameter M is the number of steps after which the algorithm is restarted (if it has not converged), Q is a reference state used only to allocate the solver internal state, and tolerance specifies the convergence criterion based on the relative residual norm. The amount of memory  required for the solver state is roughly (M + 1) * size(Q). This object is intended to be passed to the linearsolve! command.\n\nThis uses the restarted Generalized Minimal Residual method of Saad and Schultz (1986).\n\nReferences\n\n@article{saad1986gmres,\n  title={GMRES: A generalized minimal residual algorithm for solving nonsymmetric linear systems},\n  author={Saad, Youcef and Schultz, Martin H},\n  journal={SIAM Journal on scientific and statistical computing},\n  volume={7},\n  number={3},\n  pages={856--869},\n  year={1986},\n  publisher={SIAM}\n}\n\n\n\n\n\n","category":"type"},{"location":"LinearSolvers.html#LinearSolvers-2","page":"LinearSolvers","title":"LinearSolvers","text":"","category":"section"},{"location":"LinearSolvers.html#","page":"LinearSolvers","title":"LinearSolvers","text":"LinearSolvers.AbstractLinearSolver\nLinearSolvers.AbstractIterativeLinearSolver\nLinearSolvers.linearsolve!\nLinearSolvers.settolerance!","category":"page"},{"location":"LinearSolvers.html#CLIMA.LinearSolvers.AbstractLinearSolver","page":"LinearSolvers","title":"CLIMA.LinearSolvers.AbstractLinearSolver","text":"AbstractLinearSolver\n\nThis is an abstract type representing a generic linear solver.\n\n\n\n\n\n","category":"type"},{"location":"LinearSolvers.html#CLIMA.LinearSolvers.AbstractIterativeLinearSolver","page":"LinearSolvers","title":"CLIMA.LinearSolvers.AbstractIterativeLinearSolver","text":"AbstractIterativeLinearSolver\n\nThis is an abstract type representing a generic iterative linear solver.\n\nThe available concrete implementations are:\n\nGeneralizedConjugateResidual\nGeneralizedMinimalResidual\n\n\n\n\n\n","category":"type"},{"location":"LinearSolvers.html#CLIMA.LinearSolvers.linearsolve!","page":"LinearSolvers","title":"CLIMA.LinearSolvers.linearsolve!","text":"linearsolve!(linearoperator!, solver::AbstractIterativeLinearSolver, Q, Qrhs, args...)\n\nSolves a linear problem defined by the linearoperator! function and the state Qrhs, i.e,\n\nL(Q) = Q_rhs\n\nusing the solver and the initial guess Q. After the call Q contains the solution.  The arguments args is passed to linearoperator! when it is called.\n\n\n\n\n\n","category":"function"},{"location":"LinearSolvers.html#CLIMA.LinearSolvers.settolerance!","page":"LinearSolvers","title":"CLIMA.LinearSolvers.settolerance!","text":"settolerance!(solver::AbstractIterativeLinearSolver, tolerance)\n\nSets the tolerance of the iterative linear solver solver to tolerance.\n\n\n\n\n\n","category":"function"},{"location":"Atmos/Microphysics.html#Microphysics-Module-1","page":"Microphysics","title":"Microphysics Module","text":"","category":"section"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"The Microphysics module describes warm rain bulk parameterization of cloud microphysical processes. The module describes the warm rain (no ice and snow) formation and is based on the ideas of Kessler 1995.","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"Parameterized processes include:","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"rain sedimentation with mass weighted average terminal velocity,\ncondensation/evaporation of cloud water,\nautoconversion,\naccretion,\nevaporation of rain water.","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"The cloud microphysics variables are expressed as specific humidities:","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"q_tot - total water specific humidity,\nq_vap - water vapor specific humidity,\nq_liq - liquid water specific humidity,\nq_rai - rain water specific humidity.","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"Parameters used in the parameterization are defined in MicrophysicsParameters module. They consist of:","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"symbol definition units default value\nn_0_MP rain drop size distribution parameter frac1m^4 16 cdot 10^6\ntau_cond_evap cloud water condensation/evaporation timescale s 10\ntau_acnv cloud to rain water autoconversion timescale s 10^3\nq_liq_threshold cloud to rain water autoconversion threshold - 5 cdot 10^-4\nE_col collision efficiency between rain drops and cloud droplets - 08\nC_drag rain drop drag coefficient - 055\na_vent b_vent rain drop ventilation factor coefficients - 15 , 053\nK_therm thermal conductivity of air fracJm  s  K 24 cdot 10^-2\nnu_air kinematic viscosity of air fracm^2s 16 cdot 10^-5\nD_vapor diffusivity of water vapor fracm^2s 226 cdot 10^-5","category":"page"},{"location":"Atmos/Microphysics.html#Rain-drop-size-distribution-1","page":"Microphysics","title":"Rain drop size distribution","text":"","category":"section"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"The rain-drop size distribution is assumed to follow Marshall-Palmer distribution (Marshall Palmer 1948 eq. 1):","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"beginequation\nn(r) = n_0_MP expleft(- lambda_MP  r right)\nendequation","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"r is the drop radius,\nn_0_MP and lambda_MP are the Marshall-Palmer distribution parameters (twice the values used in the Marshall Palmer 1948, because we use drop radius and not diameter).","category":"page"},{"location":"Atmos/Microphysics.html#Terminal-velocity-1","page":"Microphysics","title":"Terminal velocity","text":"","category":"section"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"The terminal velocity of an individual rain drop is defined by the balance between the gravitational acceleration (taking into account the density difference between water and air) and the drag force:","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"beginequation\nv_drop = left(frac83  C_drag left( fracrho_waterrho -1 right) right)^12 (g  r)^12 = v_c(rho)  (g  r)^12\nlabeleqvdrop\nendequation","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"g is the gravitational acceleration,\nC_drag is the drag coefficient,\nrho_water is the density of water,\nrho is the density of air.","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"The mass weighted terminal velocity v_t is defined following Ogura and Takahashi 1971","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"beginequation\nv_t = fracF_rainRWC\nlabeleqvt\nendequation","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"F_rain = int_0^infty n(r)  m(r)  v_drop(r)  dr is the vertical flux of rain drops,\nRWC = int_0^infty n(r)  m(r)  dr = rho  q_rai is the rain water content.","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"Integrating over the assumed Marshall-Palmer distribution results in","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"beginequation\nRWC = frac8 pi  n_0_MP  rho_waterlambda_MP^4\nlabeleqlambda\nendequation","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"beginequation\nF_rain = Gamma left(frac92 right) frac43 n_0_MP  pi  rho_water v_c(rho)  g^12 (lambda_MP)^-92\nlabeleqfrain\nendequation","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"Substituting eq.(\\ref{eq:lambda}) and eq.(\\ref{eq:frain}) into eq.(\\ref{eq:vt}) results in:","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"beginequation\nv_t = Gamma left( frac92 right)  fracv_c(rho)6  left( fracglambda_MPright)^12\nendequation","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"where lambda_MP is computed as","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"lambda_MP = left( frac8 pi rho_water n_0_MPrho q_rai right)^14","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"The default value of C_drag is chosen such that the v_t is close to the empirical terminal velocity formulation in Smolarkiewicz and Grabowski 1996. Assuming a constant drag coefficient is an approximation as it should be size and flow dependent, see drag_coefficient.","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"using CLIMA.Microphysics\nusing Plots\n\n# eq. 5d in Smolarkiewicz and Grabowski 1996\n# https://doi.org/10.1175/1520-0493(1996)124<0487:TTLSLM>2.0.CO;2\nfunction terminal_velocity_empirical(q_rai::DT, q_tot::DT, ρ::DT, ρ_air_ground::DT) where {DT<:Real}\n    rr  = q_rai / (DT(1) - q_tot)\n    vel = DT(14.34) * ρ_air_ground^DT(0.5) * ρ^-DT(0.3654) * rr^DT(0.1346)\n    return vel\nend\n\nq_rain_range = range(1e-8, stop=5e-3, length=100)\nρ_air, q_tot, ρ_air_ground = 1.2, 20 * 1e-3, 1.22\n\nplot(q_rain_range * 1e3,  [terminal_velocity(q_rai, ρ_air) for q_rai in q_rain_range], xlabel=\"q_rain [g/kg]\", ylabel=\"velocity [m/s]\", title=\"Average terminal velocity of rain\", label=\"CLIMA\")\nplot!(q_rain_range * 1e3, [terminal_velocity_empirical(q_rai, q_tot, ρ_air, ρ_air_ground) for q_rai in q_rain_range], label=\"Empirical\")\nsavefig(\"rain_terminal_velocity.svg\") # hide\nnothing # hide","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"(Image: )","category":"page"},{"location":"Atmos/Microphysics.html#Cloud-condensation/evaporation-1","page":"Microphysics","title":"Cloud condensation/evaporation","text":"","category":"section"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"Condensation and evaporation of cloud water is parameterized as a relaxation to equilibrium value at the current time step.","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"beginequation\n  left fracd  q_liqdt right_cond evap = fracq^eq_liq - q_liqtau_cond_evap\nendequation","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"q^eq_liq - liquid water specific humidity in equilibrium,\nq_liq - liquid water specific humidity,\ntau_cond_evap - relaxation timescale (parameter in MicrophysicsParameters module).","category":"page"},{"location":"Atmos/Microphysics.html#Autoconversion-1","page":"Microphysics","title":"Autoconversion","text":"","category":"section"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"Autoconversion defines the rate of conversion form cloud to rain water due to collisions between cloud droplets. It is parameterized following Kessler 1995:","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"beginequation\n  left fracd  q_raidt right_acnv = fracmax(0 q_liq - q_liq_threshold)tau_acnv\nendequation","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"q_liq - liquid water specific humidity,\ntau_acnv - timescale (parameter in MicrophysicsParameters module),\nq_liq_threshold - autoconversion (parameter in MicrophysicsParameters module).","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"The default values of tau_acnv and q_liq_threshold are based on Smolarkiewicz and Grabowski 1996.","category":"page"},{"location":"Atmos/Microphysics.html#Accretion-1","page":"Microphysics","title":"Accretion","text":"","category":"section"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"Accretion defines the rate of conversion from cloud to rain water resulting from collisions between cloud droplets and rain drops. It is parameterized following Kessler 1995:","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"beginequation\nleft fracd  q_raidt right_accr = int_0^infty n(r)  pi r^2  v_drop E_col q_liq dr\nendequation","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"E_col is the collision efficiency,\nv_drop is defined in eq.(\\ref{eq:vdrop}).","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"Integrating over the distribution and using the RWC to eliminate the lambda_MP results in:","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"beginequation\nleft fracd  q_raidt right_accr  = Gamma left(frac72 right) pi^18 8^-78 E_col v_c(rho)  left(fracrhorho_waterright)^78 n_0_MP^18 g^12 q_liq q_rai^78 = A(rho)  n_0_MP^18 g^12 q_liq q_rai^78\nendequation","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"The default value of collision efficiency E_coll is set to 0.8 so that the resulting accretion rate is close to the empirical accretion rate in Smolarkiewicz and Grabowski 1996. Assuming a constant E_col is an approximation, see for example collision efficiency.","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"using CLIMA.Microphysics\nusing Plots\n\n# eq. 5b in Smolarkiewicz and Grabowski 1996\n# https://doi.org/10.1175/1520-0493(1996)124<0487:TTLSLM>2.0.CO;2\nfunction accretion_empirical(q_rai::DT, q_liq::DT, q_tot::DT) where {DT<:Real}\n    rr  = q_rai / (DT(1) - q_tot)\n    rl  = q_liq / (DT(1) - q_tot)\n    return DT(2.2) * rl * rr^DT(7/8)\nend\n\n# some example values\nq_rain_range = range(1e-8, stop=5e-3, length=100)\nρ_air, q_liq, q_tot = 1.2, 5e-4, 20e-3\n\nplot(q_rain_range * 1e3,  [conv_q_liq_to_q_rai_accr(q_liq, q_rai, ρ_air) for q_rai in q_rain_range], xlabel=\"q_rain [g/kg]\", ylabel=\"accretion rate [1/s]\", title=\"Accretion\", label=\"CLIMA\")\nplot!(q_rain_range * 1e3, [accretion_empirical(q_rai, q_liq, q_tot) for q_rai in q_rain_range], label=\"empirical\")\nsavefig(\"accretion_rate.svg\") # hide\nnothing # hide","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"(Image: )","category":"page"},{"location":"Atmos/Microphysics.html#Rain-evaporation-1","page":"Microphysics","title":"Rain evaporation","text":"","category":"section"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"Based on Maxwell 1971 the equation of growth of individual water drop is:","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"beginequation\n\nr fracdrdt = frac1rho_water\n                  left(fracq_vapq_vap^sat - 1 right)\n                  left(\n                    fracLKT left(fracLR_v T - 1 right) +\n                    fracR_v Tp_vap^sat D\n                  right)^-1\n                = frac1rho_water S(q_vap q_vap^sat)  G(T)\nendequation","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"q_vap^sat is the saturation vapor specific humidity,\nL is the latent heat of vaporization,\nK_thermo is the thermal conductivity of air,\nR_v is the gas constant of water vapor,\nD_vapor is the diffusivity of water vapor,\nS(q_vap q_vap^sat) = fracq_vapq_vap^sat - 1 is commonly labeled as supersaturation,\nG(T) = left(fracLKT left(fracLR_v T - 1 right) + fracR_v Tp_vap^sat D right)^-1 combines the effects of thermal conductivity and water diffusivity.","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"The rate of q_rai evaporation is:","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"beginequation\nleft fracd  q_raidt right_evap  =  int_0^infty frac1rho  4 pi  r  S(q_vap q_vap^sat)  G(T)  F(r)  n(r)  dr\nendequation","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"F(r) is the rain drop ventilation factor.","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"Following Seifert and Beheng 2006 eq. 24 the ventilation factor is defined as:","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"beginequation\nF(r) = a_vent + b_vent  N_Sc^13 N_Re(r)^12\nendequation","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"a_vent, b_vent are coefficients,\nN_Sc is the Schmidt number,\nN_Re is the Reynolds number of a falling rain drop.","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"The Schmidt number is assumed constant:","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"N_Sc = fracnu_airD_vapor","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"nu_air is the kinematic viscosity of air.","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"The Reynolds number of a rain drop is defined as:","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"N_Re = frac2  r  v_drop(r rho)nu_air = frac2 v_c(rho)  g^12  r^32nu_air","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"The final integral is:","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"beginequation\nleft fracd  q_raidt right_evap  =  4 pi S(q_vap q_vap^sat) fracn_0_MP G(T)rho\n                                                  int_0^infty left( a_vent r + b_vent N_Sc^13 (2 v_c(rho))^12 fracg^14nu_air^12 r^74 right) exp(-lambda_MP r) dr\nendequation","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"Integrating and eliminating lambda_MP using eq.(\\ref{eq:lambda}) results in:","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"beginequation\nleft fracd  q_raidt right_evap  = S(q_vap q_vap^sat) fracG(T) n_0_MP^12rho left( A q_rai^12 + B fracg^14n_0_MP^316 nu_air^12 q_rai^1116 right)\nendequation","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"A = (2 pi)^12 a_vent left( fracrhorho_water right)^12\nB = Gammaleft(frac114right) 2^716 pi^516 b_vent N_Sc^13 v_c(rho)^12 left( fracrhorho_water right)^1116","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"The values of a_vent and b_vent are chosen so that at q_tot = 15 gkg and T=288K the resulting rain evaporation rate is close to the empirical rain evaporation rate from Smolarkiewicz and Grabowski 1996.","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"using CLIMA.Microphysics\nusing CLIMA.MoistThermodynamics\nusing CLIMA.PlanetParameters\nusing Plots\n\n# eq. 5c in Smolarkiewicz and Grabowski 1996\n# https://doi.org/10.1175/1520-0493(1996)124<0487:TTLSLM>2.0.CO;2\nfunction rain_evap_empirical(q_rai::DT, q::PhasePartition, T::DT, p::DT, ρ::DT) where {DT<:Real}\n\n    q_sat  = q_vap_saturation(T, ρ, q)\n    q_vap  = q.tot - q.liq\n    rr     = q_rai / (DT(1) - q.tot)\n    rv_sat = q_sat / (DT(1) - q.tot)\n    S      = q_vap/q_sat - DT(1)\n\n    ag, bg = 5.4 * 1e2, 2.55 * 1e5\n    G = DT(1) / (ag + bg / p / rv_sat) / ρ\n\n    av, bv = 1.6, 124.9\n    F = av * (ρ/DT(1e3))^DT(0.525)  * rr^DT(0.525) + bv * (ρ/DT(1e3))^DT(0.7296) * rr^DT(0.7296)\n\n    return DT(1) / (DT(1) - q.tot) * S * F * G\nend\n\n# example values\nT, p = 273.15 + 15, 90000.\nϵ = 1. / molmass_ratio\np_sat = saturation_vapor_pressure(T, Liquid())\nq_sat = ϵ * p_sat / (p + p_sat * (ϵ - 1.))\nq_rain_range = range(1e-8, stop=5e-3, length=100)\nq_tot = 15e-3\nq_vap = 0.15 * q_sat\nq_ice = 0.\nq_liq = q_tot - q_vap - q_ice\nq = PhasePartition(q_tot, q_liq, q_ice)\nR = gas_constant_air(q)\nρ = p / R / T\n\nplot(q_rain_range * 1e3,  [conv_q_rai_to_q_vap(q_rai, q, T, p, ρ) for q_rai in q_rain_range], xlabel=\"q_rain [g/kg]\", ylabel=\"rain evaporation rate [1/s]\", title=\"Rain evaporation\", label=\"CLIMA\")\nplot!(q_rain_range * 1e3, [rain_evap_empirical(q_rai, q, T, p, ρ) for q_rai in q_rain_range], label=\"empirical\")\nsavefig(\"rain_evaporation_rate.svg\") # hide\nnothing # hide","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"(Image: )","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"CurrentModule = CLIMA.Microphysics","category":"page"},{"location":"Atmos/Microphysics.html#Functions-1","page":"Microphysics","title":"Functions","text":"","category":"section"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"terminal_velocity\nconv_q_vap_to_q_liq\nconv_q_liq_to_q_rai_acnv\nconv_q_liq_to_q_rai_accr\nconv_q_rai_to_q_vap","category":"page"},{"location":"Atmos/Microphysics.html#CLIMA.Microphysics.terminal_velocity","page":"Microphysics","title":"CLIMA.Microphysics.terminal_velocity","text":"terminal_velocity(q_rai, ρ)\n\nwhere:\n\nq_rai - rain water specific humidity\nρ     - density of air\n\nReturns the mass weighted average rain terminal velocity assuming Marshall Palmer 1948 distribution of rain drops.\n\n\n\n\n\n","category":"function"},{"location":"Atmos/Microphysics.html#CLIMA.Microphysics.conv_q_vap_to_q_liq","page":"Microphysics","title":"CLIMA.Microphysics.conv_q_vap_to_q_liq","text":"conv_q_vap_to_q_liq(q_sat, q)\n\nwhere:\n\nq_sat - PhasePartition at equilibrium\nq     - current PhasePartition\n\nReturns the q_liq tendency due to condensation/evaporation. The tendency is obtained assuming a relaxation to equilibrium with constant timescale.\n\n\n\n\n\n","category":"function"},{"location":"Atmos/Microphysics.html#CLIMA.Microphysics.conv_q_liq_to_q_rai_acnv","page":"Microphysics","title":"CLIMA.Microphysics.conv_q_liq_to_q_rai_acnv","text":"conv_q_liq_to_q_rai_acnv(q_liq)\n\nwhere:\n\nq_liq - is the liquid water specific humidity\n\nReturns the q_rai tendency due to collisions between cloud droplets (autoconversion) parametrized following Kessler 1995.\n\n\n\n\n\n","category":"function"},{"location":"Atmos/Microphysics.html#CLIMA.Microphysics.conv_q_liq_to_q_rai_accr","page":"Microphysics","title":"CLIMA.Microphysics.conv_q_liq_to_q_rai_accr","text":"conv_q_liq_to_q_rai_accr(q_liq, q_rai, ρ)\n\nwhere:\n\nq_liq - is the liquid water specific humidity\nq_rai - is the rain water specific humidity\nρ - is the density of air\n\nReturns the q_rai tendency due to collisions between cloud droplets and rain drops (accretion) parametrized following Kessler 1995.\n\n\n\n\n\n","category":"function"},{"location":"Atmos/Microphysics.html#CLIMA.Microphysics.conv_q_rai_to_q_vap","page":"Microphysics","title":"CLIMA.Microphysics.conv_q_rai_to_q_vap","text":"conv_q_rai_to_q_vap(q_rai, q, T, p, ρ)\n\nwhere:\n\nq_rai - rain water specific humidity\nq - current PhasePartition\nT - temperature\np - pressure\nρ - air density\n\nReturns the q_rai tendency due to rain evaporation. Parameterized following Smolarkiewicz and Grabowski 1996.\n\n\n\n\n\n","category":"function"},{"location":"Atmos/Microphysics.html#References-1","page":"Microphysics","title":"References","text":"","category":"section"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"@article{GrabowskiandSmolarkiewicz_1996, author = {Grabowski, Wojciech W. and Smolarkiewicz, Piotr K.}, title = {Two-Time-Level Semi-Lagrangian Modeling of Precipitating Clouds}, journal = {Monthly Weather Review}, volume = {124}, number = {3}, pages = {487-497}, year = {1996}, doi = {10.1175/1520-0493(1996)124<0487:TTLSLM>2.0.CO;2}}","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"@article{Kessler_1995, author = {Kessler, E.}, title = {On the continuity and distribution of water substance in atmospheric circulations}, journal = {Atmospheric Research}, volume = {38}, number = {1}, pages = {109 - 145}, year = {1995}, doi = {10.1016/0169-8095(94)00090-Z}}","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"@book{Mason_1971, author = {Mason, B. J.}, title = {The Physics of Clouds}, publisher = {Oxford Univ. Press}, year = {1971}}","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"@article{MarshallandPalmer_1948, author = {Marshall, J. S. and Palmer, W. Mc K.}, title = {The distribution of raindrops with size}, journal = {Journal of Meteorology}, volume = {5}, number = {4}, pages = {165-166}, year = {1948}, doi = {10.1175/1520-0469(1948)005<0165:TDORWS>2.0.CO;2}}","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"@article{OguraandTakahashi_1971, author = {Oqura, Yoshimitsu and Takahashi, Tsutomu}, title = {Numerical simulation of the life cycle of a thunderstorm cell}, journal = {Monthly Weather Review}, volume = {99}, number = {12}, pages = {895-911}, year = {1971}, doi = {10.1175/1520-0493(1971)099<0895:NSOTLC>2.3.CO;2}}","category":"page"},{"location":"Atmos/Microphysics.html#","page":"Microphysics","title":"Microphysics","text":"@article{SeifertandBeheng_2006, author={Seifert, A. and Beheng, K. D.}, title={A two-moment cloud microphysics parameterization for mixed-phase clouds. Part 1: Model description}, journal={Meteorology and Atmospheric Physics}, year={2006}, volume={92}, number={1}, pages={45–66}, doi={10.1007/s00703-005-0112-4}}","category":"page"},{"location":"DGmethods_old.html#DGmethods_old-1","page":"DGmethods_old","title":"DGmethods_old","text":"","category":"section"},{"location":"DGmethods_old.html#","page":"DGmethods_old","title":"DGmethods_old","text":"CurrentModule = CLIMA","category":"page"},{"location":"DGmethods_old.html#SpaceMethods-1","page":"DGmethods_old","title":"SpaceMethods","text":"","category":"section"},{"location":"DGmethods_old.html#","page":"DGmethods_old","title":"DGmethods_old","text":"Set of abstract types for spatial discretizations","category":"page"},{"location":"DGmethods_old.html#Types-1","page":"DGmethods_old","title":"Types","text":"","category":"section"},{"location":"DGmethods_old.html#","page":"DGmethods_old","title":"DGmethods_old","text":"SpaceMethods.AbstractSpaceMethod\nSpaceMethods.AbstractDGMethod","category":"page"},{"location":"DGmethods_old.html#CLIMA.SpaceMethods.AbstractSpaceMethod","page":"DGmethods_old","title":"CLIMA.SpaceMethods.AbstractSpaceMethod","text":"AbstractSpaceMethod\n\nSupertype for spatial discretizations\n\n\n\n\n\n","category":"type"},{"location":"DGmethods_old.html#CLIMA.SpaceMethods.AbstractDGMethod","page":"DGmethods_old","title":"CLIMA.SpaceMethods.AbstractDGMethod","text":"AbstractDGMethod <: AbstractSpaceMethod\n\nSupertype for discontinuous Galerkin spatial discretizations\n\n\n\n\n\n","category":"type"},{"location":"DGmethods_old.html#Functions-1","page":"DGmethods_old","title":"Functions","text":"","category":"section"},{"location":"DGmethods_old.html#","page":"DGmethods_old","title":"DGmethods_old","text":"SpaceMethods.odefun!","category":"page"},{"location":"DGmethods_old.html#CLIMA.SpaceMethods.odefun!","page":"DGmethods_old","title":"CLIMA.SpaceMethods.odefun!","text":"odefun!(disc::AbstractSpaceMethod, dQ, Q, t; increment)\n\nEvaluates the right-hand side of the spatial discretization defined by disc at time t with state Q. The result is either added into dQ if increment is true or stored in dQ if it is false. Namely, the semi-discretization is of the form dotQ = F(Q t) and after the call dQ += F(Q, t) if increment == true or dQ = F(Q, t) if increment == false\n\nnote: Note\nThere is no generic implementation of this function. This must be implemented for each subtype of AbstractSpaceMethod\n\n\n\n\n\n","category":"function"},{"location":"DGmethods_old.html#DGBalanceLawDiscretizations-1","page":"DGmethods_old","title":"DGBalanceLawDiscretizations","text":"","category":"section"},{"location":"DGmethods_old.html#","page":"DGmethods_old","title":"DGmethods_old","text":"DGBalanceLawDiscretizations","category":"page"},{"location":"DGmethods_old.html#CLIMA.DGBalanceLawDiscretizations","page":"DGmethods_old","title":"CLIMA.DGBalanceLawDiscretizations","text":"DG Balance Law Discretizations module. Attempts to provide a reasonable implementation of a discontinuous Galerkin method (in weak form) on tensor product quadrilateral (2D) and hexahedral (3D) elements for balance laws of the form\n\nq_t + Σ_i=1d F_ii = s\n\nwhere q is the state vector, F is the flux function, and s is the source function. F includes both the \"inviscid\" and \"viscous\" fluxes. Note that this is a space only discretization, time must be advanced using some ordinary differential equations methods; see ODESolvers.\n\nThe flux function F_{i} is taken to be of the form:\n\nF_i = F_i(q σ a)\nσ = H(q G(q a) a)\n\nwhere a is a set of parameters and viscous terms enter through σ\n\nThe source term is of the form:\n\ns = s(q a)\n\nIn the code and docs the following terminology is used:\n\nq is referred to as the state\nσ is the viscous state\na is the auxiliary state\nF is the physical flux\nH is the viscous transform\nG is the gradient transform\n\nMuch of the notation used in this module follows Hesthaven and Warburton (2008).\n\nnote: Note\nCurrently all the functions take the same parameters and the gradient transform can take a user-specified subset of the state vector.\n\nreferences: References\n@BOOK{HesthavenWarburton2008,\n  title = {Nodal Discontinuous {G}alerkin Methods: {A}lgorithms, Analysis,\n           and Applications},\n  publisher = {Springer-Verlag New York},\n  year = {2008},\n  author = {Hesthaven, Jan S. and Warburton, Tim},\n  volume = {54},\n  series = {Texts in Applied Mathematics},\n  doi = {10.1007/978-0-387-72067-8}\n}\n\n\n\n\n\n","category":"module"},{"location":"DGmethods_old.html#Types-2","page":"DGmethods_old","title":"Types","text":"","category":"section"},{"location":"DGmethods_old.html#","page":"DGmethods_old","title":"DGmethods_old","text":"DGBalanceLawDiscretizations.DGBalanceLaw","category":"page"},{"location":"DGmethods_old.html#CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw","page":"DGmethods_old","title":"CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw","text":"DGBalanceLaw <: AbstractDGMethod\n\nThis contains the necessary information for a discontinuous Galerkin method for balance laws.\n\nSee also: Outer constructor DGBalanceLaw\n\nFields\n\ngrid\ncomputational grid / mesh\nnstate\nnumber of state\nflux!\nphysical flux function\nnumerical_flux!\nnumerical flux function\nnumerical_boundary_flux!\nnumerical boundary flux function\nQvisc\nstorage for the viscous state\nnumber_gradient_states\nnumber of out states for gradient_transform!\nnumber_viscous_states\nnumber of out states for the viscous_transform!\ngradient_transform!\ntransform from state to variables to take gradient of\nviscous_transform!\ntransform from Q and gradient state to viscous states\nviscous_penalty!\npenalty for the viscous state computation\nviscous_boundary_penalty!\nboundary penalty for the viscous state computation (e.g., Dirichlet)\nauxstate\nauxiliary state array\nsource!\nsource function\npreodefun!\ncallback function for before the odefun!\n\n\n\n\n\n","category":"type"},{"location":"DGmethods_old.html#Constructor-1","page":"DGmethods_old","title":"Constructor","text":"","category":"section"},{"location":"DGmethods_old.html#","page":"DGmethods_old","title":"DGmethods_old","text":"DGBalanceLawDiscretizations.DGBalanceLaw(;)","category":"page"},{"location":"DGmethods_old.html#CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw-Tuple{}","page":"DGmethods_old","title":"CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw","text":"DGBalanceLaw(;grid::DiscontinuousSpectralElementGrid,\n             length_state_vector,\n             flux!,\n             numerical_flux!,\n             numerical_boundary_flux! = nothing,\n             number_gradient_states = 0,\n             number_viscous_states = 0,\n             gradient_transform! = nothing,\n             viscous_transform! = nothing,\n             viscous_penalty! = nothing,\n             viscous_boundary_penalty! = nothing,\n             auxiliary_state_length = 0,\n             auxiliary_state_initialization! = nothing,\n             source! = nothing,\n             preodefun! = nothing)\n\nConstructs a DGBalanceLaw spatial discretization type for the physics defined by flux! and source!. The computational domain is defined by grid. The number of state variables is defined by length_state_vector. The user may also specify an auxiliary state which will be unpacked by the compute kernel passed on to the user-defined flux and numerical flux functions. The source function source! is optional.\n\nThe flux function is called with data from a degree of freedom (DOF) as\n\nflux!(F, Q, V, aux, t)\n\nwhere\n\nF is an MArray of size (dim, length_state_vector) to be filled (note that this is uninitialized so the user must set to zero if is this desired)\nQ is the state to evaluate (MArray)\nV is the viscous state to evaluate (MArray)\naux is the user-defined auxiliary state (MArray)\nt is the current simulation time\n\nWarning: Modifications to Q or aux may cause side effects and should be avoided.\n\nThe numerical flux function is called with data from two DOFs as\n\nnumerical_flux!(F, nM, QM, VM, auxM, QP, VP, auxP, t)\n\nwhere\n\nF is an MVector of length length_state_vector to be filled with the numerical flux across the face (note that this is uninitialized so user must set to zero if is this desired)\nnM is the unit outward normal to the face with respect to the minus side (MVector of length 3)\nQM and QP are the minus and plus side states (MArray)\nVM and VP are the minus and plus viscous side states (MArray)\nauxM and auxP are the auxiliary states (MArray)\nt is the current simulation time\n\nWarning: Modifications to nM, QM, auxM, QP, or auxP may cause side effects and should be avoided.\n\nIf grid.topology has a boundary then the function numerical_boundary_flux! must be specified. This function is called with the data from the neighbouring DOF as\n\nnumerical_boundary_flux!(F, nM, QM, VM, auxM, QP, VP, auxP, bctype, t)\n\nwhere\n\nF is an MArray of size (dim, length_state_vector) to be filled with the numerical flux across the face (note that this is uninitialized so user must set to zero is this desired)\nnM is the unit outward normal to the face with respect to the minus side (MVector of length 3)\nQM and QP are the minus and plus side states (MArray)\nVM and VP are the minus and plus viscous side states (MArray)\nauxM and auxP are the auxiliary states (MArray)\nbctype is the boundary condition flag for the connected face and element of  grid.elemtobndy\nt is the current simulation time\n\nNote: QP and auxP are filled with values based on degrees of freedom referenced in grid.vmapP; QP and auxP may be modified by the calling function.\n\nWarning: Modifications to nM, QM, or auxM may cause side effects and should be avoided.\n\nIf present the source function is called with data from a DOF as\n\nsource!(S, Q, aux, t)\n\nwhere S is an MVector of length length_state_vector to be filled; other arguments are the same as flux! and the same warning concerning Q and aux applies.\n\nWhen auxiliary_state_initialization! !== nothing then this is called on the auxiliary state (assuming auxiliary_state_length > 0) as\n\nauxiliary_state_initialization!(aux, x1, x2, x3)\n\nwhere aux is an MArray to fill with the auxiliary state for a DOF located at Cartesian coordinate locations (x1, x2, x3); see also grad_auxiliary_state! allows the user to take the gradient of a field stored in the auxiliary state.\n\nWhen viscous terms are needed, the user must specify values for the following keyword arguments:\n\nnumber_gradient_states (Int)\nnumber_viscous_states (Int)\ngradient_transform! (Function)\nviscous_transform! (Function)\nviscous_penalty! (Function)\nviscous_boundary_penalty! (Function); only required if the topology has a boundary\n\nThe function gradient_transform! is the implementation of the function G in the module docs; see DGBalanceLawDiscretizations.  It is called on each DOF as:\n\ngradient_transform!(G, Q, aux, t)\n\nwhere G is an MVector of length number_gradient_states to be filled, Q is an MVector containing the states, aux is the full auxiliary state at the DOF, and t is the simulation time.data\n\nThe function viscous_transform! is the implementation of the function H in the module docs; see DGBalanceLawDiscretizations. It transforms the gradient G and q into the viscous state σ. It is called on each DOF as:\n\nviscous_transform!(V, gradG, Q, aux, t)\n\nwhere V is an MVector of length number_viscous_states to be filled, gradG is an MMatrix containing the DG-gradient of G, Q is an MVector containing the states, aux is the full auxiliary state at the DOF, and t is the simulation time. Note that V is a vector not a matrix so that minimal storage can be used if symmetry can be exploited.\n\nThe function viscous_penalty! is the penalty terms to be used for the DG-gradient calculation. It is called with data from two neighbouring degrees of freedom as\n\nviscous_penalty!(V, nM, GM, QM, auxM, GP, QP, auxP, t)\n\nwhere:\n\nV is an MVector of length number_viscous_states to be filled with the numerical penalty across the face; see below.\nnM is the unit outward normal to the face with respect to the minus side (MVector of length 3)\nGM and GP are the minus and plus evaluation of gradient_transform! on either side of the face\nQM and QP are the minus and plus side states (MArray)\nauxM and auxP are the auxiliary states (MArray)\nt is the current simulation time\n\nThe viscous penalty function should compute on the faces\n\nn^- cdot H^* - n^- cdot H^-\n\nwhere n^- cdot H^* is the \"numerical-flux\" for the viscous state computation and H^- is the value of viscous_transform! evaluated on the minus side with n^- cdot G^- as an argument.\n\nIf grid.topology has a boundary then the function viscous_boundary_penalty! must be specified. This function is called with the data from the neighbouring DOF as\n\nviscous_boundary_penalty!(V, nM, GM, QM, auxM, GP, QP, auxP, bctype, t)\n\nwhere the required behaviour mimics that of viscous_penalty! and numerical_boundary_flux!.\n\nIf preodefun! is called right before the rest of the ODE function, with the main purpose to allow the user to populate/modify the auxiliary state disc.auxstate to be consistent with the current time t and solution vector Q\n\npreodefun!(disc, Q, t)\n\nwhere disc is the DGBalanceLaw structure and Q is the current state being used to evaluate the ODE function.\n\nnote: notes on `preodefun!`\nUnlike the other callbacks, this function is not called at the device (or kernel) level but the host level.MPI communication of Q occurs after the odefun! and no MPI communication of auxstate is performed (if this is needed we will need to determine a way to handle it in order to overlap communication and computation as well only comm update fields).\n\nnote: Note\nIf (x1, x2, x3), or data derived from this such as spherical coordinates, is needed in the flux or source the user is responsible to storing this in the auxiliary state\n\n\n\n\n\n","category":"method"},{"location":"DGmethods_old.html#Functions-2","page":"DGmethods_old","title":"Functions","text":"","category":"section"},{"location":"DGmethods_old.html#","page":"DGmethods_old","title":"DGmethods_old","text":"DGBalanceLawDiscretizations.grad_auxiliary_state!\nDGBalanceLawDiscretizations.indefinite_stack_integral!\nDGBalanceLawDiscretizations.reverse_indefinite_stack_integral!\nDGBalanceLawDiscretizations.dof_iteration!","category":"page"},{"location":"DGmethods_old.html#CLIMA.DGBalanceLawDiscretizations.grad_auxiliary_state!","page":"DGmethods_old","title":"CLIMA.DGBalanceLawDiscretizations.grad_auxiliary_state!","text":"grad_auxiliary_state!(disc, i, (ix1, ix2, ix3)\n\nComputes the gradient of a the field i of the constant auxiliary state of disc and stores the x1, x2, x3 compoment in fields ix1, ix2, ix3 of constant auxiliary state.\n\nnote: Note\nThis only computes the element gradient not a DG gradient. If your constant auxiliary state is discontinuous this may or may not be what you want!\n\n\n\n\n\n","category":"function"},{"location":"DGmethods_old.html#CLIMA.DGBalanceLawDiscretizations.indefinite_stack_integral!","page":"DGmethods_old","title":"CLIMA.DGBalanceLawDiscretizations.indefinite_stack_integral!","text":"indefinite_stack_integral!(disc, f, Q, out_states, [P=disc.auxstate])\n\nComputes an indefinite line integral along the trailing dimension (ξ3 in 3-D and ξ2 in 2-D) up an element stack using state Q\n\n_ζ_0^ζ f(q aux t)\n\nand stores the result of the integral in field of P indicated by out_states\n\nThe syntax of the integral kernel is:\n\nf(F, Q, aux)\n\nwhere F is an MVector of length length(out_states), Q and aux are the MVectors for the state and auxiliary state at a single degree of freedom. The function is responsible for filling F.\n\nRequires the isstacked(disc.grid.topology) == true\n\n\n\n\n\n","category":"function"},{"location":"DGmethods_old.html#CLIMA.DGBalanceLawDiscretizations.reverse_indefinite_stack_integral!","page":"DGmethods_old","title":"CLIMA.DGBalanceLawDiscretizations.reverse_indefinite_stack_integral!","text":"reverse_indefinite_stack_integral!(disc, oustate, instate,\n                                   [P=disc.auxstate])\n\nreverse previously computed indefinite integral(s) computed with indefinite_stack_integral! to be\n\n_ζ^ζ_max f(q aux t)\n\nThe states instate[i] is reverse and stored in instate[i].\n\nRequires the isstacked(disc.grid.topology) == true\n\n\n\n\n\n","category":"function"},{"location":"DGmethods_old.html#CLIMA.DGBalanceLawDiscretizations.dof_iteration!","page":"DGmethods_old","title":"CLIMA.DGBalanceLawDiscretizations.dof_iteration!","text":"dof_iteration!(dof_fun!::Function, R::MPIStateArray, disc::DGBalanceLaw,\n               Q::MPIStateArray)\n\nIterate over each dof to fill R using the dof_fun!. The syntax of the dof_fun! is\n\ndof_fun!(l_R, l_Q, l_Qvisc, l_aux)\n\nwhere l_R, l_Q, l_Qvisc, and l_aux are of type MArray filled initially with the values at a single degree of freedom. After the call the values in l_R will be written back to the degree of freedom of R.\n\n\n\n\n\n","category":"function"},{"location":"DGmethods_old.html#Pirated-Type-Functions-1","page":"DGmethods_old","title":"Pirated Type Functions","text":"","category":"section"},{"location":"DGmethods_old.html#","page":"DGmethods_old","title":"DGmethods_old","text":"CLIMA.MPIStateArrays.MPIStateArray(::DGBalanceLawDiscretizations.DGBalanceLaw)\nCLIMA.MPIStateArrays.MPIStateArray(::DGBalanceLawDiscretizations.DGBalanceLaw, ::Function)\nCLIMA.SpaceMethods.odefun!(::DGBalanceLawDiscretizations.DGBalanceLaw, dQ, Q, t)","category":"page"},{"location":"DGmethods_old.html#CLIMA.MPIStateArrays.MPIStateArray-Tuple{CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw}","page":"DGmethods_old","title":"CLIMA.MPIStateArrays.MPIStateArray","text":"MPIStateArray(disc::DGBalanceLaw; nstate=disc.nstate, commtag=888)\n\nGiven a discretization disc constructs an MPIStateArrays for holding a solution state. The optional 'nstate' arguments allows the user to specify a specific number of states. The optional commtag allows the user to set the tag to use for communication with this MPIStateArray.\n\n\n\n\n\n","category":"method"},{"location":"DGmethods_old.html#CLIMA.MPIStateArrays.MPIStateArray-Tuple{CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw,Function}","page":"DGmethods_old","title":"CLIMA.MPIStateArrays.MPIStateArray","text":"MPIStateArray(disc::DGBalanceLaw, initialization!::Function; commtag=888)\n\nGiven a discretization disc constructs an MPIStateArrays for holding a solution state. The optional commtag allows the user to set the tag to use for communication with this MPIStateArray.\n\nAfter allocation the MPIStateArray is initialized using the function initialization! which will be called as:\n\ninitialization!(Q, x1, x2, x3, aux)\n\nwhere Q is an MArray with the solution state at a single degree of freedom (DOF) to initialize and (x1, x2, x3) is the coordinate point for the allocation.  The auxiliary data the values at the DOF are passed through as an MArray through the aux argument; if disc does not have auxiliary data then the length of the MArray will be zero.\n\nnote: Note\nQ is undef at start the function (i.e., not initialized to zero)\n\nnote: Note\nModifications of the aux array will be discarded.\n\ntodo: Todo\nRemove host and device data transfers.\n\n\n\n\n\n","category":"method"},{"location":"DGmethods_old.html#Kernels-1","page":"DGmethods_old","title":"Kernels","text":"","category":"section"},{"location":"DGmethods_old.html#","page":"DGmethods_old","title":"DGmethods_old","text":"DGBalanceLawDiscretizations.volumerhs!\nDGBalanceLawDiscretizations.facerhs!\nDGBalanceLawDiscretizations.volumeviscterms!\nDGBalanceLawDiscretizations.faceviscterms!\nDGBalanceLawDiscretizations.initauxstate!\nDGBalanceLawDiscretizations.initauxstate!\nDGBalanceLawDiscretizations.elem_grad_field!\nDGBalanceLawDiscretizations.knl_dof_iteration!\nDGBalanceLawDiscretizations.knl_indefinite_stack_integral!\nDGBalanceLawDiscretizations.knl_reverse_indefinite_stack_integral!","category":"page"},{"location":"DGmethods_old.html#CLIMA.DGBalanceLawDiscretizations.volumerhs!","page":"DGmethods_old","title":"CLIMA.DGBalanceLawDiscretizations.volumerhs!","text":"volumerhs!(::Val{dim}, ::Val{N}, ::Val{nstate}, ::Val{nviscstate},\n           ::Val{nauxstate}, flux!, source!, rhs, Q, Qvisc, auxstate,\n           vgeo, t, D, elems) where {dim, N, nstate, nviscstate,\n\nComputational kernel: Evaluate the volume integrals on right-hand side of a DGBalanceLaw semi-discretization.\n\nSee odefun! for usage.\n\n\n\n\n\n","category":"function"},{"location":"DGmethods_old.html#CLIMA.DGBalanceLawDiscretizations.facerhs!","page":"DGmethods_old","title":"CLIMA.DGBalanceLawDiscretizations.facerhs!","text":"facerhs!(::Val{dim}, ::Val{N}, ::Val{nstate}, ::Val{nviscstate},\n         ::Val{nauxstate}, numerical_flux!,\n         numerical_boundary_flux!, rhs, Q, Qvisc, auxstate,\n         vgeo, sgeo, t, vmapM, vmapP, elemtobndy,\n         elems) where {dim, N, nstate, nviscstate, nauxstate}\n\nComputational kernel: Evaluate the surface integrals on right-hand side of a DGBalanceLaw semi-discretization.\n\nSee odefun! for usage.\n\n\n\n\n\n","category":"function"},{"location":"DGmethods_old.html#CLIMA.DGBalanceLawDiscretizations.initauxstate!","page":"DGmethods_old","title":"CLIMA.DGBalanceLawDiscretizations.initauxstate!","text":"initauxstate!(::Val{dim}, ::Val{N}, ::Val{nauxstate}, auxstatefun!,\n              auxstate, vgeo, elems) where {dim, N, nauxstate}\n\nComputational kernel: Initialize the auxiliary state\n\nSee DGBalanceLaw for usage.\n\n\n\n\n\n","category":"function"},{"location":"DGmethods_old.html#CLIMA.DGBalanceLawDiscretizations.elem_grad_field!","page":"DGmethods_old","title":"CLIMA.DGBalanceLawDiscretizations.elem_grad_field!","text":"elem_grad_field!(::Val{dim}, ::Val{N}, ::Val{nstate}, Q, vgeo, D, elems, s,\n                 sx, sy, sz) where {dim, N, nstate}\n\nComputational kernel: Compute the element gradient of state s of Q and store it in sx, sy, and sz of Q.\n\nwarning: Warning\nThis does not compute a DG gradient, but only over the element. If Q_s is discontinuous you may want to consider another approach.\n\n\n\n\n\n","category":"function"},{"location":"DGmethods_old.html#CLIMA.DGBalanceLawDiscretizations.knl_dof_iteration!","page":"DGmethods_old","title":"CLIMA.DGBalanceLawDiscretizations.knl_dof_iteration!","text":"knl_dof_iteration!(::Val{dim}, ::Val{N}, ::Val{nRstate}, ::Val{nstate},\n                   ::Val{nviscstate}, ::Val{nauxstate}, dof_fun!, R, Q,\n                   QV, auxstate, elems) where {dim, N, nRstate, nstate,\n                                               nviscstate, nauxstate}\n\nComputational kernel: fill postprocessing array\n\nSee DGBalanceLaw for usage.\n\n\n\n\n\n","category":"function"},{"location":"DGmethods_old.html#CLIMA.DGBalanceLawDiscretizations.knl_indefinite_stack_integral!","page":"DGmethods_old","title":"CLIMA.DGBalanceLawDiscretizations.knl_indefinite_stack_integral!","text":"knl_indefinite_stack_integral!(::Val{dim}, ::Val{N}, ::Val{nstate},\n                                        ::Val{nauxstate}, ::Val{nvertelem},\n                                        int_knl!, Q, auxstate, vgeo, Imat,\n                                        elems, ::Val{outstate}\n                                       ) where {dim, N, nstate, nauxstate,\n                                                outstate, nvertelem}\n\nComputational kernel: compute indefinite integral along the vertical stack\n\nSee DGBalanceLaw for usage.\n\n\n\n\n\n","category":"function"},{"location":"DGmethods_old.html#DGBalanceLawDiscretizations.NumericalFluxes_old-1","page":"DGmethods_old","title":"DGBalanceLawDiscretizations.NumericalFluxes_old","text":"","category":"section"},{"location":"DGmethods_old.html#","page":"DGmethods_old","title":"DGmethods_old","text":"DGBalanceLawDiscretizations.NumericalFluxes_old.rusanov!\nDGBalanceLawDiscretizations.NumericalFluxes_old.rusanov_boundary_flux!","category":"page"},{"location":"Common/MoistThermodynamics.html#MoistThermodynamics-Module-1","page":"MoistThermodynamics","title":"MoistThermodynamics Module","text":"","category":"section"},{"location":"Common/MoistThermodynamics.html#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"The MoistThermodynamics module provides all thermodynamic functions needed for the atmosphere and functions shared across model components. The functions are general for a moist atmosphere that includes suspended cloud condensate in the working fluid; the special case of a dry atmosphere is obtained for zero specific humidities (or simply by omitting the optional specific humidity arguments in the functions that are needed for a dry atmosphere). The general formulation assumes that there are tracers for the total water specific humidity q_tot, the liquid specific humidity q_liq, and the ice specific humidity q_ice to characterize the thermodynamic state and composition of moist air.","category":"page"},{"location":"Common/MoistThermodynamics.html#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"There are several types of functions:","category":"page"},{"location":"Common/MoistThermodynamics.html#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"Equation of state (ideal gas law):\nair_pressure\nSpecific gas constant and isobaric and isochoric specific heats of moist air:\ngas_constant_air\ncp_m\ncv_m\nSpecific latent heats of vaporization, fusion, and sublimation:\nlatent_heat_vapor\nlatent_heat_fusion\nlatent_heat_sublim\nSaturation vapor pressure and specific humidity over liquid and ice:\nsat_vapor_press_liquid\nsat_vapor_press_ice\nsat_shum\nFunctions computing energies and inverting them to obtain temperatures\ntotal_energy\ninternal_energy\nair_temperature\nFunctions to compute temperatures and partitioning of water into phases in thermodynamic equilibrium (when Gibbs' phase rule implies that the entire thermodynamic state of moist air, including the liquid and ice specific humidities, can be calculated from the 3 thermodynamic state variables, such as energy, pressure, and total specific humidity)\nliquid_fraction_equil (fraction of condensate that is liquid)\nsaturation_adjustment (compute temperature from energy, density, and total specific humidity)\nAuxiliary functions for diagnostic purposes, e.g., other thermodynamic quantities\nliquid_ice_pottemp (liquid-ice potential temperature)","category":"page"},{"location":"Common/MoistThermodynamics.html#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"A moist dynamical core that assumes equilibrium thermodynamics can be obtained from a dry dynamical core with total energy as a prognostic variable by including a tracer for the total specific humidity q_tot, using the functions, e.g., for the energies in the module, and computing the temperature T and the liquid and ice specific humidities (q.liq and q.ice) from the internal energy e_int by saturation adjustment:","category":"page"},{"location":"Common/MoistThermodynamics.html#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"T = saturation_adjustment(e_int, ρ, q_tot);\nq = PhasePartition_equil(T, ρ, q_tot);","category":"page"},{"location":"Common/MoistThermodynamics.html#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"here, ρ is the density of the moist air, and the internal energy e_int = e_tot - e_kin - geopotential is the total energy e_tot minus kinetic energy e_kin and potential energy geopotential (all energies per unit mass). No changes to the \"right-hand sides\" of the dynamical equations are needed for a moist dynamical core that supports clouds, as long as they do not precipitate. Additional source-sink terms arise from precipitation.","category":"page"},{"location":"Common/MoistThermodynamics.html#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"Schematically, the workflow in such a core would look as follows:","category":"page"},{"location":"Common/MoistThermodynamics.html#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"# initialize\ngeopotential = grav * z\nq_tot          = ...\nρ            = ...\n\n(u, v, w)    = ...\ne_kin           = 0.5 * (u^2 + v^2 + w^2)\n\ne_tot        = total_energy(e_kin, geopotential, T, q_tot)\n\ndo timestep   # timestepping loop\n\n  # advance dynamical variables by a timestep (temperature typically\n  # appears in terms on the rhs, such as radiative transfer)\n  advance(u, v, w, ρ, e_tot, q_tot)\n\n  # compute internal energy from dynamic variables\n  e_int = e_tot - 0.5 * (u^2 + v^2 + w^2) - geopotential\n\n  # compute temperature, pressure and condensate specific humidities,\n  T = saturation_adjustment(e_int, ρ, q_tot);\n  q = PhasePartition_equil(T, ρ, q_tot);\n  p = air_pressure(T, ρ, q)\n\nend","category":"page"},{"location":"Common/MoistThermodynamics.html#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"For a dynamical core that additionally uses the liquid and ice specific humidities q.liq and q.ice as prognostic variables, and thus explicitly allows the presence of non-equilibrium phases such as supercooled water, the saturation adjustment in the above workflow is replaced by a direct calculation of temperature and pressure:","category":"page"},{"location":"Common/MoistThermodynamics.html#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"T = air_temperature(e_int, q)\np = air_pressure(T, ρ, q)","category":"page"},{"location":"Common/MoistThermodynamics.html#Functions-1","page":"MoistThermodynamics","title":"Functions","text":"","category":"section"},{"location":"Common/MoistThermodynamics.html#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"CurrentModule = CLIMA.MoistThermodynamics","category":"page"},{"location":"Common/MoistThermodynamics.html#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"PhasePartition\nPhasePartition_equil\nThermodynamicState\nPhaseDry\nPhaseEquil\nPhaseNonEquil\nTemperatureSHumEquil\nLiquidIcePotTempSHumEquil\nLiquidIcePotTempSHumNonEquil\nLiquidIcePotTempSHumNonEquil_given_pressure","category":"page"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.PhasePartition","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.PhasePartition","text":"PhasePartition\n\nRepresents the mass fractions of the moist air mixture.\n\nConstructors\n\nPhasePartition(q_tot::Real[, q_liq::Real[, q_ice::Real]])\nPhasePartition(ts::ThermodynamicState)\n\nSee also PhasePartition_equil\n\nFields\n\ntot\ntotal specific humidity\nliq\nliquid water specific humidity (default: 0)\nice\nice specific humidity (default: 0)\n\n\n\n\n\n","category":"type"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.PhasePartition_equil","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.PhasePartition_equil","text":"PhasePartition_equil(T, ρ, q_tot)\n\nPartition the phases in equilibrium, returning a PhasePartition object using the liquid_fraction_equil function where\n\nT temperature\nρ (moist-)air density\nq_tot total specific humidity\n\nThe residual q.tot - q.liq - q.ice is the vapor specific humidity, where q is the resulting PhasePartition.\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.ThermodynamicState","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.ThermodynamicState","text":"ThermodynamicState{FT}\n\nA thermodynamic state, which can be initialized for various thermodynamic formulations (via its sub-types). All ThermodynamicState's have access to functions to compute all other thermodynamic properties.\n\n\n\n\n\n","category":"type"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.PhaseDry","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.PhaseDry","text":"PhaseDry{FT} <: ThermodynamicState\n\nA dry thermodynamic state (q_tot = 0).\n\nConstructors\n\nPhaseDry(e_int, ρ)\n\nFields\n\ne_int\ninternal energy\nρ\ndensity of dry air\n\n\n\n\n\n","category":"type"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.PhaseEquil","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.PhaseEquil","text":"PhaseEquil{FT} <: ThermodynamicState\n\nA thermodynamic state assuming thermodynamic equilibrium (therefore, saturation adjustment may be needed).\n\nConstructors\n\nPhaseEquil(e_int, q_tot, ρ)\n\nFields\n\ne_int\ninternal energy\nq_tot\ntotal specific humidity\nρ\ndensity of air (potentially moist)\nT\ntemperature: computed via saturation_adjustment\n\n\n\n\n\n","category":"type"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.PhaseNonEquil","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.PhaseNonEquil","text":"PhaseNonEquil{FT} <: ThermodynamicState\n\nA thermodynamic state assuming thermodynamic non-equilibrium (therefore, temperature can be computed directly).\n\nConstructors\n\nPhaseNonEquil(e_int, q::PhasePartition, ρ)\n\nFields\n\ne_int\ninternal energy\nq\nphase partition\nρ\ndensity of air (potentially moist)\n\n\n\n\n\n","category":"type"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.TemperatureSHumEquil","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.TemperatureSHumEquil","text":"TemperatureSHumEquil(T, q_tot, p)\n\nConstructs a PhaseEquil thermodynamic state from temperature.\n\nT - temperature\nq_tot - total specific humidity\np - pressure\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.LiquidIcePotTempSHumEquil","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.LiquidIcePotTempSHumEquil","text":"LiquidIcePotTempSHumEquil(θ_liq_ice, q_tot, ρ)\n\nConstructs a PhaseEquil thermodynamic state from:\n\nθ_liq_ice - liquid-ice potential temperature\nq_tot - total specific humidity\nρ - density\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.LiquidIcePotTempSHumNonEquil","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.LiquidIcePotTempSHumNonEquil","text":"LiquidIcePotTempSHumNonEquil(θ_liq_ice, q_pt, ρ)\n\nConstructs a PhaseNonEquil thermodynamic state from:\n\nθ_liq_ice - liquid-ice potential temperature\nq_pt - phase partition\nρ - density\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.LiquidIcePotTempSHumNonEquil_given_pressure","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.LiquidIcePotTempSHumNonEquil_given_pressure","text":"LiquidIcePotTempSHumNonEquil_given_pressure(θ_liq_ice, q_pt, p)\n\nConstructs a PhaseNonEquil thermodynamic state from:\n\nθ_liq_ice - liquid-ice potential temperature\nq_pt - phase partition\np - pressure\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"air_density\nair_pressure\nair_temperature\nair_temperature_from_liquid_ice_pottemp\ncp_m\ncv_m\ndry_pottemp\nexner\ngas_constant_air\nIce\ninternal_energy\ninternal_energy_sat\nlatent_heat_fusion\nlatent_heat_sublim\nlatent_heat_vapor\nLiquid\nliquid_fraction_equil\nliquid_fraction_nonequil\nliquid_ice_pottemp\nliquid_ice_pottemp_sat\nmoist_gas_constants\nsaturation_adjustment\nsaturation_excess\nq_vap_saturation\nq_vap_saturation_generic\nsaturation_vapor_pressure\nsoundspeed_air\nspecific_volume\ntotal_energy\nvirtual_pottemp","category":"page"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.air_density","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.air_density","text":"air_density(T, p[, q::PhasePartition])\n\nThe (moist-)air density from the equation of state (ideal gas law) where\n\nT air temperature\np pressure\n\nand, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\nair_density(ts::ThermodynamicState)\n\nThe (moist-)air density from the equation of state (ideal gas law), given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.air_pressure","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.air_pressure","text":"air_pressure(T, ρ[, q::PhasePartition])\n\nThe air pressure from the equation of state (ideal gas law) where:\n\nT air temperature\nρ (moist-)air density\n\nand, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\nair_pressure(ts::ThermodynamicState)\n\nThe air pressure from the equation of state (ideal gas law), given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.air_temperature","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.air_temperature","text":"air_temperature(e_int, q::PhasePartition)\n\nThe air temperature, where\n\ne_int internal energy per unit mass\n\nand, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\nair_temperature(ts::ThermodynamicState)\n\nThe air temperature, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.air_temperature_from_liquid_ice_pottemp","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.air_temperature_from_liquid_ice_pottemp","text":"air_temperature_from_liquid_ice_pottemp(θ_liq_ice, ρ, q::PhasePartition)\n\nAir temperature T = θ_liq-ice*(ρ*R_m*θ_liq-iceMSLP)^R_mc_vm + latent_heat_liq_ice(q)c_vm given\n\nθ_liq_ice liquid-ice potential temperature\nρ (moist-)air density\n\nand, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.cp_m","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.cp_m","text":"cp_m([q::PhasePartition])\n\nThe isobaric specific heat capacity of moist air where, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\ncp_m(ts::ThermodynamicState)\n\nThe isobaric specific heat capacity of moist air, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.cv_m","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.cv_m","text":"cv_m([q::PhasePartition])\n\nThe isochoric specific heat capacity of moist air where optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\ncv_m(ts::ThermodynamicState)\n\nThe isochoric specific heat capacity of moist air given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.dry_pottemp","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.dry_pottemp","text":"dry_pottemp(T, ρ[, q::PhasePartition])\n\nThe dry potential temperature where\n\nT temperature\nρ (moist-)air density\n\nand, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\n\n\ndry_pottemp(ts::ThermodynamicState)\n\nThe dry potential temperature, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.exner","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.exner","text":"exner(T, ρ[, q::PhasePartition)])\n\nThe Exner function where\n\nT temperature\nρ (moist-)air density\n\nand, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\nexner(ts::ThermodynamicState)\n\nThe Exner function, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.gas_constant_air","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.gas_constant_air","text":"gas_constant_air([q::PhasePartition])\n\nThe specific gas constant of moist air given\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\ngas_constant_air(ts::ThermodynamicState)\n\nThe specific gas constant of moist air given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.Ice","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.Ice","text":"Ice <: Phase\n\nAn ice phase, to dispatch over saturation_vapor_pressure and q_vap_saturation_generic.\n\n\n\n\n\n","category":"type"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.internal_energy","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.internal_energy","text":"internal_energy(T[, q::PhasePartition])\n\nThe internal energy per unit mass, given a thermodynamic state ts or\n\nT temperature\n\nand, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\ninternal_energy(ts::ThermodynamicState)\n\nThe internal energy per unit mass, given a thermodynamic state ts.\n\n\n\n\n\ninternal_energy(ρ::FT, ρe::FT, ρu::AbstractVector{FT}, e_pot::FT)\n\nThe internal energy per unit mass, given\n\nρ (moist-)air density\nρe total energy\nρu momentum vector\ne_pot potential energy (e.g., gravitational) per unit mass\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.internal_energy_sat","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.internal_energy_sat","text":"internal_energy_sat(T, ρ, q_tot)\n\nThe internal energy per unit mass in thermodynamic equilibrium at saturation where\n\nT temperature\nρ (moist-)air density\nq_tot total specific humidity\n\n\n\n\n\ninternal_energy_sat(ts::ThermodynamicState)\n\nThe internal energy per unit mass in thermodynamic equilibrium at saturation, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.latent_heat_fusion","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.latent_heat_fusion","text":"latent_heat_fusion(T::FT) where {FT<:Real}\n\nThe specific latent heat of fusion where\n\nT temperature\n\n\n\n\n\nlatent_heat_fusion(ts::ThermodynamicState)\n\nThe specific latent heat of fusion given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.latent_heat_sublim","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.latent_heat_sublim","text":"latent_heat_sublim(T::FT) where {FT<:Real}\n\nThe specific latent heat of sublimation where\n\nT temperature\n\n\n\n\n\nlatent_heat_sublim(ts::ThermodynamicState)\n\nThe specific latent heat of sublimation given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.latent_heat_vapor","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.latent_heat_vapor","text":"latent_heat_vapor(T::FT) where {FT<:Real}\n\nThe specific latent heat of vaporization where\n\nT temperature\n\n\n\n\n\nlatent_heat_vapor(ts::ThermodynamicState)\n\nThe specific latent heat of vaporization given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.Liquid","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.Liquid","text":"Liquid <: Phase\n\nA liquid phase, to dispatch over saturation_vapor_pressure and q_vap_saturation_generic.\n\n\n\n\n\n","category":"type"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.liquid_fraction_equil","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.liquid_fraction_equil","text":"liquid_fraction_equil(T[, q::PhasePartition])\n\nThe fraction of condensate, assuming phase equilibrium, that is liquid where\n\nT temperature\nq PhasePartition\n\nIf q.liq or q.ice are nonzero, the liquid fraction is computed from them.\n\nOtherwise, the fraction of liquid is a function that is 1 above T_freeze and goes to zero below T_freeze.\n\n\n\n\n\nliquid_fraction_equil(ts::ThermodynamicState)\n\nThe fraction of condensate that is liquid given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.liquid_fraction_nonequil","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.liquid_fraction_nonequil","text":"liquid_fraction_nonequil(T[, q::PhasePartition])\n\nThe fraction of condensate, assuming phase non-equilibrium, that is liquid where\n\nT temperature\nq PhasePartition\n\nIf q.liq or q.ice are nonzero, the liquid fraction is computed from them.\n\nOtherwise, the fraction of liquid is a function that is 1 above T_freeze and goes to zero below T_freeze.\n\ntodo: Todo\nCurrently liquid_fraction_nonequil calls liquid_fraction_equil, but we should implement a more general function here.\n\n\n\n\n\nliquid_fraction_nonequil(ts::ThermodynamicState)\n\nThe fraction of condensate that is liquid given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.liquid_ice_pottemp","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.liquid_ice_pottemp","text":"liquid_ice_pottemp(T, ρ, q::PhasePartition)\n\nThe liquid-ice potential temperature where\n\nT temperature\nρ (moist-)air density\n\nand, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\nliquid_ice_pottemp(ts::ThermodynamicState)\n\nThe liquid-ice potential temperature, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.liquid_ice_pottemp_sat","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.liquid_ice_pottemp_sat","text":"liquid_ice_pottemp_sat(T, ρ[, q::PhasePartition])\n\nThe saturated liquid ice potential temperature where\n\nT temperature\nρ (moist-)air density\n\nand, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\nliquid_ice_pottemp_sat(T, ρ, q_tot)\n\nThe saturated liquid ice potential temperature where\n\nT temperature\nρ (moist-)air density\nq_tot total specific humidity\n\n\n\n\n\nliquid_ice_pottemp_sat(ts::ThermodynamicState)\n\nThe liquid potential temperature given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.saturation_adjustment","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.saturation_adjustment","text":"saturation_adjustment(e_int, ρ, q_tot)\n\nCompute the temperature that is consistent with\n\ne_int internal energy\nρ (moist-)air density\nq_tot total specific humidity\n\nSee also saturation_adjustment_q_tot_θ_liq_ice.\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.saturation_excess","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.saturation_excess","text":"saturation_excess(T, ρ, q::PhasePartition)\n\nThe saturation excess in equilibrium where\n\nT temperature\nρ (moist-)air density\nq PhasePartition\n\nThe saturation excess is the difference between the total specific humidity q.tot and the saturation specific humidity in equilibrium, and it is defined to be nonzero only if this difference is positive.\n\n\n\n\n\nsaturation_excess(ts::ThermodynamicState)\n\nCompute the saturation excess in equilibrium, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.q_vap_saturation","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.q_vap_saturation","text":"q_vap_saturation(T, ρ[, q::PhasePartition])\n\nCompute the saturation specific humidity, given\n\nT temperature\nρ (moist-)air density\n\nand, optionally,\n\nq PhasePartition\n\nIf the PhasePartition q is given, the saturation specific humidity is that of a mixture of liquid and ice, computed in a thermodynamically consistent way from the weighted sum of the latent heats of the respective phase transitions (Pressel et al., JAMES, 2015). That is, the saturation vapor pressure and from it the saturation specific humidity are computed from a weighted mean of the latent heats of vaporization and sublimation, with the weights given by the fractions of condensates q.liq/(q.liq + q.ice) and q.ice/(q.liq + q.ice) that are liquid and ice, respectively.\n\nIf the PhasePartition q is not given, or has zero liquid and ice specific humidities, the saturation specific humidity is that over a mixture of liquid and ice, with the fraction of liquid given by temperature dependent liquid_fraction_equil(T) and the fraction of ice by the complement 1 - liquid_fraction_equil(T).\n\n\n\n\n\nq_vap_saturation(ts::ThermodynamicState)\n\nCompute the saturation specific humidity, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.q_vap_saturation_generic","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.q_vap_saturation_generic","text":"q_vap_saturation_generic(T, ρ[; phase=Liquid()])\n\nCompute the saturation specific humidity over a plane surface of condensate, given\n\nT temperature\nρ (moist-)air density\n\nand, optionally,\n\nLiquid() indicating condensate is liquid\nIce() indicating condensate is ice\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.saturation_vapor_pressure","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.saturation_vapor_pressure","text":"saturation_vapor_pressure(T, Liquid())\n\nReturn the saturation vapor pressure over a plane liquid surface at temperature T.\n\nsaturation_vapor_pressure(T, Ice())\n\nReturn the saturation vapor pressure over a plane ice surface at temperature T.\n\nsaturation_vapor_pressure(T, LH_0, Δcp)\n\nCompute the saturation vapor pressure over a plane surface by integration of the Clausius-Clepeyron relation.\n\nThe Clausius-Clapeyron relation\n\ndlog(p_v_sat)/dT = [LH_0 + Δcp * (T-T_0)]/(R_v*T^2)\n\nis integrated from the triple point temperature T_triple, using Kirchhoff's relation\n\nL = LH_0 + Δcp * (T - T_0)\n\nfor the specific latent heat L with constant isobaric specific heats of the phases. The linear dependence of the specific latent heat on temperature T allows analytic integration of the Clausius-Clapeyron relation to obtain the saturation vapor pressure p_v_sat as a function of the triple point pressure press_triple.\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.soundspeed_air","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.soundspeed_air","text":"soundspeed_air(T[, q::PhasePartition])\n\nThe speed of sound in air, where\n\nT temperature\n\nand, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\nWithout the specific humidity arguments, the results are that of dry air.\n\n\n\n\n\nsoundspeed_air(ts::ThermodynamicState)\n\nThe speed of sound in air given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.specific_volume","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.specific_volume","text":"specific_volume(T, p[, q::PhasePartition])\n\nThe (moist-)air specific volume from the equation of state (ideal gas law) where\n\nT air temperature\np pressure\n\nand, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\nspecific_volume(ts::ThermodynamicState)\n\nThe (moist-)air specific volume from the equation of state (ideal gas law), given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.total_energy","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.total_energy","text":"total_energy(e_kin, e_pot, T[, q::PhasePartition])\n\nThe total energy per unit mass, given\n\ne_kin kinetic energy per unit mass\ne_pot potential energy per unit mass\nT temperature\n\nand, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\ntotal_energy(e_kin, e_pot, ts::ThermodynamicState)\n\nThe total energy per unit mass given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Common/MoistThermodynamics.html#CLIMA.MoistThermodynamics.virtual_pottemp","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.virtual_pottemp","text":"virtual_pottemp(T, ρ[, q::PhasePartition])\n\nThe virtual temperature where\n\nT temperature\nρ (moist-)air density\n\nand, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\nvirtual_pottemp(ts::ThermodynamicState)\n\nThe virtual potential temperature, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"index.html#CLIMA-1","page":"Home","title":"CLIMA","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Climate Machine","category":"page"},{"location":"VariableList.html#CliMA-Variable-List-1","page":"CliMA Variable List","title":"CliMA Variable List","text":"","category":"section"},{"location":"VariableList.html#","page":"CliMA Variable List","title":"CliMA Variable List","text":"This document is currently for collaborators within the project with access to the Overleaf CliMA-Atmos docs. The purpose of this page is to unify the naming conventions used in the Overleaf document in a manner useful for coding. This document suggests 'reserved' variable names in <property>_<species> format with the default working fluid (no-subscript) being moist air. Contributors to the CliMA repository are welcome to suggest changes when necessary.","category":"page"},{"location":"VariableList.html#Type-parameters-1","page":"CliMA Variable List","title":"Type parameters","text":"","category":"section"},{"location":"VariableList.html#","page":"CliMA Variable List","title":"CliMA Variable List","text":"The Julia code typically uses T as a type parameter, however this conflicts with the typical usage for temperature. Instead, good choices are:","category":"page"},{"location":"VariableList.html#","page":"CliMA Variable List","title":"CliMA Variable List","text":"FT for floating point values","category":"page"},{"location":"VariableList.html#Names-reserved-for-'use-and-throw'-/-debug-variables-1","page":"CliMA Variable List","title":"Names reserved for 'use and throw' / debug variables","text":"","category":"section"},{"location":"VariableList.html#","page":"CliMA Variable List","title":"CliMA Variable List","text":"dummy\nscratch","category":"page"},{"location":"VariableList.html#.1-Working-Fluid-and-Equation-of-State-1","page":"CliMA Variable List","title":"2.1  Working Fluid and Equation of State","text":"","category":"section"},{"location":"VariableList.html#","page":"CliMA Variable List","title":"CliMA Variable List","text":"q_dry = dry air mass fraction\nq_vap = specific humidity, vapour\nq_liq = specific humidity, liquid\nq_ice = specific humidity, ice\nq_con = specific humidity, condensate\nq_tot = specific humidity, total\n\nP_<species>     = pressure, species (no subscript == default working fluid moist air)\nρ_<species>     = density, species (no subscript == default working fluid moist air)\nR_m             = gas constant, moist\nR_d             = gas constant, dry\nR_v             = gas constant, water vapour\nT               = temperature, moist air\nT_<species>     = temperature, species","category":"page"},{"location":"VariableList.html#.2-Mass-Balance-1","page":"CliMA Variable List","title":"2.2 Mass Balance","text":"","category":"section"},{"location":"VariableList.html#","page":"CliMA Variable List","title":"CliMA Variable List","text":"dt              = time increment\nu               = x-velocity\nv               = y-velocity\nw               = z-velocity\nU               = x-momentum\nV               = y-momentum\nW               = z=momentum","category":"page"},{"location":"VariableList.html#.3-Moisture-balances-1","page":"CliMA Variable List","title":"2.3 Moisture balances","text":"","category":"section"},{"location":"VariableList.html#","page":"CliMA Variable List","title":"CliMA Variable List","text":"source_qt           = local source/sink of water mass [S_qt]\ndiffusiveflux_vap   = diffusive flux, water vapour\ndiffusiveflux_liq   = diffusive flux, cloud liquid\ndiffusiveflux_ice   = diffusive flux, cloud ice\ndiffusiveflux_tot   = diffusive flux, total","category":"page"},{"location":"VariableList.html#.4-Momentum-balances-1","page":"CliMA Variable List","title":"2.4 Momentum balances","text":"","category":"section"},{"location":"VariableList.html#","page":"CliMA Variable List","title":"CliMA Variable List","text":"U               = x-momentum\nV               = y-momentum\nW               = z-momentum (2D/3D: this is the vertical coordinate)\nΩ_x             = x-angular momentum\nΩ_y             = y-angular momentum\nΩ_z             = z-angular momentum\nτ_xx            = stress tensor ((1,1) component)\nτ_<ij>          = replace ij with combination of x/y/z to recover appropriate value\nλ_stokes        = Stokes parameter","category":"page"},{"location":"VariableList.html#.5-Energy-balance-1","page":"CliMA Variable List","title":"2.5 Energy balance","text":"","category":"section"},{"location":"VariableList.html#","page":"CliMA Variable List","title":"CliMA Variable List","text":"<Lower case e_<type> suggests specific (per unit mass) quantities>\ne_kin_<spe>      = specific energy per unit volume, kinetic\ne_pot_<spe>      = specific energy per unit volume, potential\ne_int_<spe>      = specific energy per unit volume, internal\ne_tot_<spe>      = specific energy per unit volume, total\n\nE_kin_<spe>      = energy, kinetic\nE_pot_<spe>      = energy, potential\nE_int_<spe>      = energy, internal\nE_tot_<spe>      = energy, total\n\ncv_m             = isochoric specific heat, moist air\ncv_d             = isochoric specific heat, dry air\ncv_l             = isochoric specific heat, liquid water\ncv_v             = isochoric specific heat, water vapour\ncv_i             = isochoric specific heat, ice\n\ncp_m             = isobaric specific heat, moist air\ncp_d             = isobaric specific heat, dry air\ncp_l             = isobaric specific heat, liquid water\ncp_v             = isobaric specific heat, water vapour\ncp_i             = isobaric specific heat, ice","category":"page"},{"location":"VariableList.html#.6-Microphysics-1","page":"CliMA Variable List","title":"2.6 Microphysics","text":"","category":"section"},{"location":"VariableList.html#","page":"CliMA Variable List","title":"CliMA Variable List","text":"q_rai = specific humidity, rain [kg/kg]\n\nterminal_velocity = mass weighted average rain fall speed [m/s]\n\nconv_q_vap_to_q_liq      = tendency to q_liq and q_ice due to\n                           condensation/evaporation and\n                           sublimation/resublimation from q_vap [1/s]\nconv_q_liq_to_q_rai_acnv = tendency to q_rai due to autoconversion from q_liq [1/s]\nconv_q_liq_to_q_rai_accr = tendency to q_rai due to accretion from q_liq [1/s]\nconv_q_rai_to_q_vap      = tendency to q_vap due to evaporation from q_rai [1/s]","category":"page"},{"location":"VariableList.html#TODO-1","page":"CliMA Variable List","title":"TODO","text":"","category":"section"},{"location":"VariableList.html#","page":"CliMA Variable List","title":"CliMA Variable List","text":"Update with list of additional parameters / source terms as necessary","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"EditURL = \"https://github.com/climate-machine/CLIMA/blob/master/examples/DGmethods_old/ex_003_acoustic_wave.jl\"","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#Example-003:-Acoustic-Wave-on-Sphere-1","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"jupyter: Jupyter\nThis example is also available as a Jupyter notebook: ex_003_acoustic_wave.ipynb","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#Introduction-1","page":"Example 003: Acoustic Wave on Sphere","title":"Introduction","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"In this example we will set up and run the acoustic wave test problem from Tomita and Satoh (2004).","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"@article{TomitaSatoh2004,\n  author = {Hirofumi Tomita and Masaki Satoh},\n  title = {A new dynamical framework of nonhydrostatic global model using the\n           icosahedral grid},\n  journal = {Fluid Dynamics Research},\n  volume = {34},\n  number = {6},\n  pages = {357-400},\n  year = {2004},\n  doi = {10.1016/j.fluiddyn.2004.03.003},\n}","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"Below is a program interspersed with comments. The full program, without comments, can be found in the next section.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#Commented-Program-1","page":"Example 003: Acoustic Wave on Sphere","title":"Commented Program","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#Preliminaries-1","page":"Example 003: Acoustic Wave on Sphere","title":"Preliminaries","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"Load in modules needed for solving the problem","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"using MPI\nusing Logging\nusing LinearAlgebra\nusing Dates\nusing Printf\nusing CLIMA\nusing CLIMA.Mesh.Topologies\nusing CLIMA.MPIStateArrays\nusing CLIMA.Mesh.Grids\nusing CLIMA.DGBalanceLawDiscretizations\nusing CLIMA.DGBalanceLawDiscretizations.NumericalFluxes\nusing CLIMA.VTK\nusing CLIMA.LowStorageRungeKuttaMethod\nusing CLIMA.ODESolvers\nusing CLIMA.GenericCallbacks","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"Though not required, here we are explicit about which values we read out the PlanetParameters and MoistThermodynamics","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"using CLIMA.PlanetParameters: planet_radius, grav, MSLP\nusing CLIMA.MoistThermodynamics: air_temperature, air_pressure, internal_energy,\n                                 soundspeed_air, air_density, gas_constant_air","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"Start up MPI if this has not already been done","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"MPI.Initialized() || MPI.Init()\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"If CuArrays is in the current environment we will use CUDA, otherwise we drop back to the CPU","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"@static if haspkg(\"CuArrays\")\n  using CUDAdrv\n  using CUDAnative\n  using CuArrays\n  CuArrays.allowscalar(false)\n  const DeviceArrayType = CuArray\nelse\n  const DeviceArrayType = Array\nend\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"Specify whether to enforce hydrostatic balance at PDE level or not","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"const PDE_level_hydrostatic_balance = true","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"check whether to use default VTK directory or define something else","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"VTKDIR = get(ENV, \"CLIMA_VTK_DIR\", \"vtk\")","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"Here we setup constants to for some of the computational parameters; the underscore is just syntactic sugar to indicate that these are constants.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"These are parameters related to the Euler state. Here we used the conserved variables for the state: perturbation in density, three components of momentum, and perturbation to the total energy.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"const _nstate = 5\nconst _dρ, _ρu, _ρv, _ρw, _dρe = 1:_nstate\nconst _statenames = (\"δρ\", \"ρu\", \"ρv\", \"ρw\", \"δρe\")\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"These will be the auxiliary state which will contain the geopotential, gradient of the geopotential, and reference values for density and total energy","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"const _nauxstate = 6\nconst _a_ϕ, _a_ϕx, _a_ϕy, _a_ϕz, _a_ρ_ref, _a_ρe_ref = 1:_nauxstate\nconst _auxnames = (\"ϕ\", \"ϕx\", \"ϕy\", \"ϕz\", \"ρ_ref\", \"ρe_ref\")\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#Definition-of-the-physics-1","page":"Example 003: Acoustic Wave on Sphere","title":"Definition of the physics","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"Now we define a function which given the state and auxiliary state defines the physical Euler flux","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"function eulerflux!(F, Q, _, aux, t)\n  @inbounds begin\n    # extract the states\n    dρ, ρu, ρv, ρw, dρe = Q[_dρ], Q[_ρu], Q[_ρv], Q[_ρw], Q[_dρe]\n    ρ_ref, ρe_ref, ϕ = aux[_a_ρ_ref], aux[_a_ρe_ref], aux[_a_ϕ]\n\n    ρ = ρ_ref + dρ\n    ρe = ρe_ref + dρe\n    e = ρe / ρ\n\n    # compute the velocity\n    u, v, w = ρu / ρ, ρv / ρ, ρw / ρ\n\n    # internal energy\n    e_int = e - (u^2 + v^2 + w^2)/2 - ϕ\n\n    # compute the pressure\n    T = air_temperature(e_int)\n    P = air_pressure(T, ρ)\n\n    e_ref_int = ρe_ref / ρ_ref - ϕ\n    T_ref = air_temperature(e_ref_int)\n    P_ref = air_pressure(T_ref, ρ_ref)\n\n    # set the actual flux\n    F[1, _dρ ], F[2, _dρ ], F[3, _dρ ] = ρu          , ρv          , ρw\n    if PDE_level_hydrostatic_balance\n      δP = P - P_ref\n      F[1, _ρu], F[2, _ρu], F[3, _ρu] = u * ρu  + δP, v * ρu     , w * ρu\n      F[1, _ρv], F[2, _ρv], F[3, _ρv] = u * ρv      , v * ρv + δP, w * ρv\n      F[1, _ρw], F[2, _ρw], F[3, _ρw] = u * ρw      , v * ρw     , w * ρw + δP\n    else\n      F[1, _ρu], F[2, _ρu], F[3, _ρu] = u * ρu  + P, v * ρu    , w * ρu\n      F[1, _ρv], F[2, _ρv], F[3, _ρv] = u * ρv     , v * ρv + P, w * ρv\n      F[1, _ρw], F[2, _ρw], F[3, _ρw] = u * ρw     , v * ρw    , w * ρw + P\n    end\n    F[1, _dρe], F[2, _dρe], F[3, _dρe] = u * (ρe + P), v * (ρe + P), w * (ρe + P)\n  end\nend\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"Define the geopotential source from the solution and auxiliary variables","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"function geopotential!(S, Q, aux, t)\n  @inbounds begin\n    ρ_ref, ϕx, ϕy, ϕz = aux[_a_ρ_ref], aux[_a_ϕx], aux[_a_ϕy], aux[_a_ϕz]\n    dρ = Q[_dρ]\n    S[_dρ ] = 0\n    if PDE_level_hydrostatic_balance\n      S[_ρu ] = -dρ * ϕx\n      S[_ρv ] = -dρ * ϕy\n      S[_ρw ] = -dρ * ϕz\n    else\n      ρ = ρ_ref + dρ\n      S[_ρu ] = -ρ * ϕx\n      S[_ρv ] = -ρ * ϕy\n      S[_ρw ] = -ρ * ϕz\n    end\n    S[_dρe] = 0\n  end\nend\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"This defines the local wave speed from the current state (this will be needed to define the numerical flux)","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"function wavespeed(n, Q, aux, _...)\n  @inbounds begin\n    ρ_ref, ρe_ref, ϕ = aux[_a_ρ_ref], aux[_a_ρe_ref], aux[_a_ϕ]\n    dρ, ρu, ρv, ρw, dρe = Q[_dρ], Q[_ρu], Q[_ρv], Q[_ρw], Q[_dρe]\n\n    # get total energy and density\n    ρ = ρ_ref + dρ\n    e = (ρe_ref + dρe) / ρ\n\n    # velocity field\n    u, v, w = ρu / ρ, ρv / ρ, ρw / ρ\n\n    # internal energy\n    e_int = e - (u^2 + v^2 + w^2)/2 - ϕ\n\n    # compute the temperature\n    T = air_temperature(e_int)\n\n    abs(n[1] * u + n[2] * v + n[3] * w) + soundspeed_air(T)\n  end\nend\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"The only boundary condition needed for this test problem is the no flux boundary condition, the state for which is defined below. This function defines the plus-side (exterior) values from the minus-side (inside) values. This plus-side value will then be fed into the numerical flux routine in order to enforce the boundary condition.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"function nofluxbc!(QP, _, _, nM, QM, _, auxM, _...)\n  @inbounds begin\n    FT = eltype(QM)\n    # get the minus values\n    dρM, ρuM, ρvM, ρwM, dρeM = QM[_dρ], QM[_ρu], QM[_ρv], QM[_ρw], QM[_dρe]\n\n    # scalars are preserved\n    dρP, dρeP = dρM, dρeM\n\n    # vectors are reflected\n    nx, ny, nz = nM[1], nM[2], nM[3]\n\n    # reflect velocities\n    mag_ρu⃗ = nx * ρuM + ny * ρvM + nz * ρwM\n    ρuP = ρuM - 2mag_ρu⃗ * nx\n    ρvP = ρvM - 2mag_ρu⃗ * ny\n    ρwP = ρwM - 2mag_ρu⃗ * nz\n\n    # Construct QP state\n    QP[_dρ], QP[_ρu], QP[_ρv], QP[_ρw], QP[_dρe] = dρP, ρuP, ρvP, ρwP, dρeP\n  end\nend\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#Definition-of-the-problem-1","page":"Example 003: Acoustic Wave on Sphere","title":"Definition of the problem","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"Here we define the initial condition as well as the auxiliary state (which contains the reference state on which the initial condition depends)","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"First it is useful to have a conversion function going between Cartesian and spherical coordinates (defined here in terms of radians)","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"function cartesian_to_spherical(FT, x, y, z)\n    r = hypot(x, y, z)\n    λ = atan(y, x)\n    φ = asin(z / r)\n    (r, λ, φ)\nend\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"Set up the geopotential and the background reference states. The temperature T0 is the isothermal state defined in Tomita and Satoh (2004) to be 300 K.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"function auxiliary_state_initialization!(T0, aux, x, y, z)\n  @inbounds begin\n    FT = eltype(aux)\n    p0 = FT(MSLP)\n\n    # Convert to Spherical coordinates\n    (r, _, _) = cartesian_to_spherical(FT, x, y, z)\n\n    # Calculate the geopotential ϕ\n    h = r - FT(planet_radius) # height above the planet surface\n    ϕ = FT(grav) * h\n\n    # Pressure assuming hydrostatic balance\n    P_ref = p0 * exp(-ϕ / (gas_constant_air(FT) * T0))\n\n    # Density from the ideal gas law\n    ρ_ref = air_density(FT(T0), P_ref)\n\n    # Calculate the reference total potential energy\n    e_int = internal_energy(FT(T0))\n    ρe_ref = e_int * ρ_ref + ρ_ref * ϕ\n\n    # Fill the auxiliary state array\n    aux[_a_ϕ] = ϕ\n    # gradient of the geopotential will be computed numerical below\n    aux[_a_ϕx] = 0\n    aux[_a_ϕy] = 0\n    aux[_a_ϕz] = 0\n    aux[_a_ρ_ref] = ρ_ref\n    aux[_a_ρe_ref] = ρe_ref\n  end\nend\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"Setup the initial condition based on Tomita and Satoh (2004). domain_height is the height above the planet surface of the top of the atmosphere; defined in Tomita and Satoh (2004) to be 10 km.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"function initialcondition!(domain_height, Q, x, y, z, aux, _...)\n  @inbounds begin\n    FT = eltype(Q)\n    p0 = FT(MSLP)\n\n    (r, λ, φ) = cartesian_to_spherical(FT, x, y, z)\n    h = r - FT(planet_radius)\n\n    # Get the reference pressure from the previously defined reference state\n    ρ_ref, ρe_ref, ϕ = aux[_a_ρ_ref], aux[_a_ρe_ref], aux[_a_ϕ]\n    e_ref_int = ρe_ref / ρ_ref - ϕ\n    T_ref = air_temperature(e_ref_int)\n    P_ref = air_pressure(T_ref, ρ_ref)\n\n    # Define the initial pressure Perturbation\n    α, nv, γ = 3, 1, 100\n    β = min(FT(1), α * acos(cos(φ) * cos(λ)))\n    f = (1 + cos(π * β)) / 2\n    g = sin(nv * π * h / domain_height)\n    dP = γ * f * g\n\n    # Define the initial pressure and compute the density perturbation\n    P = P_ref + dP\n    ρ = air_density(T_ref, P)\n    dρ = ρ - ρ_ref\n\n    # Define the initial total energy perturbation\n    e_int = internal_energy(T_ref)\n    ρe = e_int * ρ + ρ * ϕ\n    dρe = ρe - ρe_ref\n\n    # Store Initial conditions\n    Q[_dρ], Q[_ρu], Q[_ρv], Q[_ρw], Q[_dρe] = dρ, 0, 0, 0, dρe\n  end\nend\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"This function compute the pressure perturbation for a given state. It will be used only in the computation of the pressure perturbation prior to writing the VTK output.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"function compute_δP!(δP, Q, _, aux)\n  @inbounds begin\n    # extract the states\n    dρ, ρu, ρv, ρw, dρe = Q[_dρ], Q[_ρu], Q[_ρv], Q[_ρw], Q[_dρe]\n    ρ_ref, ρe_ref, ϕ = aux[_a_ρ_ref], aux[_a_ρe_ref], aux[_a_ϕ]\n\n    # Compute the reference pressure\n    e_ref_int = ρe_ref / ρ_ref - ϕ\n    T_ref = air_temperature(e_ref_int)\n    P_ref = air_pressure(T_ref, ρ_ref)\n\n    # Compute the fulle states\n    ρ = ρ_ref + dρ\n    ρe = ρe_ref + dρe\n    e = ρe / ρ\n\n    # compute the velocity\n    u, v, w = ρu / ρ, ρv / ρ, ρw / ρ\n\n    # internal energy\n    e_int = e - (u^2 + v^2 + w^2)/2 - ϕ\n\n    # compute the pressure\n    T = air_temperature(e_int)\n    P = air_pressure(T, ρ)\n\n    # store the pressure perturbation\n    δP[1] = P - P_ref\n  end\nend\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#Initialize-the-DG-Method-1","page":"Example 003: Acoustic Wave on Sphere","title":"Initialize the DG Method","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"function setupDG(mpicomm, Ne_vertical, Ne_horizontal, polynomialorder,\n                 ArrayType, domain_height, T0, FT)\n\n  # Create the element grid in the vertical direction\n  Rrange = range(FT(planet_radius), length = Ne_vertical + 1,\n                 stop = planet_radius + domain_height)\n\n  # Set up the mesh topology for the sphere\n  topology = StackedCubedSphereTopology(mpicomm, Ne_horizontal, Rrange)\n\n  # Set up the grid for the sphere. Note that here we need to pass the\n  # `cubedshellwarp` shell `meshwarp` function so that the degrees of freedom\n  # lay on the sphere (and not just stacked cubes)\n  grid = DiscontinuousSpectralElementGrid(topology;\n                                          polynomialorder = polynomialorder,\n                                          FloatType = FT,\n                                          DeviceArray = ArrayType,\n                                          meshwarp = Topologies.cubedshellwarp)\n\n  # Here we use the Rusanov numerical flux which requires the physical flux and\n  # wavespeed\n  numflux!(x...) = NumericalFluxes.rusanov!(x..., eulerflux!, wavespeed)\n\n  # We also use Rusanov to define the numerical boundary flux which also\n  # requires a definition of the state to use for the \"plus\" side of the\n  # boundary face (calculated here with `nofluxbc!`)\n  numbcflux!(x...) = NumericalFluxes.rusanov_boundary_flux!(x..., eulerflux!,\n                                                            nofluxbc!,\n                                                            wavespeed)\n\n  auxinit(x...) = auxiliary_state_initialization!(T0, x...)\n  # Define the balance law solver\n  spatialdiscretization = DGBalanceLaw(grid = grid,\n                                       length_state_vector = _nstate,\n                                       flux! = eulerflux!,\n                                       source! = geopotential!,\n                                       numerical_flux! = numflux!,\n                                       numerical_boundary_flux! = numbcflux!,\n                                       auxiliary_state_length = _nauxstate,\n                                       auxiliary_state_initialization! =\n                                       auxinit,\n                                      )\n\n  # Compute Gradient of Geopotential\n  DGBalanceLawDiscretizations.grad_auxiliary_state!(spatialdiscretization, _a_ϕ,\n                                                    (_a_ϕx, _a_ϕy, _a_ϕz))\n\n  spatialdiscretization\nend\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#Initializing-and-run-the-DG-method-1","page":"Example 003: Acoustic Wave on Sphere","title":"Initializing and run the DG method","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"Note that the final time and grid size are small so that CI and docs generation happens in a reasonable amount of time. Running the simulation to a final time of 33 hours allows the wave to propagate all the way around the sphere and back. Increasing the numeber of horizontal elements to ~30 is required for stable long time simulation.","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"let\n  mpicomm = MPI.COMM_WORLD\n  mpi_logger = ConsoleLogger(MPI.Comm_rank(mpicomm) == 0 ? stderr : devnull)\n\n  # parameters for defining the cubed sphere.\n  Ne_vertical   = 4  # number of vertical elements (small for CI/docs reasons)\n  # Ne_vertical   = 30 # Resolution required for stable long time result\n  # cubed sphere will use Ne_horizontal * Ne_horizontal horizontal elements in\n  # each of the 6 faces\n  Ne_horizontal = 4\n\n  polynomialorder = 5\n\n  # top of the domain and temperature from Tomita and Satoh (2004)\n  domain_height = 10e3\n\n  # isothermal temperature state\n  T0 = 300\n\n  # Floating point type to use in the calculation\n  FT = Float64\n\n  spatialdiscretization = setupDG(mpicomm, Ne_vertical, Ne_horizontal,\n                                  polynomialorder, DeviceArrayType,\n                                  domain_height, T0, FT)\n\n  Q = MPIStateArray(spatialdiscretization,\n                    (x...) -> initialcondition!(domain_height, x...))\n\n  # Since we are using explicit time stepping the acoustic wave speed will\n  # dominate our CFL restriction along with the vertical element size\n  element_size = (domain_height / Ne_vertical)\n  acoustic_speed = soundspeed_air(FT(T0))\n  dt = element_size / acoustic_speed / polynomialorder^2\n\n  # Adjust the time step so we exactly hit 1 hour for VTK output\n  dt = 60 * 60 / ceil(60 * 60 / dt)\n\n  lsrk = LSRK54CarpenterKennedy(spatialdiscretization, Q; dt = dt, t0 = 0)\n\n  # Uncomment line below to extend simulation time and output less frequently\n  #=\n  finaltime = 33 * 60 * 60\n  =#\n  finaltime = 4 * dt # short run just to get docs generated\n\n  outputtime = 60 * 60\n\n  # We will use this array for storing the pressure to write out to VTK\n  δP = MPIStateArray(spatialdiscretization; nstate = 1)\n\n  # Define a convenience function for VTK output\n  mkpath(VTKDIR)\n  function do_output(vtk_step)\n    # name of the file that this MPI rank will write\n    filename = @sprintf(\"%s/acoustic_wave_mpirank%04d_step%04d\",\n                        VTKDIR, MPI.Comm_rank(mpicomm), vtk_step)\n\n    # fill the `δP` array with the pressure perturbation\n    DGBalanceLawDiscretizations.dof_iteration!(compute_δP!, δP,\n                                               spatialdiscretization, Q)\n\n    # write the vtk file for this MPI rank\n    writevtk(filename, Q, spatialdiscretization, _statenames, δP, (\"δP\",))\n\n    # Generate the pvtu file for these vtk files\n    if MPI.Comm_rank(mpicomm) == 0\n      # name of the pvtu file\n      pvtuprefix = @sprintf(\"acoustic_wave_step%04d\", vtk_step)\n\n      # name of each of the ranks vtk files\n      prefixes = ntuple(i->\n                        @sprintf(\"%s/acoustic_wave_mpirank%04d_step%04d\",\n                                 VTKDIR, i-1, vtk_step),\n                        MPI.Comm_size(mpicomm))\n\n      # Write out the pvtu file\n      writepvtu(pvtuprefix, prefixes, (_statenames..., \"δP\",))\n\n      # write that we have written the file\n      with_logger(mpi_logger) do\n        @info @sprintf(\"Done writing VTK: %s\", pvtuprefix)\n      end\n    end\n  end\n\n  # Setup callback for writing VTK every hour of simulation time and dump\n  #initial file\n  vtk_step = 0\n  do_output(vtk_step)\n  cb_vtk = GenericCallbacks.EveryXSimulationSteps(floor(outputtime / dt)) do\n    vtk_step += 1\n    do_output(vtk_step)\n    nothing\n  end\n\n  # Setup a callback to display simulation runtime information\n  starttime = Ref(now())\n  cb_info = GenericCallbacks.EveryXWallTimeSeconds(60, mpicomm) do (init=false)\n    if init\n      starttime[] = now()\n    end\n    with_logger(mpi_logger) do\n      @info @sprintf(\"\"\"Update\n                     simtime = %.16e\n                     runtime = %s\n                     norm(Q) = %.16e\"\"\", ODESolvers.gettime(lsrk),\n                     Dates.format(convert(Dates.DateTime,\n                                          Dates.now()-starttime[]),\n                                  Dates.dateformat\"HH:MM:SS\"),\n                     norm(Q))\n    end\n  end\n\n  solve!(Q, lsrk; timeend = finaltime, callbacks = (cb_vtk, cb_info))\n\nend\nnothing # hide","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#ex_003_acoustic_wave-plain-program-1","page":"Example 003: Acoustic Wave on Sphere","title":"Plain Program","text":"","category":"section"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"Below follows a version of the program without any comments. The file is also available here: ex_003_acoustic_wave.jl","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"using MPI\nusing Logging\nusing LinearAlgebra\nusing Dates\nusing Printf\nusing CLIMA\nusing CLIMA.Mesh.Topologies\nusing CLIMA.MPIStateArrays\nusing CLIMA.Mesh.Grids\nusing CLIMA.DGBalanceLawDiscretizations\nusing CLIMA.DGBalanceLawDiscretizations.NumericalFluxes\nusing CLIMA.VTK\nusing CLIMA.LowStorageRungeKuttaMethod\nusing CLIMA.ODESolvers\nusing CLIMA.GenericCallbacks\n\nusing CLIMA.PlanetParameters: planet_radius, grav, MSLP\nusing CLIMA.MoistThermodynamics: air_temperature, air_pressure, internal_energy,\n                                 soundspeed_air, air_density, gas_constant_air\n\nMPI.Initialized() || MPI.Init()\n\n@static if haspkg(\"CuArrays\")\n  using CUDAdrv\n  using CUDAnative\n  using CuArrays\n  CuArrays.allowscalar(false)\n  const DeviceArrayType = CuArray\nelse\n  const DeviceArrayType = Array\nend\n\nconst PDE_level_hydrostatic_balance = true\n\nVTKDIR = get(ENV, \"CLIMA_VTK_DIR\", \"vtk\")\n\nconst _nstate = 5\nconst _dρ, _ρu, _ρv, _ρw, _dρe = 1:_nstate\nconst _statenames = (\"δρ\", \"ρu\", \"ρv\", \"ρw\", \"δρe\")\n\nconst _nauxstate = 6\nconst _a_ϕ, _a_ϕx, _a_ϕy, _a_ϕz, _a_ρ_ref, _a_ρe_ref = 1:_nauxstate\nconst _auxnames = (\"ϕ\", \"ϕx\", \"ϕy\", \"ϕz\", \"ρ_ref\", \"ρe_ref\")\n\nfunction eulerflux!(F, Q, _, aux, t)\n  @inbounds begin\n    # extract the states\n    dρ, ρu, ρv, ρw, dρe = Q[_dρ], Q[_ρu], Q[_ρv], Q[_ρw], Q[_dρe]\n    ρ_ref, ρe_ref, ϕ = aux[_a_ρ_ref], aux[_a_ρe_ref], aux[_a_ϕ]\n\n    ρ = ρ_ref + dρ\n    ρe = ρe_ref + dρe\n    e = ρe / ρ\n\n    # compute the velocity\n    u, v, w = ρu / ρ, ρv / ρ, ρw / ρ\n\n    # internal energy\n    e_int = e - (u^2 + v^2 + w^2)/2 - ϕ\n\n    # compute the pressure\n    T = air_temperature(e_int)\n    P = air_pressure(T, ρ)\n\n    e_ref_int = ρe_ref / ρ_ref - ϕ\n    T_ref = air_temperature(e_ref_int)\n    P_ref = air_pressure(T_ref, ρ_ref)\n\n    # set the actual flux\n    F[1, _dρ ], F[2, _dρ ], F[3, _dρ ] = ρu          , ρv          , ρw\n    if PDE_level_hydrostatic_balance\n      δP = P - P_ref\n      F[1, _ρu], F[2, _ρu], F[3, _ρu] = u * ρu  + δP, v * ρu     , w * ρu\n      F[1, _ρv], F[2, _ρv], F[3, _ρv] = u * ρv      , v * ρv + δP, w * ρv\n      F[1, _ρw], F[2, _ρw], F[3, _ρw] = u * ρw      , v * ρw     , w * ρw + δP\n    else\n      F[1, _ρu], F[2, _ρu], F[3, _ρu] = u * ρu  + P, v * ρu    , w * ρu\n      F[1, _ρv], F[2, _ρv], F[3, _ρv] = u * ρv     , v * ρv + P, w * ρv\n      F[1, _ρw], F[2, _ρw], F[3, _ρw] = u * ρw     , v * ρw    , w * ρw + P\n    end\n    F[1, _dρe], F[2, _dρe], F[3, _dρe] = u * (ρe + P), v * (ρe + P), w * (ρe + P)\n  end\nend\n\nfunction geopotential!(S, Q, aux, t)\n  @inbounds begin\n    ρ_ref, ϕx, ϕy, ϕz = aux[_a_ρ_ref], aux[_a_ϕx], aux[_a_ϕy], aux[_a_ϕz]\n    dρ = Q[_dρ]\n    S[_dρ ] = 0\n    if PDE_level_hydrostatic_balance\n      S[_ρu ] = -dρ * ϕx\n      S[_ρv ] = -dρ * ϕy\n      S[_ρw ] = -dρ * ϕz\n    else\n      ρ = ρ_ref + dρ\n      S[_ρu ] = -ρ * ϕx\n      S[_ρv ] = -ρ * ϕy\n      S[_ρw ] = -ρ * ϕz\n    end\n    S[_dρe] = 0\n  end\nend\n\nfunction wavespeed(n, Q, aux, _...)\n  @inbounds begin\n    ρ_ref, ρe_ref, ϕ = aux[_a_ρ_ref], aux[_a_ρe_ref], aux[_a_ϕ]\n    dρ, ρu, ρv, ρw, dρe = Q[_dρ], Q[_ρu], Q[_ρv], Q[_ρw], Q[_dρe]\n\n    # get total energy and density\n    ρ = ρ_ref + dρ\n    e = (ρe_ref + dρe) / ρ\n\n    # velocity field\n    u, v, w = ρu / ρ, ρv / ρ, ρw / ρ\n\n    # internal energy\n    e_int = e - (u^2 + v^2 + w^2)/2 - ϕ\n\n    # compute the temperature\n    T = air_temperature(e_int)\n\n    abs(n[1] * u + n[2] * v + n[3] * w) + soundspeed_air(T)\n  end\nend\n\nfunction nofluxbc!(QP, _, _, nM, QM, _, auxM, _...)\n  @inbounds begin\n    FT = eltype(QM)\n    # get the minus values\n    dρM, ρuM, ρvM, ρwM, dρeM = QM[_dρ], QM[_ρu], QM[_ρv], QM[_ρw], QM[_dρe]\n\n    # scalars are preserved\n    dρP, dρeP = dρM, dρeM\n\n    # vectors are reflected\n    nx, ny, nz = nM[1], nM[2], nM[3]\n\n    # reflect velocities\n    mag_ρu⃗ = nx * ρuM + ny * ρvM + nz * ρwM\n    ρuP = ρuM - 2mag_ρu⃗ * nx\n    ρvP = ρvM - 2mag_ρu⃗ * ny\n    ρwP = ρwM - 2mag_ρu⃗ * nz\n\n    # Construct QP state\n    QP[_dρ], QP[_ρu], QP[_ρv], QP[_ρw], QP[_dρe] = dρP, ρuP, ρvP, ρwP, dρeP\n  end\nend\n\nfunction cartesian_to_spherical(FT, x, y, z)\n    r = hypot(x, y, z)\n    λ = atan(y, x)\n    φ = asin(z / r)\n    (r, λ, φ)\nend\n\nfunction auxiliary_state_initialization!(T0, aux, x, y, z)\n  @inbounds begin\n    FT = eltype(aux)\n    p0 = FT(MSLP)\n\n    # Convert to Spherical coordinates\n    (r, _, _) = cartesian_to_spherical(FT, x, y, z)\n\n    # Calculate the geopotential ϕ\n    h = r - FT(planet_radius) # height above the planet surface\n    ϕ = FT(grav) * h\n\n    # Pressure assuming hydrostatic balance\n    P_ref = p0 * exp(-ϕ / (gas_constant_air(FT) * T0))\n\n    # Density from the ideal gas law\n    ρ_ref = air_density(FT(T0), P_ref)\n\n    # Calculate the reference total potential energy\n    e_int = internal_energy(FT(T0))\n    ρe_ref = e_int * ρ_ref + ρ_ref * ϕ\n\n    # Fill the auxiliary state array\n    aux[_a_ϕ] = ϕ\n    # gradient of the geopotential will be computed numerical below\n    aux[_a_ϕx] = 0\n    aux[_a_ϕy] = 0\n    aux[_a_ϕz] = 0\n    aux[_a_ρ_ref] = ρ_ref\n    aux[_a_ρe_ref] = ρe_ref\n  end\nend\n\nfunction initialcondition!(domain_height, Q, x, y, z, aux, _...)\n  @inbounds begin\n    FT = eltype(Q)\n    p0 = FT(MSLP)\n\n    (r, λ, φ) = cartesian_to_spherical(FT, x, y, z)\n    h = r - FT(planet_radius)\n\n    # Get the reference pressure from the previously defined reference state\n    ρ_ref, ρe_ref, ϕ = aux[_a_ρ_ref], aux[_a_ρe_ref], aux[_a_ϕ]\n    e_ref_int = ρe_ref / ρ_ref - ϕ\n    T_ref = air_temperature(e_ref_int)\n    P_ref = air_pressure(T_ref, ρ_ref)\n\n    # Define the initial pressure Perturbation\n    α, nv, γ = 3, 1, 100\n    β = min(FT(1), α * acos(cos(φ) * cos(λ)))\n    f = (1 + cos(π * β)) / 2\n    g = sin(nv * π * h / domain_height)\n    dP = γ * f * g\n\n    # Define the initial pressure and compute the density perturbation\n    P = P_ref + dP\n    ρ = air_density(T_ref, P)\n    dρ = ρ - ρ_ref\n\n    # Define the initial total energy perturbation\n    e_int = internal_energy(T_ref)\n    ρe = e_int * ρ + ρ * ϕ\n    dρe = ρe - ρe_ref\n\n    # Store Initial conditions\n    Q[_dρ], Q[_ρu], Q[_ρv], Q[_ρw], Q[_dρe] = dρ, 0, 0, 0, dρe\n  end\nend\n\nfunction compute_δP!(δP, Q, _, aux)\n  @inbounds begin\n    # extract the states\n    dρ, ρu, ρv, ρw, dρe = Q[_dρ], Q[_ρu], Q[_ρv], Q[_ρw], Q[_dρe]\n    ρ_ref, ρe_ref, ϕ = aux[_a_ρ_ref], aux[_a_ρe_ref], aux[_a_ϕ]\n\n    # Compute the reference pressure\n    e_ref_int = ρe_ref / ρ_ref - ϕ\n    T_ref = air_temperature(e_ref_int)\n    P_ref = air_pressure(T_ref, ρ_ref)\n\n    # Compute the fulle states\n    ρ = ρ_ref + dρ\n    ρe = ρe_ref + dρe\n    e = ρe / ρ\n\n    # compute the velocity\n    u, v, w = ρu / ρ, ρv / ρ, ρw / ρ\n\n    # internal energy\n    e_int = e - (u^2 + v^2 + w^2)/2 - ϕ\n\n    # compute the pressure\n    T = air_temperature(e_int)\n    P = air_pressure(T, ρ)\n\n    # store the pressure perturbation\n    δP[1] = P - P_ref\n  end\nend\n\nfunction setupDG(mpicomm, Ne_vertical, Ne_horizontal, polynomialorder,\n                 ArrayType, domain_height, T0, FT)\n\n  # Create the element grid in the vertical direction\n  Rrange = range(FT(planet_radius), length = Ne_vertical + 1,\n                 stop = planet_radius + domain_height)\n\n  # Set up the mesh topology for the sphere\n  topology = StackedCubedSphereTopology(mpicomm, Ne_horizontal, Rrange)\n\n  # Set up the grid for the sphere. Note that here we need to pass the\n  # `cubedshellwarp` shell `meshwarp` function so that the degrees of freedom\n  # lay on the sphere (and not just stacked cubes)\n  grid = DiscontinuousSpectralElementGrid(topology;\n                                          polynomialorder = polynomialorder,\n                                          FloatType = FT,\n                                          DeviceArray = ArrayType,\n                                          meshwarp = Topologies.cubedshellwarp)\n\n  # Here we use the Rusanov numerical flux which requires the physical flux and\n  # wavespeed\n  numflux!(x...) = NumericalFluxes.rusanov!(x..., eulerflux!, wavespeed)\n\n  # We also use Rusanov to define the numerical boundary flux which also\n  # requires a definition of the state to use for the \"plus\" side of the\n  # boundary face (calculated here with `nofluxbc!`)\n  numbcflux!(x...) = NumericalFluxes.rusanov_boundary_flux!(x..., eulerflux!,\n                                                            nofluxbc!,\n                                                            wavespeed)\n\n  auxinit(x...) = auxiliary_state_initialization!(T0, x...)\n  # Define the balance law solver\n  spatialdiscretization = DGBalanceLaw(grid = grid,\n                                       length_state_vector = _nstate,\n                                       flux! = eulerflux!,\n                                       source! = geopotential!,\n                                       numerical_flux! = numflux!,\n                                       numerical_boundary_flux! = numbcflux!,\n                                       auxiliary_state_length = _nauxstate,\n                                       auxiliary_state_initialization! =\n                                       auxinit,\n                                      )\n\n  # Compute Gradient of Geopotential\n  DGBalanceLawDiscretizations.grad_auxiliary_state!(spatialdiscretization, _a_ϕ,\n                                                    (_a_ϕx, _a_ϕy, _a_ϕz))\n\n  spatialdiscretization\nend\n\nlet\n  mpicomm = MPI.COMM_WORLD\n  mpi_logger = ConsoleLogger(MPI.Comm_rank(mpicomm) == 0 ? stderr : devnull)\n\n  # parameters for defining the cubed sphere.\n  Ne_vertical   = 4  # number of vertical elements (small for CI/docs reasons)\n  # Ne_vertical   = 30 # Resolution required for stable long time result\n  # cubed sphere will use Ne_horizontal * Ne_horizontal horizontal elements in\n  # each of the 6 faces\n  Ne_horizontal = 4\n\n  polynomialorder = 5\n\n  # top of the domain and temperature from Tomita and Satoh (2004)\n  domain_height = 10e3\n\n  # isothermal temperature state\n  T0 = 300\n\n  # Floating point type to use in the calculation\n  FT = Float64\n\n  spatialdiscretization = setupDG(mpicomm, Ne_vertical, Ne_horizontal,\n                                  polynomialorder, DeviceArrayType,\n                                  domain_height, T0, FT)\n\n  Q = MPIStateArray(spatialdiscretization,\n                    (x...) -> initialcondition!(domain_height, x...))\n\n  # Since we are using explicit time stepping the acoustic wave speed will\n  # dominate our CFL restriction along with the vertical element size\n  element_size = (domain_height / Ne_vertical)\n  acoustic_speed = soundspeed_air(FT(T0))\n  dt = element_size / acoustic_speed / polynomialorder^2\n\n  # Adjust the time step so we exactly hit 1 hour for VTK output\n  dt = 60 * 60 / ceil(60 * 60 / dt)\n\n  lsrk = LSRK54CarpenterKennedy(spatialdiscretization, Q; dt = dt, t0 = 0)\n\n  # Uncomment line below to extend simulation time and output less frequently\n  #=\n  finaltime = 33 * 60 * 60\n  =#\n  finaltime = 4 * dt # short run just to get docs generated\n\n  outputtime = 60 * 60\n\n  # We will use this array for storing the pressure to write out to VTK\n  δP = MPIStateArray(spatialdiscretization; nstate = 1)\n\n  # Define a convenience function for VTK output\n  mkpath(VTKDIR)\n  function do_output(vtk_step)\n    # name of the file that this MPI rank will write\n    filename = @sprintf(\"%s/acoustic_wave_mpirank%04d_step%04d\",\n                        VTKDIR, MPI.Comm_rank(mpicomm), vtk_step)\n\n    # fill the `δP` array with the pressure perturbation\n    DGBalanceLawDiscretizations.dof_iteration!(compute_δP!, δP,\n                                               spatialdiscretization, Q)\n\n    # write the vtk file for this MPI rank\n    writevtk(filename, Q, spatialdiscretization, _statenames, δP, (\"δP\",))\n\n    # Generate the pvtu file for these vtk files\n    if MPI.Comm_rank(mpicomm) == 0\n      # name of the pvtu file\n      pvtuprefix = @sprintf(\"acoustic_wave_step%04d\", vtk_step)\n\n      # name of each of the ranks vtk files\n      prefixes = ntuple(i->\n                        @sprintf(\"%s/acoustic_wave_mpirank%04d_step%04d\",\n                                 VTKDIR, i-1, vtk_step),\n                        MPI.Comm_size(mpicomm))\n\n      # Write out the pvtu file\n      writepvtu(pvtuprefix, prefixes, (_statenames..., \"δP\",))\n\n      # write that we have written the file\n      with_logger(mpi_logger) do\n        @info @sprintf(\"Done writing VTK: %s\", pvtuprefix)\n      end\n    end\n  end\n\n  # Setup callback for writing VTK every hour of simulation time and dump\n  #initial file\n  vtk_step = 0\n  do_output(vtk_step)\n  cb_vtk = GenericCallbacks.EveryXSimulationSteps(floor(outputtime / dt)) do\n    vtk_step += 1\n    do_output(vtk_step)\n    nothing\n  end\n\n  # Setup a callback to display simulation runtime information\n  starttime = Ref(now())\n  cb_info = GenericCallbacks.EveryXWallTimeSeconds(60, mpicomm) do (init=false)\n    if init\n      starttime[] = now()\n    end\n    with_logger(mpi_logger) do\n      @info @sprintf(\"\"\"Update\n                     simtime = %.16e\n                     runtime = %s\n                     norm(Q) = %.16e\"\"\", ODESolvers.gettime(lsrk),\n                     Dates.format(convert(Dates.DateTime,\n                                          Dates.now()-starttime[]),\n                                  Dates.dateformat\"HH:MM:SS\"),\n                     norm(Q))\n    end\n  end\n\n  solve!(Q, lsrk; timeend = finaltime, callbacks = (cb_vtk, cb_info))\n\nend\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/DGmethods_old/generated/ex_003_acoustic_wave.html#","page":"Example 003: Acoustic Wave on Sphere","title":"Example 003: Acoustic Wave on Sphere","text":"This page was generated using Literate.jl.","category":"page"}]
}
